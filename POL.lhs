POL.lhs

Chapter 9 of Haskell road to Logic
  http://homepages.cwi.nl/~jve/HR/

> module POL where
> import Polynomials

9.1 Difference Analysis of Polynomial Sequences
Suppose 
  a = \{a_n\}_n
is a sequence of N, i.e.,
  f = \n -> a_n
is a function in N -> N.

The function f is a polynomial function of degree k iff f can be represented in the form
  c_k*n^k + \cdots + c_1*n + c_0,
with c_i \in Q and c_k \neq 0.

Example 9.1
  *POL> let polynomial n = 2*n^2+n+1
  *POL> take 15 $ map polynomial [0..]
  [1,4,11,22,37,56,79,106,137,172,211,254,301,352,407]

Consider the difference sequence given by the function
  d(f) := \n.a_{n+1} - a_n.

> difs :: (Integral n) => [n] -> [n]
> difs [] = []
> difs [_] = []
> difs (i:jj@(j:js)) = j-i : difs jj

  *POL> difs [1,4,11,22,37,56,79,106,137,172,211,254,301,352,407]
  [3,7,11,15,19,23,27,31,35,39,43,47,51,55]
  *POL> difs it
  [4,4,4,4,4,4,4,4,4,4,4,4,4]

  *POL> difs [-12,-11,6,45,112,213,354,541,780,1077]
  [1,17,39,67,101,141,187,239,297]
  *POL> difs it
  [16,22,28,34,40,46,52,58]
  *POL> difs it
  [6,6,6,6,6,6,6]

Proposition 9.2
If f is a polynomial function of degree k, then d(f) is a polynomial function of degree (k-1).

Proof.
Suppose 
  f(n) = c_k*n^k + \cdots + c_1*n + c_0,
then d(f)(n) is given by
  d(f)(n) 
   := f(n+1) - f(n)
    = c_k*(n+1)^k + c_{k-1}*(n+1)^(k-1) + \cdots + c_1*(n+1) + c_0
       - (c_k*n^k + c_{k-1}*n^(k-1) + \cdots + c_1*n + c_0)
    = k*c_k*n^(k-1) + O(n^(k-2))
where O(n^(k-2)) is some polynomial function of degree (k-2).
(Big-O notation)

Difference Engine (Charles Babbage(1791-1871))

> difLists :: (Integral n) => [[n]] -> [[n]]
> difLists [] = []
> difLists xx@(xs:xss) =
>   if isConst xs then xx
>                 else difLists $ difs xs : xx
>   where
>     isConst (i:jj@(j:js)) = all (==i) jj
>     isConst _ = error "difLists: lack of data, or not a polynomial"

  *POL> difLists [[-12,-11,6,45,112,213,354,541,780,1077]]
  [[6,6,6,6,6,6,6]
  ,[16,22,28,34,40,46,52,58]
  ,[1,17,39,67,101,141,187,239,297]
  ,[-12,-11,6,45,112,213,354,541,780,1077]
  ]

The list of difference can be used to generate the next element of the original sequence: just add the last elements of all the difference lists to the last element of the original sequence.
To get the last elements, we define

> genDifs :: (Integral n) => [n] -> [n]
> genDifs xs = map last $ difLists [xs]

A new list of last elements of difference lists is computed from the current one by keeping the const element d_1, and replacing each d_{i+1} by d_{i}+d_{i+1}:

> nextD :: (Integral n) => [n] -> [n]
> nextD [] = error "nextD: no data"
> nextD [n] = [n]
> nextD (i:j:js) = i : nextD (i+j : js)

The next element of the original sequence is given by the last element of the new list of last elements of difference lists:

> next :: (Integral n) => [n] -> n
> next = last . nextD . genDifs
  
  *POL> next [-12,-11,6,45,112,213,354,541,780,1077]
  1438
  *POL> let f n = n^3+5*n^2-5*n-12
  *POL> take 11 $ map f [0..]
  [-12,-11,6,45,112,213,354,541,780,1077,1438]

All this can now be wrapped in a function that continues any list of polynomial form, provided that enough initial elements are given as data:

> continue :: (Integral n) => [n] -> [n]
> continue xs = map last $ iterate nextD difference
>   where
>     difference = nextD $ genDifs xs

  *POL> take 20 $ continue [-12,-11,6,45,112,213,354,541,780,1077]
  [1438,1869,2376,2965,3642,4413,5284,6261,7350,8557,9888,11349,12946,14685,16572,18613,20814,23181,25720,28437]

  *POL> let f n = n^3+5*n^2-5*n-12
  *POL> take 30 $ map f [0..]
  [-12,-11,6,45,112,213,354,541,780,1077,1438,1869,2376,2965,3642,4413,5284,6261,7350,8557,9888,11349,12946,14685,16572,18613,20814,23181,25720,28437]

If a given list is generated by a polynomial, then the degree of the polynomial can be computed by difference analysis:

> degree :: (Integral n) => [n] -> Int
> degree xs = length (difLists [xs]) -1

9.2 Gaussian Elimination
Here is a conversion function from a list of coefficients to a polynomial.

> -- p2fct :: Num a => [a] -> [a] -> [a]
> -- p2fct [] x = 0
> -- p2fct (c:cs) = c + (x * p2fct as x)

9.3 Polynomials and the Binomial Theorem

9.4 Polynomials for Combinatorial Reasoning
The follwoing gadgets are implmented in Polynomials.hs.

To implement the polynomial functions in a variable z, we will represent a polynomial
  f(z) = f_0 + f_1*z + \cdots + f_n*z^n.
as a list of its coefficients.
  [f_0 .. f_n]

We need some conventions for switching back and forth between a polynomial and its list of coefficients.
If f(z) is a polynomial, then we we use f for its coefficient list.
We've assumed f is non empty and we will indicate 'f for the tail of f:
  f = [f_0, f_1 .. f_n] ==> 'f = [f_1 .. f_n]
Then clearly
  f(z) = f_0 + z*`f(z)

The identity function
  \z -> z
will get represented as
  [0,1]
for this function is of the form
  \z -> f_0+f_1*z
with f_0=0 and f_1=1:
  z = [0,1]

Addition, scalar multiplication and multiplication recursively, see Polynomials.hs.

  *POL> (z+1)^0
  [1]
  *POL> (z+1)^1
  [1,1]
  *POL> (z+1)^2
  [1,2,1]
  *POL> (z+1)^3
  [1,3,3,1]
  *POL> (z+1)^4
  [1,4,6,4,1]
  *POL> (z+1)^10
  [1,10,45,120,210,252,210,120,45,10,1]

For an arbitrary polynomial f(z) of
  [f_0, f_1 .. f_n]
We are interested in the difference list 
  [f_0, f_1-f_0, f_2-f_1 ..].
   
   *POL> delta [2,4,6]
   [2,2,2,-6]

Composition is given by
  f(g(z)) = f_0 + f_1*g(z) + f_2*(g(z))^2 + ..
          = f_0 + g(z)*(f_1 + f_2*g(z) + ..)
          = f_0 + g(z)*'f(g(z))
This observation leads us to write

> comp' _ [] = error "comp': "
> comp' [] _ = []
> comp' (f:fs) gs = [f] + (gs * comp' fs gs)

(In Polynomials.hs, the imprementation is slightly more involved.)

Derivative of f is given by
  [f_1, 2*f_2, 3*f_3 ..]

> -- deriv' :: Num a => [a] -> [a]
> deriv' [] = []
> deriv' (f:fs) = zipWith (*) [1..] fs

  *POL> :t deriv
  deriv :: Num a => [a] -> [a]
  *POL> :t deriv'
  deriv' :: (Num t, Enum t) => [t] -> [t]

  *POL> (z+1)^3
  [1,3,3,1]
  *POL> deriv $ (z+1)^3
  [3,6,3]
  *POL> derivative $ (z+1)^3
  [3,6,3]

