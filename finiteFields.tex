\documentclass[11pt]{book}
\usepackage{amsmath,amssymb}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage[all]{xy}
\usepackage[yyyymmdd]{datetime}
\usepackage{listings}

\usepackage{hyperref}

\DeclareMathOperator*{\colim}{colim}
\DeclareMathOperator*{\coker}{coker}

\begin{document}

\lstset{ language = Haskell
         , numbers = left
         , breaklines = true
         , basicstyle = \small\ttfamily
         }

\newcommand{\Slash}[1]{{\ooalign{\hfil/\crcr$#1$}}}

\title{Finite fields and functional reconstructions}
\author{Ray D. Sameshima}
\date{2016/09/23 $\sim$ \today \, \currenttime}
\maketitle

\tableofcontents

%%%%%%body
\setcounter{chapter}{-1}
\chapter{Preface}
\section{References}
\begin{enumerate}
\item \label{Tiziano}
Scattering amplitudes over finite fields and multivariate functional reconstruction\\
(Tiziano Peraro)\\
\url{https://arxiv.org/pdf/1608.01902.pdf}

\item Haskell Language \\
\url{www.haskell.org}

%\item \url{http://qiita.com/bra_cat_ket/items/205c19611e21f3d422b7}\\
% (Japanese tech support sns)

\item \label{Haskellroad}
The Haskell Road to Logic, Maths and Programming\\ 
(Kees Doets, Jan van Eijck)\\
\url{http://homepages.cwi.nl/~jve/HR/}

\item \label{Numerical}
Introduction to numerical analysis\\ 
(Stoer Josef, Bulirsch Roland)

\end{enumerate}

\section{Set theoretical gadgets}
\subsection{Numbers}
Here is a list of what we assumed that the readers are familiar with:
\begin{enumerate}
\item $\mathbb{N}$ (Peano axiom: $\emptyset, \text{suc}$)
\item $\mathbb{Z}$
\item $\mathbb{Q}$
\item $\mathbb{R}$ (Dedekind cut)
\item $\mathbb{C}$ 
\end{enumerate}

\subsection{Algebraic structures}
\begin{enumerate}
\item Monoid: $(\mathbb{N},+), (\mathbb{N},\times)$
\item Group: $(\mathbb{Z},+), (\mathbb{Z},\times)$
\item Ring: $\mathbb{Z}$
\item Field: $\mathbb{Q}$, $\mathbb{R}$ (continuous), $\mathbb{C}$ (algebraic closed)
\end{enumerate}

\section{Haskell language}
From "A Brief, Incomplete and Mostly Wrong History of Programming Languages":\footnote{
\url{http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html}
}
\begin{quotation}
1990 - A committee formed by Simon Peyton-Jones, Paul Hudak, Philip Wadler, Ashton Kutcher, and People for the Ethical Treatment of Animals creates Haskell, a pure, non-strict, functional language. Haskell gets some resistance due to the complexity of using monads to control side effects. Wadler tries to appease critics by explaining that "a monad is a monoid in the category of endofunctors, what's the problem?" 
\end{quotation}

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=3cm, bb= 0 0 1280 904]{Haskell-Logo.png}
\caption{Haskell's logo, the combinations of $\lambda$ and monad's bind \texttt{>>=}.}
\label{Haskell-Logo}
\end{center}
\end{figure}

Haskell language is a standardized purely functional declarative statically typed programming language.

In declarative languages, we describe "what" or "definition" in its codes, however imperative languages, like C/C++, "how" or "procedure".
\begin{quotation}
Functional languages can be seen as 'executable mathematics'; the notation was designed to be as close as possible to the mathematical way of writing.\footnote{
Algorithms: A Functional Programming Approach (Fethi A. Rabhi, Guy Lapalme)
}
\end{quotation}
Instead of loops, we use (implicit) recursions in functional language.\footnote{Of course, as a best practice, we should use higher order function (in this case \texttt{foldr} or \texttt{foldl}) rather than explicit recursions.
}
\begin{verbatim}
> sum :: [Int] -> Int
> sum []     = 0
> sum (i:is) = i + sum is
\end{verbatim}



%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Basics}
We have assumed living knowledge on (axiomatic, i.e., ZFC) set theory and basic algebraic structures.

\section{Finite fields}

\subsection{Rings}
A ring $(R,+,*)$ is a structured set $R$ with two binary operations
\begin{eqnarray}
\verb|(+) :: R -> R -> R|\\
\verb|(*) :: R -> R -> R|
\end{eqnarray}
satisfying the following 3 (ring) axioms:
\begin{enumerate}
\item $(R,+)$ is an abelian, i.e., commutative group,
i.e.,
\begin{eqnarray}
\forall a,b,c \in R, (a+b) + c = a + (b + c) & \text{ (associativity for $+$)} \\
\forall a, b, \in R, a+b = b+a & \text{ (commutativity)} \\
\exists 0 \in R, \text{ s.t. } \forall a \in R, a + 0 = a & \text{ (additive identity) } \\
\forall a \in R, \exists (-a) \in R \text{ s.t. } a + (-a) = 0 & \text{ (additive inverse)}
\end{eqnarray}

\item $(R,*)$ is a monoid, i.e.,
\begin{eqnarray}
\forall a,b,c \in R, (a*b) * c = a * (b * c) & \text{ (associativity for $*$)} \\
\exists 1 \in R, \text{ s.t. } \forall a \in R, a * 1 = a = 1*a & \text{ (multiplicative identity) } 
\end{eqnarray}

\item Multiplication is distributive w.r.t addition, i.e., $\forall a,b,c \in R$, 
\begin{eqnarray}
a*(b+c) = (a*b) + (a*c) & \text{ (left distributivity)} \\
(a+b)*c = (a*c) + (b*c) & \text{ (right distributivity)} 
\end{eqnarray}

\end{enumerate}

\subsection{Fields}
A field is a ring $(\mathbb{K},+,*)$ whose non-zero elements form an abelian group under multiplication, i.e., $\forall r \in \mathbb{K}$,
\begin{eqnarray}
r \neq 0 \Rightarrow \exists r^{-1} \in \mathbb{K} \text{ s.t. } r*r^{-1} = 1 = r^{-1}*r.
\end{eqnarray}
A field $\mathbb{K}$ is a finite field iff the underlying set $\mathbb{K}$ is finite.
A field $\mathbb{K}$ is called infinite field iff the underlying set is infinite.

\subsection{An example of finite rings $\mathbb{Z}_n$}
Let $n (>0) \in \mathbb{N}$ be a non-zero natural number.
Then the quotient set
\begin{eqnarray}
\mathbb{Z}_n &:=& \mathbb{Z} / n\mathbb{Z} \\
&\cong& \{0, \cdots, (n-1)\}
\end{eqnarray}
with addition, subtraction and multiplication under modulo $n$ is a ring.\footnote{
Here we have taken an equivalence class, 
\begin{eqnarray}
0 \leq \forall k \leq (n-1), [k] := \{k + n*z | z \in \mathbb{Z} \}
\end{eqnarray}
with the following operations:
\begin{eqnarray}
\left[k \right] + \left[l \right] &:=& \left[k+l\right] \\
\left[k \right] * \left[l \right] &:=& \left[k * l\right]
\end{eqnarray}
This is equivalent to take modular $n$:
\begin{eqnarray}
(k \mod n) + (l \mod n) &:=& (k+l \mod n) \\
(k \mod n) * (l \mod n) &:=& (k*l \mod n).
\end{eqnarray}

}

\subsection{B\'ezout's lemma}
Consider $a,b \in \mathbb{Z}$ be nonzero integers.
Then there exist $x,y \in \mathbb{Z}$ s.t.
\begin{eqnarray}
a*x + b*y = \gcd(a,b),
\end{eqnarray}
where $\gcd$ is the greatest common divisor (function), see \S\ref{gcdDefinition}.
We will prove this statement in \S\ref{exGCD}.

\subsection{Greatest common divisor}
\label{gcdDefinition}
Before the proof, here is an implementation of $\gcd$ using Euclidean algorithm with Haskell language:

\begin{verbatim}
> -- Eucledian algorithm.
> myGCD :: Integral a => a -> a -> a
> myGCD a b
>   | b < 0 = myGCD a (-b)
> myGCD a b
>   | a == b = a
>   | b >  a = myGCD b a
>   | b <  a = myGCD (a-b) b
\end{verbatim}

\subsubsection{Example, by hands}
Let us consider the gcd of 7 and 13.
Since they are primes, the gcd should be 1.
First it binds \texttt{a} with 7 and \texttt{b} with 13, and hit \texttt{b > a}.
\begin{eqnarray}
\texttt{myGCD 7 13 == myGCD 13 7}
\end{eqnarray}
Then it hits main line:
\begin{eqnarray}
\texttt{myGCD 13 7 == myGCD (13-7) 7}
\end{eqnarray}
In order to go to next step, Haskell evaluate $(13-7)$,\footnote{
Since Haskell language adopts lazy evaluation, i.e., call by need, not call by name.
}
and
\begin{eqnarray}
\texttt{myGCD (13-7) 7} &\texttt{==}& \texttt{myGCD 6 7} \\
&\texttt{==}& \texttt{myGCD 7 6} \\
&\texttt{==}& \texttt{myGCD (7-6) 6} \\
&\texttt{==}& \texttt{myGCD 1 6} \\
&\texttt{==}& \texttt{myGCD 6 1}
\end{eqnarray}
Finally it ends with 1:
\begin{eqnarray}
\texttt{myGCD 1 1 == 1} 
\end{eqnarray}

As another example, consider $15$ and $25$:
\begin{eqnarray}
\texttt{myGCD 15 25} &\texttt{==}& \texttt{myGCD 25 15}\\
&\texttt{==}& \texttt{myGCD (25-15) 15}\\
&\texttt{==}& \texttt{myGCD 10 15}\\
&\texttt{==}& \texttt{myGCD 15 10}\\
&\texttt{==}& \texttt{myGCD (15-10) 10}\\
&\texttt{==}& \texttt{myGCD 5 10}\\
&\texttt{==}& \texttt{myGCD 10 5}\\
&\texttt{==}& \texttt{myGCD (10-5) 5}\\
&\texttt{==}& \texttt{myGCD 5 5}\\
&\texttt{==}& \texttt{5}
\end{eqnarray}

\subsubsection{Example, with Haskell}
Let us check simple example using Haskell:
\begin{verbatim}
  *Ffield> myGCD 7 13
  1
  *Ffield> myGCD 7 14
  7
  *Ffield> myGCD (-15) (20)
  5
  *Ffield> myGCD (-299) (-13)
  13
\end{verbatim}
The final result is from
\begin{verbatim}
  *Ffield> 13*23
  299
\end{verbatim}

\subsection{Extended Euclidean algorithm}
\label{exGCD}
Here we treat the extended Euclidean algorithm, this is a constructive solution for B\'ezout's lemma.

As intermediate steps, this algorithm makes sequences of integers $\{r_i\}_i$, $\{s_i\}_i$, $\{t_i\}_i$ and quotients $\{q_i\}_i$ as follows.
The base cases are
\begin{eqnarray}
\left(r_0, s_0, t_0 \right) &:=& (a,1,0) \\
\left(r_1, s_1, t_1 \right) &:=& (b,0,1) 
\end{eqnarray}
and inductively, for $i \geq 2$,
\begin{eqnarray}
q_i &:=& \text{quot}(r_{i-2}, r_{i-1}) \\
r_i &:=& r_{i-2} - q_i * r_{i-1} \\
s_i &:=& s_{i-2} - q_i * s_{i-1} \\
t_i &:=& t_{i-2} - q_i * t_{i-1}.
\end{eqnarray}
The termination condition\footnote{
This algorithm will terminate eventually, since the sequence $\{r_i\}_i$ is non-negative by definition of $q_i$, but strictly decreasing, i.e., decreasing natural numbers.
Therefore, $\{r_i\}_i$ will meet $0$ in finite step $k$.
} is
\begin{eqnarray}
r_k = 0
\end{eqnarray}
for some $k \in \mathbb{N}$ and
\begin{eqnarray}
\gcd(a,b) &=& r_{k-1} \\
x &=& s_{k-1} \\
y &=& t_{k-1}.
\end{eqnarray}

\subsubsection{Proof}
By definition,
\begin{eqnarray}
\gcd(r_{i-1}, r_i) &=& \gcd(r_{i-1}, r_{i-2} - q_i * r_{i-1}) \\
&=& \gcd(r_{i-1}, r_{i-2})
\end{eqnarray}
and this implies 
\begin{eqnarray}
\gcd(a,b) =: \gcd(r_0, r_1) = \cdots = \gcd(r_{k-1}, 0),
\end{eqnarray}
i.e., 
\begin{eqnarray}
r_{k-1} = \gcd(a,b).
\end{eqnarray}

Next, for $i=0,1$ observe
\begin{eqnarray}
\label{guessOfRational}
a*s_i + b*t_i = r_i.
\end{eqnarray}
Let $i\geq 2$, then
\begin{eqnarray}
r_i &=& r_{i-2}  - q_i * r_{i-1} \\
&=& a*s_{i-2} + b*t_{i-2} - q_i *(a*s_{i-1} + b*t_{i-1} ) \\
&=& a*(s_{i-2} - q_i *s_{i-1}) + b* (t_{i-2} - q_i *t_{i-1} ) \\
&=:& a*s_i + b*t_i.
\end{eqnarray}
Therefore, inductively we get
\begin{eqnarray}
\gcd(a,b) = r_{k-1} = a*s_{k-1} + b*t_{k-1}. =: a*x + b*y.
\end{eqnarray}
This prove B\'ezout's lemma. \\
$\blacksquare$

\subsubsection{Haskell implementation}
\label{exGCDHaskell}
Here I use lazy lists for intermediate lists of $qs,rs,ss,ts$, and pick up (second) last elements for the results.

\label{extendedEuclideanAlgorithm}
\begin{verbatim}
Here we would like to implement the extended Euclidean algorithm.
See the algorithm, examples, and pseudo code at:

  https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm
  http://qiita.com/bra_cat_ket/items/205c19611e21f3d422b7

> exGCD' 
>   :: (Integral n) => 
>      n -> n -> ([n], [n], [n], [n])
> exGCD' a b = (qs, rs, ss, ts)
>   where
>     qs = zipWith quot rs (tail rs)
>     rs = takeBefore (==0) r'
>     r' = steps a b
>     ss = steps 1 0
>     ts = steps 0 1
>
>     steps a b = rr
>       where 
>         rr@(_:rs) = a:b: zipWith (-) rr (zipWith (*) qs rs)
>
> takeBefore 
>   :: (a -> Bool) -> [a] -> [a]
> takeBefore p = foldr func []
>   where
>     func x xs 
>       | p x       = []
>       | otherwise = x : xs
\end{verbatim}
Here we have used so called lazy lists, and higher order function\footnote{
Naively speaking, the function whose inputs and/or outputs are functions is called a higher order function.
}.
The gcd of $a$ and $b$ should be the last element of second list \verb+rs+, and our targets $(s,t)$ are second last elements of last two lists \verb+ss+ and \verb+ts+.
The following example is from wikipedia:
\begin{verbatim}
  *Ffield> exGCD' 240 46
  ([5,4,1,1,2],[240,46,10,6,4,2],[1,0,1,-4,5,-9,23],[0,1,-5,21,-26,47,-120])
\end{verbatim}  
Look at the second lasts of \verb+[1,0,1,-4,5,-9,23],[0,1,-5,21,-26,47,-120]+, i.e., -9 and 47:
\begin{verbatim}  
  *Ffield> gcd 240 46
  2
  *Ffield> 240*(-9) + 46*(47)
  2
\end{verbatim}
It works, and we have other simpler examples:
\begin{verbatim}
  *Ffield> exGCD' 15 25
  ([0,1,1,2],[15,25,15,10,5],[1,0,1,-1,2,-5],[0,1,0,1,-1,3])
  *Ffield> 15 * 2 + 25*(-1)
  5
  *Ffield> exGCD' 15 26
  ([0,1,1,2,1,3],[15,26,15,11,4,3,1],[1,0,1,-1,2,-5,7,-26],[0,1,0,1,-1,3,-4,15])
  *Ffield> 15*7 + (-4)*26
  1
\end{verbatim}
Now what we should do is extract gcd of $a$ and $b$, and $(x, y)$ from the tuple of lists:
\begin{verbatim}
> -- a*x + b*y = gcd a b
> exGCD :: Integral t => t -> t -> (t, t, t)
> exGCD a b = (g, x, y)
>   where
>     (_,r,s,t) = exGCD' a b
>     g = last r
>     x = last . init $ s
>     y = last . init $ t
\end{verbatim}
where the underscore \verb+_+ is a special symbol in Haskell that hits every pattern, since we do not need to evaluate the quotient list \verb+qs+.
So, in order to get gcd and $(x, y)$ we don't need quotients list.
\begin{verbatim}
  *Ffield> exGCD 46 240
  (2,47,-9)
  *Ffield> 46*47 + 240*(-9)
  2
  *Ffield> gcd 46 240
  2
\end{verbatim}

\subsection{Coprime as a binary relation}
Let us define a binary relation as follows:
\begin{verbatim}
  coprime :: Integral a => a -> a -> Bool
  coprime a b = (gcd a b) == 1
\end{verbatim}

\subsection{Corollary (Inverses in $\mathbb{Z}_n$)}
For a non-zero element
\begin{eqnarray}
a \in \mathbb{Z}_n,
\end{eqnarray}
there is a unique number 
\begin{eqnarray}
b \in \mathbb{Z}_n \text{ s.t. } ((a*b) \mod n) = 1
\end{eqnarray}
iff $a$ and $n$ are coprime.

\subsubsection{Proof}
From B\'ezout's lemma, $a$ and $n$ are coprime iff
\begin{eqnarray}
\exists s,t \in \mathbb{Z}, a*s + n*t = 1.
\end{eqnarray}
Therefore
\begin{eqnarray}
\text{$a$ and $n$ are coprime} &\Leftrightarrow& \exists s,t \in \mathbb{Z}, a*s + n*t = 1 \\
&\Leftrightarrow &\exists s,t' \in \mathbb{Z}, a*s = 1 + n*t'.
\end{eqnarray}
This $s$, by taking its modulo $n$ is our $b = a^{-1}$:
\begin{eqnarray}
a*s = 1 \mod n.
\end{eqnarray}
We will make a Haskell implementation in \S\ref{inverses}.\\
$\blacksquare$

\subsection{Corollary (Finite field $\mathbb{Z}_p$)}
If $p$ is prime, then 
\begin{eqnarray}
\mathbb{Z}_p := \{0, \cdots, (p-1)\}
\end{eqnarray}
with addition, subtraction and multiplication under modulo $n$ is a field.

\subsubsection{Proof}
It suffices to show that 
\begin{eqnarray}
\forall a \in \mathbb{Z}_p, a \neq 0 \Rightarrow \exists a^{-1} \in \mathbb{K} \text{ s.t. } a*a^{-1} = 1 = a^{-1}*a,
\end{eqnarray}
but since $p$ is prime, and
\begin{eqnarray}
\forall a \in \mathbb{Z}_p, a \neq 0 \Rightarrow \texttt{gcd a p == 1}
\end{eqnarray}
so all non-zero element has its inverse in $ \mathbb{Z}_p$.\\
$\blacksquare$

\subsubsection{Example and implementation}
\label{inverses}
Let us pick 11 as a prime and consider $\mathbb{Z}_{11}$:
\begin{verbatim}
  Example Z_{11}

  *Ffield> isField 11
  True
  *Ffield> map (exGCD 11) [0..10]
  [(11,1,0),(1,0,1),(1,1,-5),(1,-1,4),(1,-1,3)
  ,(1,1,-2),(1,-1,2),(1,2,-3),(1,3,-4),(1,-4,5),(1,1,-1)
  ]
\end{verbatim}
This list of three-tuple let us know the candidates of inverses.
Take the last one, \verb+(1,1,-1)+.
This is the image of \verb+exGcd 11 10+, and 
\begin{eqnarray}
1 = 10*1 + 11*(-1)
\end{eqnarray}
holds.
This suggests -1 is a candidate of the inverse of 10 in $\mathbb{Z}_{11}$:
\begin{eqnarray}
10^{-1} &=& -1 \mod 11 \\
&=& 10 \mod 11
\end{eqnarray}
In fact,
\begin{eqnarray}
10*10 = 11*9+1.
\end{eqnarray}
So, picking up the third elements in tuple and zipping with nonzero elements, we have a list of inverses:
\begin{verbatim}
  *Ffield> map ((`mod` 11) . (\(_,_,x)->x) . exGCD 11) [1..10] 
  [1,6,4,3,9,2,8,7,5,10]

We get non-zero elements with its inverse:

  *Ffield> zip [1..10] it
  [(1,1),(2,6),(3,4),(4,3),(5,9),(6,2),(7,8),(8,7),(9,5),(10,10)]
\end{verbatim}
Let us generalize these flow into a function\footnote{
From \url{https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Maybe.html}:
\begin{quotation}
The Maybe type encapsulates an optional value. 
A value of type Maybe a either contains a value of type a (represented as Just a), or it is empty (represented as Nothing). 
Using Maybe is a good way to deal with errors or exceptional cases without resorting to drastic measures such as error.
\end{quotation}
}:
\begin{verbatim}  
> -- a^{-1} (in Z_p) == a `inversep` p
> inversep :: Integral a => a -> a -> Maybe a
> a `inversep` p = let (g,x,_) = exGCD a p in
>   if (g == 1) then Just (x `mod` p)
>               else Nothing
\end{verbatim}
This \texttt{inversep} function returns the inverse with respect to second argument, if they are coprime, i.e. $\gcd$ is 1.
So the second argument should not be prime.
\begin{verbatim}
> inversesp :: Integral a => a -> [Maybe a]
> inversesp p = map (`inversep` p) [1..(p-1)]

  *Ffield> inversesp 11
  [Just 1,Just 6,Just 4,Just 3,Just 9,Just 2,Just 8,Just 7,Just 5,Just 10]
  *Ffield> inversesp 9
  [Just 1,Just 5,Nothing,Just 7,Just 2,Nothing,Just 4,Just 8]
\end{verbatim}

\section{Rational number reconstruction}
\subsection{A map from $\mathbb{Q}$ to $\mathbb{Z}_p$}
Let $p$ be a prime.
Now we have a map
\begin{eqnarray}
- \mod p : \mathbb{Z} \to \mathbb{Z}_p; a \mapsto (a \mod p),
\end{eqnarray}
and a natural inclusion (or a forgetful map)\footnote{
By introducing this forgetful map, we can use 
\begin{eqnarray}
\times : (\mathbb{Z}, \mathbb{Z}) \to \mathbb{Z} 
\end{eqnarray}
of normal product on $\mathbb{Z}$ in eq.(\ref{modpForRational}).
}
\begin{eqnarray}
\text{\textquestiondown} : \mathbb{Z}_p \hookrightarrow \mathbb{Z}.
\end{eqnarray}
Then we can define a map
\begin{eqnarray}
- \mod p : \mathbb{Q} \to \mathbb{Z}_p
\end{eqnarray}
by\footnote{
This is an example of operator overloadings.
}
\begin{eqnarray}
\label{modpForRational}
q = \frac{a}{b} \mapsto (q \mod p) := \left( \left( a \times \text{\textquestiondown} \left( b^{-1} \mod p\right) \right) \mod p \right).
\end{eqnarray}

\subsubsection{Example and implementation}
An easy implementation is the followings:\footnote{
The backquotes makes any binary function infix operator.
For example,
\begin{eqnarray}
\texttt{add 1 2 == 1 `add` 2}
\end{eqnarray}
Similarly, use parenthesis we can use an infix binary operator to a function:
\begin{eqnarray}
\texttt{(+) 1 2 == 1 + 2}
\end{eqnarray}
}
\begin{verbatim}
> -- A map from Q to Z_p, where p is a prime.
> modp 
>   :: Ratio Int -> Int -> Maybe Int
> q `modp` p 
>   | coprime b p = Just $ (a * (bi `mod` p)) `mod` p
>   | otherwise   = Nothing
>   where
>     (a,b)   = (numerator q, denominator q)
>     Just bi = b `inversep` p
>
> -- When the denominator of q is not proprtional to p, use this.
> modp' 
>   :: Ratio Int -> Int -> Int
> q `modp'` p = (a * (bi `mod` p)) `mod` p
>   where
>     (a,b)   = (numerator q, denominator q)
>     bi = b `inversep'` p
\end{verbatim}
Let us consider a rational number $\frac{3}{7}$ on a finite field $\mathbb{Z}_{11}$:
\begin{verbatim}
Example: on Z_{11}
Consider (3 % 7).

  *Ffield> let q = (3%7)
  *Ffield> 3 `mod` 11
  3
  *Ffield> 7 `inversep` 11
  Just 8
  *Ffield> (3*8) `mod` 11
  2
\end{verbatim}
% For example, pick 7:
% \begin{verbatim}  
%  *Ffield> 7*8 == 11*5+1
%   True
% \end{verbatim}
Therefore, on $\mathbb{Z}_{11}$, $(7^{-1} \mod 11)$ is equal to $(8 \mod 11)$ and
\begin{eqnarray}
\frac{3}{7} \in \mathbb{Q} &\mapsto& (3 \times \text{\textquestiondown}(7^{-1} \mod 11) \mod 11) \\
&&= (3 \times 8) \mod 11 \\
&&= 24 \mod 11 \\
&&= 2 \mod 11.
\end{eqnarray}
Haskell returns the same result
\begin{verbatim}  
  *Ffield> q `modp` 11
  Just 2
\end{verbatim}

\subsection{Reconstruction from $\mathbb{Z}_p$ to $\mathbb{Q}$}
Consider a rational number $q$ and its image $a \in \mathbb{Z}_p$.
\begin{eqnarray}
a := q \mod p
\end{eqnarray}
The extended Euclidean algorithm can be used for guessing a rational number $q$ from the images $a := q \mod p$ of several primes $p$'s.

At each step, the extended Euclidean algorithm satisfies eq.(\ref{guessOfRational}).
\begin{eqnarray}
a*s_i + p*t_i = r_i
\end{eqnarray}
Therefore
\begin{eqnarray}
r_i = a*s_i \mod p. %\Leftrightarrow \frac{r_i}{s_i} \mod p = a.
\end{eqnarray}
Hence $\frac{r_i}{s_i}$ is a possible guess for $q$.
We take
\begin{eqnarray}
\label{terminationOfRec}
r_i^2 , s_i^2 < p
\end{eqnarray}
as the termination condition for this reconstruction.

\subsubsection{Haskell implementation}
Let us first try to reconstruct from the image $(\frac{1}{3} \mod p)$ of some prime $p$.
Here we choose three primes
\begin{verbatim}
Reconstruction Z_p -> Q
  *Ffield> let q = (1%3)
  *Ffield> take 3 $ dropWhile (<100) primes
  [101,103,107]
\end{verbatim}
The following images are basically given by the first elements of second lists ($s_0$'s):
\begin{verbatim}  
  *Ffield> q `modp` 101
  34
  *Ffield> let try x = exGCD' (q `modp` x) x
  *Ffield> try 101
  ([0,2,1,33],[34,101,34,33,1],[1,0,1,-2,3,-101],[0,1,0,1,-1,34])
  *Ffield> try 103
  ([0,1,2,34],[69,103,69,34,1],[1,0,1,-1,3,-103],[0,1,0,1,-2,69])
  *Ffield> try 107
  ([0,2,1,35],[36,107,36,35,1],[1,0,1,-2,3,-107],[0,1,0,1,-1,36])  
\end{verbatim}
Look at the first hit of termination condition eq.(\ref{terminationOfRec}), $r_4=1$ and $s_4=3$ of $\mathbb{Z}_{101}$.
The same facts on $\mathbb{Z}_{103}$ and $\mathbb{Z}_{107}$ give us the same guess $\frac{1}{3}$, and that the reconstructed number.

From the above observations we can make a simple \verb+guess+ function:
\begin{verbatim}
> -- This is guess function without Chinese Reminder Theorem.
> guess 
>   :: Integral t => 
>      (Maybe t, t)       -- (q `modp` p, p)
>   -> Maybe (Ratio t, t)
> guess (Nothing, _) = Nothing
> guess (Just a, p) = let (_,rs,ss,_) = exGCD' a p in
>   Just (select rs ss p, p)
>     where
>       select 
>         :: Integral t => 
>            [t] -> [t] -> t -> Ratio t
>       select [] _ _ = 0%1
>       select (r:rs) (s:ss) p
>         | s /= 0 && r*r <= p && s*s <= p = r%s
>         | otherwise                      = select rs ss p
\end{verbatim}

We put a list of big primes as follows.
\begin{verbatim}
> -- Hard code of big primes
> -- We have chosen a finite number (100) version.
> bigPrimes :: [Int]
> bigPrimes = take 100 $ dropWhile (<10^4) primes

  *Ffield> bigPrimes 
  [10007,10009,10037,10039,10061,10067,10069,10079,10091,10093,10099,10103
  ,10111,10133,10139,10141,10151,10159,10163,10169,10177,10181,10193,10211
  ,10223,10243,10247,10253,10259,10267,10271,10273,10289,10301,10303,10313
  ,10321,10331,10333,10337,10343,10357,10369,10391,10399,10427,10429,10433
  ,10453,10457,10459,10463,10477,10487,10499,10501,10513,10529,10531,10559
  ,10567,10589,10597,10601,10607,10613,10627,10631,10639,10651,10657,10663
  ,10667,10687,10691,10709,10711,10723,10729,10733,10739,10753,10771,10781
  ,10789,10799,10831,10837,10847,10853,10859,10861,10867,10883,10889,10891
  ,10903,10909,10937,10939
  ]
\end{verbatim}
This choice of primes of order $O(10^4)$ let our \verb+guess+ function reconstruct rational numbers up to
\begin{eqnarray}
\frac{O(10^2)}{O(10^2)}.
\end{eqnarray}

\subsubsection{Good and bad examples}
Our \verb+guess+ function can find correct answer from the images of $\frac{12}{13}$.
\begin{verbatim}
  *Ffield> let knownData q = zip (map (modp q) bigPrimes) bigPrimes
  *Ffield> let ds = knownData (12%13)
  *Ffield> map guess ds
  [Just (12 % 13,10007)
  ,Just (12 % 13,10009)
  ,Just (12 % 13,10037)
  ,Just (12 % 13,10039) ..
\end{verbatim}
However, for $\frac{112}{113}$, it gets wrong answer.
\begin{verbatim}
  *Ffield> let ds' = knownData (112%113)
  *Ffield> map guess ds'
  [Just ((-39) % 50,10007)
  ,Just ((-41) % 48,10009)
  ,Just ((-69) % 20,10037)
  ,Just ((-71) % 18,10039) ..
\end{verbatim}

A solution of this problem is next subsection.

%
%We choose 3 times match as the termination condition.
%\begin{verbatim}
%> matches3 :: Eq a => [a] -> a
%> matches3 (a:bb@(b:c:cs))
%>   | a == b && b == c = a
%>   | otherwise        = matches3 bb
%\end{verbatim}
%Finally, we can check our gadgets.
%
%What we know is a list of (q `modp` p) and prime p for several (big) primes.
%\begin{verbatim}
%  *Ffield> let q = 10%19
%  *Ffield> let knownData = zip (map (modp q) bigPrimes) bigPrimes 
%  *Ffield> take 3 knownData 
%  [(614061,897473),(377894,897497),(566842,897499)]
%  *Ffield> matches3 $  map (fst . guess) knownData
%  10 % 19
%\end{verbatim}
%The following is the function we need, its input is the list of tuple which first element is the image in $\mathbb{Z}_p$ and second element is that prime $p$.
%\begin{verbatim}
%> reconstruct :: Integral a =>
%>                [(a, a)]  -- :: [(Z_p, primes)]
%>             -> Ratio a
%> reconstruct aps = matches3 $ map (fst . guess) aps
%
%Here is a naive test:
%  > let qs = [1 % 3,10 % 19,41 % 17,30 % 311,311 % 32
%             ,869 % 232,778 % 123,331 % 739]
%  > let modmap q = zip (map (modp q) bigPrimes) bigPrimes 
%  > let longList = map modmap qs
%  > map reconstruct longList 
%  [1 % 3,10 % 19,41 % 17,30 % 311,311 % 32
%  ,869 % 232,778 % 123,331 % 739]
%  > it == qs
%  True
%\end{verbatim}
%
%For later use, let us define
%\begin{verbatim}
%> imagesAndPrimes ::  Rational-> [(Integer, Integer)]
%> imagesAndPrimes q = zip (map (modp q) bigPrimes) bigPrimes
%\end{verbatim}
%to generate a list of images (of our target rational number) in $Z_p$ and the base primes.
%
%As another example, we have slightly involved function:
%\begin{verbatim}
%> matches3' :: Eq a => [(a, t)] -> (a, t)
%> matches3' (a0@(a,_):bb@((b,_):(c,_):cs))
%>   | a == b && b == c = a0
%>   | otherwise        = matches3' bb
%\end{verbatim}
%Let us see the first good guess, Haskell tells us that in order to reconstruct, say $\frac{331}{739}$, we should take three primes start from 614693:
%\begin{verbatim}
%  *Ffield> let knowData q = zip (map (modp q) primes) primes
%  *Ffield> matches3' $ map guess $ knowData (331%739)
%  (331 % 739,614693)
%  (18.31 secs, 12,393,394,032 bytes)
%  
%  *Ffield> matches3' $ map guess $ knowData (11%13)
%  (11 % 13,311)
%  (0.02 secs, 2,319,136 bytes)
%  *Ffield> matches3' $ map guess $ knowData (1%13)
%  (1 % 13,191)
%  (0.01 secs, 1,443,704 bytes)
%  *Ffield> matches3' $ map guess $ knowData (1%3)
%  (1 % 3,13)
%  (0.01 secs, 268,592 bytes)
%  *Ffield> matches3' $ map guess $ knowData (11%31)
%  (11 % 31,1129)
%  (0.03 secs, 8,516,568 bytes)
%  *Ffield> matches3' $ map guess $ knowData (12%312)
%  (1 % 26,709)
%\end{verbatim}
%
%\subsubsection{A problem}
%Since our choice of \texttt{bigPrimes} are order $10^6$, our reconstruction can fail for rational numbers of
%\begin{eqnarray}
%\frac{O(10^3)}{O(10^3)},
%\end{eqnarray}
%say
%\begin{verbatim}
%  *Ffield> let q = 895%922
%  *Ffield> let knownData = imagesAndPrimes q
%  *Ffield> take 4 knownData 
%  [(882873,897473)
%  ,(365035,897497)
%  ,(705735,897499)
%  ,(511060,897517)
%  ]
%  *Ffield> map guess it
%  [((-854) % 123,897473)
%  ,((-656) % 327,897497)
%  ,((-192) % 805,897499)
%  ,((-491) % 497,897517)
%  ]
%\end{verbatim}
%We can solve this by introducing the following theorem.

\subsection{Chinese remainder theorem}
From wikipedia\footnote{
\url{https://en.wikipedia.org/wiki/Chinese_remainder_theorem}
}
\begin{quotation}
There are certain things whose number is unknown. If we count them by threes, we have two left over; by fives, we have three left over; and by sevens, two are left over. How many things are there? 
\end{quotation}
Here is a solution with Haskell, using list comprehension.
\begin{verbatim}
*Ffield> let lst = [n|n<-[0..], mod n 3==2, mod n 5==3, mod n 7==2]
*Ffield> head lst
23
\end{verbatim}
We define an infinite list of natural numbers that satisfy
\begin{eqnarray}
n \mod 3 = 2, n \mod 5 = 3, n \mod 7 = 2.
\end{eqnarray}
Then take the first element, and this is the answer.

\subsubsection{Claim}
The statement for binary case is the following.
Let $n_1, n_2 \in \mathbb{Z}$ be coprime, then for arbitrary $a_1,a_2 \in \mathbb{Z}$, the following a system of equations
\begin{eqnarray}
x &=& a_1 \mod n_1\\
x &=& a_2 \mod n_2
\end{eqnarray}
have a unique solution modular $n_1*n_2$\footnote{
Note that, this is equivalent that there is a unique solution $a$ in
\begin{eqnarray}
0 \leq a < n_1\times n_2.
\end{eqnarray}
}.

\subsubsection{Proof}
(existence) With \S\ref{exGCD}, there are $m_1,m_2 \in \mathbb{Z}$ s.t.
\begin{eqnarray}
n_1 * m_1 + n_2 * m_2 = 1.
\end{eqnarray}
Now we have
\begin{eqnarray}
n_1 * m_1 &=& 1 \mod n_2 \\
n_2 * m_2 &=& 1 \mod n_1
\end{eqnarray}
that is\footnote{
Here we have used slightly different notions from \ref{Tiziano}.
$m_1$ in \ref{Tiziano} is our $m_2$ times our $n_2$.
}
\begin{eqnarray}
m_1 &=& n_1^{-1} \mod n_2 \\
m_2 &=& n_2^{-1} \mod n_1.
\end{eqnarray}
Then
\begin{eqnarray}
a := a_1 * n_2 * m_2 + a_2 * n_1 * m_1 \mod (n_1*n_2)
\end{eqnarray}
is a solution.

(uniqueness)
If $a'$ is also a solution, then
\begin{eqnarray}
a - a' &=& 0 \mod n_1 \\
a - a' &=& 0 \mod n_2.
\end{eqnarray}
Since $n_1$ and $n_2$ are coprime, i.e., no common divisors, this difference is divisible by $n_1*n_2$, and
\begin{eqnarray}
a - a' = 0 \mod (n_1 * n_2).
\end{eqnarray}
Therefore, the solution is unique modular $n_1*n_2$. \\
$\blacksquare$

%\subsubsection{Generalization}
%Given $a \in Z_n$ of pairwise coprime numbers
%\begin{eqnarray}
%n := n_1 * \cdots * n_k,
%\end{eqnarray}
%a system of equations
%\begin{eqnarray}
%\left. a_i = a \mod n_i \right|_{i=1}^k
%\end{eqnarray}
%have a unique solution
%\begin{eqnarray}
%a = \sum_i m_i a_i \mod n,
%\end{eqnarray}
%where
%\begin{eqnarray}
%\left. m_i = \left( \frac{n_i}{n} \mod n_i \right) \frac{n}{n_i} \right|_{i=1}^k.
%\end{eqnarray}

\subsubsection{Haskell implementation}
Let us see how our naive \texttt{guess} function fail one more time.
We make a helper function for tests.
\begin{verbatim}
> imagesAndPrimes :: Ratio Int -> [(Maybe Int, Int)]
> imagesAndPrimes q = zip (map (modp q) bigPrimes) bigPrimes
\end{verbatim}

\begin{verbatim}
*Ffield> let q = 895%922
*Ffield> let knownData = imagesAndPrimes q
*Ffield> let [(a1,p1),(a2,p2)] = take 2 knownData
*Ffield> take 2 knownData
[(Just 6003,10007),(Just 9782,10009)]
*Ffield> map guess it
[Just ((-6) % 5,10007),Just (21 % 44,10009)]
\end{verbatim}

It suffices to make a binary version of Chinese Remainder theorem in Haskell:
\begin{verbatim}
Our data is a list of the type
  [(Maybe Int, Int)]
In order to use CRT, we should cast its type.

> toInteger2 :: [(Maybe Int, Int)] -> [(Maybe Integer, Integer)]
> toInteger2 = map helper
>   where 
>     helper (x,y) = (fmap toInteger x, toInteger y)
>
> crtRec':: Integral a => (Maybe a, a) -> (Maybe a, a) -> (Maybe a, a)
> crtRec' (Nothing,p) (_,q)       = (Nothing, p*q)
> crtRec' (_,p)       (Nothing,q) = (Nothing, p*q)
> crtRec' (Just a1,p1) (Just a2,p2) = (Just a,p)
>   where
>     a = (a1*p2*m2 + a2*p1*m1) `mod` p
>     Just m1 = p1 `inversep` p2 
>     Just m2 = p2 `inversep` p1
>     p = p1*p2

\end{verbatim}
\texttt{crtRec'} function takes two tuples of image in $\mathbb{Z}_p$ and primes, and returns these combination.

Now let us fold.
\begin{verbatim}

  *Ffield> let ds = imagesAndPrimes (1123%1135)
  *Ffield> map guess ds
  [Just (25 % 52,10007)
  ,Just ((-81) % 34,10009)
  ,Just ((-88) % 63,10037) ..

  *Ffield> matches3 it
  Nothing

  *Ffield> scanl1 crtRec' ds

  *Ffield> scanl1 crtRec' . toInteger2 $ ds
  [(Just 3272,10007)
  ,(Just 14913702,100160063)
  ,(Just 298491901442,1005306552331) ..

  *Ffield> map guess it
  [Just (25 % 52,10007)
  ,Just (1123 % 1135,100160063)
  ,Just (1123 % 1135,1005306552331)
  ,Just (1123 % 1135,10092272478850909) ..

  *Ffield> matches3 it
  Just (1123 % 1135,100160063)

\end{verbatim}
Schematically, this \texttt{scanl1 f} function takes
\begin{eqnarray}
\left[d_0, d_1, d_2, d_3, \cdots \right]
\end{eqnarray}
and returns
\begin{eqnarray}
\left[d_0, f(d_0,d_1), f(f(d_0,d_1),d_2), f(f(f(d_0,d_1),d_2), d_3), \cdots \right]
\end{eqnarray}
%We have used another higher order function which is slightly modified from standard definition:
%\begin{verbatim}
%> -- Strict zipWith, from:
%> --   http://d.hatena.ne.jp/kazu-yamamoto/touch/20100624/1277348961
%> zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]
%> zipWith' f (a:as) (b:bs) = (x `seq` x) : zipWith' f as bs
%>   where x = f a b
%> zipWith' _ _      _      = []
%\end{verbatim}
%
%Let us check our implementation.
%\begin{verbatim}
%  *Ffield> let q = 895%922
%  *Ffield> let knownData = imagesAndPrimes q
%  *Ffield> take 4 knownData 
%  [(882873,897473)
%  ,(365035,897497)
%  ,(705735,897499)
%  ,(511060,897517)
%  ]
%  *Ffield> pile crtRec' it
%  [(882873,897473)
%  ,(86488560937,805479325081)
%  ,(397525881357811624,722916888780872419)
%  ,(232931448259966259937614,648830197267942270883623)
%  ]
%  *Ffield> map guess it
%  [((-854) % 123,897473)
%  ,(895 % 922,805479325081)
%  ,(895 % 922,722916888780872419)
%  ,(895 % 922,648830197267942270883623)
%\end{verbatim}
%So on a product ring $\mathbb{Z}_{805479325081}$, we get the right answer.

\subsection{\texttt{reconstruct}: from image in $\mathbb{Z}_p$ to rational number}
From above discussion, here we define a function which takes a list of images in $\mathbb{Z}_p$ and returns the rational number.
It, basically, takes a list of image (of our target rational number) and primes, then applying Chinese Remainder theorem recursively, return several guess of rational number.

\begin{verbatim}
We should determine the number of matches to cover the range 
of machine size integer, i.e., Int of Haskell.

  *Ffield> let mI = maxBound :: Int
  *Ffield> mI == 2^63-1
  True
  *Ffield> logBase 10 (fromIntegral mI)
  18.964889726830812

Since our choice of bigPrimes are
  O(10^4)
5 times is enough to cover the machine size integers.

> reconstruct :: [(Maybe Int, Int)] -> Maybe (Ratio Integer)
> reconstruct = matches 5 . makeList -- 5 times match
>   where
>     matches n (a:as)
>       | all (a==) $ take (n-1) as = a
>       | otherwise                 = matches n as
>
>     makeList = map (fmap fst . guess) . scanl1 crtRec' . toInteger2 
>                . filter (isJust . fst)

> reconstruct' :: [(Maybe Int, Int)] -> Maybe (Ratio Int)
> reconstruct' = fmap coersion . reconstruct
>   where
>     coersion :: Ratio Integer -> Ratio Int
>     coersion q = (fromInteger . numerator $ q) 
>                    % (fromInteger . denominator $ q)

  *Ffield> let q = 513197683989569 % 1047805145658 :: Ratio Int
  *Ffield> let ds = imagesAndPrimes q
  *Ffield> let answer = fmap fromRational . reconstruct $ ds
  *Ffield> answer :: Maybe (Ratio Int)
  Just (513197683989569 % 1047805145658)
\end{verbatim}

Here is some random checks and results.

\begin{verbatim}
-- QuickCheck

> prop_rec :: Ratio Int -> Bool
> prop_rec q = Just q == answer
>   where
>    answer :: Maybe (Ratio Int)
>    answer = fmap fromRational . reconstruct $ ds
>    ds = imagesAndPrimes q

  *Ffield> quickCheckWith stdArgs { maxSuccess = 100000 } prop_rec 
  +++ OK, passed 100000 tests.
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Polynomials and rational functions}
The following discussion on an arbitrary field $\mathbb{K}$.

\subsection{Notations}
Let $n \in \mathbb{N}$ be positive. 
We use multi-index notation:
\begin{eqnarray}
\alpha = (\alpha_1, \cdots, \alpha_n) \in \mathbb{N}^n.
\end{eqnarray}
A monomial is defined as
\begin{eqnarray}
z^\alpha := \prod_i z_i^{\alpha_i}.
\end{eqnarray}
The total degree of this monomial is given by
\begin{eqnarray}
|\alpha| := \sum_i \alpha_i.
\end{eqnarray}

\subsection{Polynomials and rational functions}
Let $\mathbb{K}$ be a field.
Consider a map
\begin{eqnarray}
f : \mathbb{K}^n \to \mathbb{K}; z \mapsto f(z) := \sum_\alpha c_\alpha z^\alpha,
\end{eqnarray}
where
\begin{eqnarray}
c_\alpha \in \mathbb{K}.
\end{eqnarray}
We call the value $f(z)$ at the dummy $z \in \mathbb{K}^n$ a polynomial:
\begin{eqnarray}
f(z) := \sum_\alpha c_\alpha z^\alpha.
\end{eqnarray}
We denote
\begin{eqnarray}
\mathbb{K}[z] := \left\{ \sum_\alpha c_\alpha z^\alpha \right\}
\end{eqnarray}
as the ring of all polynomial functions in the variable $z$ with $\mathbb{K}$-coefficients.

Similarly, a rational function can be expressed as a ratio of two polynomials $p(z),q(z) \in \mathbb{K}[z]$:
\begin{eqnarray}
\frac{p(z)}{q(z)} = \frac{\sum_\alpha n_\alpha z^\alpha}{\sum_\beta d_\beta z^\beta}.
\end{eqnarray}
We denote
\begin{eqnarray}
\mathbb{K}(z) := \left\{ \frac{\sum_\alpha n_\alpha z^\alpha}{\sum_\beta d_\beta z^\beta} \right\}
\end{eqnarray}
as the field of rational functions in the variable $z$ with $\mathbb{F}$-coefficients.
Similar to fractional numbers, there are several equivalent representation of a rational function, even if we simplify with gcd.
However there still is an overall constant ambiguity.
To have a unique representation, usually we put the lowest degree of term of the denominator to be 1.

\subsection{As data, coefficients list}
We can identify a polynomial
\begin{eqnarray}
\sum_\alpha c_\alpha z^\alpha
\end{eqnarray}
as a set of coefficients
\begin{eqnarray}
\{ c_\alpha\}_{\alpha}.
\end{eqnarray}

Similarly, for a rational function, we can identify
\begin{eqnarray}
\frac{\sum_\alpha n_\alpha z^\alpha}{\sum_\beta d_\beta z^\beta}
\end{eqnarray}
as an ordered pair of coefficients
\begin{eqnarray}
(\{ n_\alpha\}_\alpha, \{ d_\beta\}_\beta).
\end{eqnarray}
However, there still is an overall factor ambiguity even after gcd simplifications.

\section{Haskell implementation of univariate polynomials}
Here we basically follows some part of \S9 of ref.\ref{Haskellroad}, and its addendum\footnote{
See \url{http://homepages.cwi.nl/~jve/HR/PolAddendum.pdf}
}.

\begin{verbatim}
Univariate.lhs

> module Univariate where
> import Data.Ratio
> import Polynomials 
\end{verbatim}

\subsection{A polynomial as a list of coefficients}
Let us start \texttt{instance} declaration, which enable us to use basic arithmetics, e.g., addition and multiplication.

\lstinputlisting[caption=Polynomials.hs,label=Polynomials]{Polynomials.hs}

%\begin{verbatim}
%-- Polynomials.hs
%-- http://homepages.cwi.nl/~jve/rcrh/Polynomials.hs
%
%module Polynomials where
%
%default (Integer, Rational, Double) 
%
%-- polynomials, as coefficients lists
%instance (Num a, Ord a) => Num [a] where
%  fromInteger c = [fromInteger c] 
%  -- operator overloading
%  negate []     = []
%  negate (f:fs) = (negate f) : (negate fs)
%
%  signum [] = []
%  signum gs 
%    | signum (last gs) < (fromInteger 0) = negate z
%    | otherwise = z
%
%  abs [] = []
%  abs gs 
%    | signum gs == z = gs
%    | otherwise      = negate gs
%
%  fs     + []     = fs
%  []     + gs     = gs
%  (f:fs) + (g:gs) = f+g : fs+gs
%
%  fs     * []     = []
%  []     * gs     = []
%  (f:fs) * gg@(g:gs) = f*g : (f .* gs + fs * gg)
%
%delta :: (Num a, Ord a) => [a] -> [a]
%delta = ([1,-1] *)
%
%shift :: [a] -> [a]
%shift = tail 
%
%p2fct :: Num a => [a] -> a -> a
%p2fct [] x = 0
%p2fct (a:as) x = a + (x * p2fct as x)
%
%comp :: (Eq a, Num a, Ord a) => [a] -> [a] -> [a]
%comp _     []      = error ".."
%comp []     _      = []
%comp (f:fs) g0@(0:gs) = f : gs * (comp fs g0)
%comp (f:fs) gg@(g:gs) = ([f] + [g] * (comp fs gg))
%                      + (0 : gs * (comp fs gg))
%
%deriv :: Num a => [a] -> [a]
%deriv []     = []
%deriv (f:fs) = deriv1 fs 1 
%  where 
%    deriv1 []     _ = []
%    deriv1 (g:gs) n = n*g : deriv1 gs (n+1)
%
%\end{verbatim}
Note that the above operators are overloaded, say \texttt{(*)}, \texttt{f*g} is a multiplication of two numbers but \texttt{fs*gg} is a multiplication of two list of coefficients.
We can not extend this overloading to scalar multiplication, since Haskell type system takes the operands of \texttt{(*)} the same type
\begin{eqnarray}
\verb+(*) :: Num a => a -> a -> a+
\end{eqnarray}

\begin{verbatim}
> -- scalar multiplication
> infixl 7 .*
> (.*) :: Num a => a -> [a] -> [a]
> c .* []     = []
> c .* (f:fs) = c*f : c .* fs
\end{verbatim}
Let us see few examples.
If we take a scalar multiplication, say
\begin{eqnarray}
3 * \left( 1+2z+3z^2+4z^3\right)
\end{eqnarray}
the result should be
\begin{eqnarray}
3 * \left( 1+2z+3z^2+4z^3\right)
=
3+6z+9z^2+12z^3
\end{eqnarray}
In Haskell 
\begin{verbatim}
  *Univariate> 3 .* [1,2,3,4]
  [3,6,9,12]
\end{verbatim}
and this is exactly same as map with section:
\begin{verbatim}
  *Univariate> map (3*) [1,2,3,4]
  [3,6,9,12]
\end{verbatim}
When we multiply two polynomials, say
\begin{eqnarray}
(1+2z) * (3+4z+5z^2+6z^3)
\end{eqnarray}
the result should be
\begin{eqnarray}
\nonumber
(1+2z) * (3+4z+5z^2+6z^3)
&=& 1*(3+4z+5z^2+6z^3) + 2z*(3+4z+5z^2+6z^3) \\
\nonumber
&=& 3+(4+2*3)z+(5+2*4)z^2+(6+2*5)z^3 + 2*6 z^4 \\
&=& 3+ 10z + 13z^2 + 16 z^3 + 12 z^4 
\end{eqnarray}
In Haskell,
\begin{verbatim}
  *Univariate> [1,2] * [3,4,5,6]
  [3,10,13,16,12]
\end{verbatim}

Now the (dummy) variable is given as 
\begin{verbatim}
> -- z of f(z), variable
> z :: Num a => [a]
> z = [0,1]
\end{verbatim}

A polynomial of degree $R$ is given by a finite sum of the following form:
\begin{eqnarray}
f(z) := \sum_{i=0}^R c_i z^i.
\end{eqnarray}
Therefore, it is natural to represent $f(z)$ by a list of coefficient $\{c_i\}_i$.
Here is the translator from the coefficient list to a polynomial function:
\begin{verbatim}
> p2fct :: Num a => [a] -> a -> a
> p2fct [] x = 0
> p2fct (a:as) x = a + (x * p2fct as x)
\end{verbatim}
This gives us\footnote{
Here we have used lambda, or so called anonymous function.
From\\
\url{http://learnyouahaskell.com/higher-order-functions}
\begin{quote}
To make a lambda, we write a \textbackslash (because it kind of looks like the greek letter lambda if you squint hard enough) and then we write the parameters, separated by spaces. 
\end{quote}
For example,
\begin{eqnarray}
f(x) &:=& x^2 + 1 \\
f &:=& \lambda x. x^2+1
\end{eqnarray}
are the same definition.
}
\begin{verbatim}
*Univariate> take 10 $ map (p2fct [1,2,3]) [0..]
[1,6,17,34,57,86,121,162,209,262]
*Univariate> take 10 $ map (\n -> 1+2*n+3*n^2) [0..]
[1,6,17,34,57,86,121,162,209,262]
\end{verbatim}

\subsection{Difference analysis}
We do not know in general this canonical form of the polynomial, nor the degree.
That means, what we can access is the graph of $f$, i.e., the list of inputs and outputs.
Without loss of generality, we can take
\begin{eqnarray}
\texttt{[0..]}
\end{eqnarray}
as the input data.
Usually we take a finite sublist of this, but we assume it is sufficiently long.
The outputs should be
\begin{eqnarray}
\texttt{map f [0..] = [f 0, f 1 ..]}
\end{eqnarray}
For example
\begin{verbatim}
*Univariate> take 10 $ map (\n -> n^2+2*n+1) [0..]
[1,4,9,16,25,36,49,64,81,100]
\end{verbatim}

Let us consider the difference sequence
\begin{eqnarray}
\label{difference}
\Delta(f) (n) := f(n+1) - f(n).
\end{eqnarray}
Its Haskell version is
\begin{verbatim}
> -- difference analysis
> difs :: (Num a) => [a] -> [a]
> difs [] = []
> difs [_] = []
> difs (i:jj@(j:js)) = j-i : difs jj
\end{verbatim}
This gives
\begin{verbatim}
*Univariate> difs [1,4,9,16,25,36,49,64,81,100]
[3,5,7,9,11,13,15,17,19]
*Univariate> difs [3,5,7,9,11,13,15,17,19]
[2,2,2,2,2,2,2,2]
\end{verbatim}

We claim that if $f(z)$ is a polynomial of degree $R$, then $\Delta(f)(z)$ is a polynomial of degree $R-1$.
Since the degree is given, we can write $f(z)$ in canonical form
\begin{eqnarray}
f(n) = \sum_{i=0}^R c_i n^i
\end{eqnarray}
and
\begin{eqnarray}
\Delta(f)(n) &:=& f(n+1) - f(n) \\
&=& \sum_{i=0}^R c_i \left\{ (n+1)^i - n^i\right\} \\
&=& \sum_{i=1}^R c_i \left\{ (n+1)^i - n^i\right\} \\
&=& \sum_{i=1}^R c_i \left\{ i*n^{i-1} + O(n^{i-2}) \right\} \\
&=& c_R*R*n^{R-1} + O(n^{R-2})
\end{eqnarray}
where $O(n^{i-2})$ is some polynomial(s) of degree $i-2$.

This guarantees the following function will terminate in finite steps\footnote{
If a given lists is generated by a polynomial.
}; \texttt{difLists} keeps generating difference lists until the difference get constant.
\begin{verbatim}
> difLists :: (Eq a, Num a) => [[a]] -> [[a]]
> difLists [] = []
> difLists xx@(xs:xss) =
>   if isConst xs then xx
>                 else difLists $ difs xs : xx
>   where
>     isConst (i:jj@(j:js)) = all (==i) jj
>     isConst _ = error "difLists: lack of data, or not a polynomial"
\end{verbatim}
Let us try:
\begin{verbatim}
  *Univariate> difLists [[-12,-11,6,45,112,213,354,541,780,1077]]
  [[6,6,6,6,6,6,6]
  ,[16,22,28,34,40,46,52,58]
  ,[1,17,39,67,101,141,187,239,297]
  ,[-12,-11,6,45,112,213,354,541,780,1077]
  ]
\end{verbatim}

The degree of the polynomial can be computed by difference analysis:
\begin{verbatim}
> degree' :: (Eq a, Num a) => [a] -> Int
> degree' xs = length (difLists [xs]) -1
\end{verbatim}
For example,
\begin{verbatim}
*Univariate> degree [1,4,9,16,25,36,49,64,81,100]
2
*Univariate> take 10 $ map (\n -> n^2+2*n+1) [0..]
[1,4,9,16,25,36,49,64,81,100]
*Univariate> degree $ take 10 $ map (\n -> n^5+4*n^3+1) [0..]
5
\end{verbatim}

Above \verb+degree'+ function can only treat finite list, however, the following function can compute the degree of infinite list.
\begin{verbatim} 
> degreeLazy :: (Eq a, Num a) => [a] -> Int
> degreeLazy xs = helper xs 0
>   where
>     helper as@(a:b:c:_) n
>       | a==b && b==c = n
>       | otherwise    = helper (difs as) (n+1)
\end{verbatim}
Note that this lazy function only sees the first two elements of the list (of difference).
So first take the lazy \verb+degreeLazy+ and guess the degree, take sufficient finite sublist of output and apply \verb+degree'+.
Here is the hybrid version:
\begin{verbatim}
> degree :: (Num a, Eq a) => [a] -> Int
> degree xs = let l = degreeLazy xs in
>   degree' $ take (l+2) xs
\end{verbatim}

\chapter{Functional reconstruction over $\mathbb{Q}$}
The goal of a functional reconstruction algorithm is to identify the monomials appearing in their definition and the corresponding coefficients.

From here, we use $\mathbb{Q}$ as our base field, but every algorithm can be computed on any field, e.g., finite field $\mathbb{Z}_p$.

\section{Univariate polynomials}
\subsection{Newtons' polynomial representation}
Consider a univariate polynomial $f(z)$.
Given a sequence of distinct values $\left. y_n \right|_{n \in \mathbb{N}}$, we evaluate the polynomial form $f(z)$ sequentially:
\begin{eqnarray}
f_0(z) &=& a_0 \\
f_1(z) &=& a_0 + (z-y_0)a_1 \\
\nonumber
&\vdots& \\
f_r(z) &=& a_0 + (z-y_0) \left(a_1 + (z-y_1)\left(a_2  \cdots \left( a_{r-1} + (z - y_{r-1})a_r \right) \right) \cdots \right) \qquad \\
&=& f_{r-1}(z) + (z-y_0) (z-y_1) \cdots (z - y_{r-1})a_r,
\end{eqnarray}
where
\begin{eqnarray}
a_0 &=& f(y_0) \\
a_1 &=& \frac{f(y_1) - a_0}{y_1 - y_0} \\
\nonumber
&\vdots& \\
a_r &=& \left( \left( \left( f(y_r)-a_0 \right)\frac{1}{y_r - y_0} - a_1 \right)\frac{1}{y_r - y_1} - \cdots - a_{r-1} \right) \frac{1}{y_r - y_{r-1}} \qquad
\end{eqnarray}
It is easy to see that, $f_r(z)$ and the original $f(z)$ match on the given data points, i.e.,
\begin{eqnarray}
f_r(n) = f(n), 0 \leq n \leq r.
\end{eqnarray}

When we have already known the total degree of $f(z)$, say $R$, then we can terminate this sequential trial:
\begin{eqnarray}
f(z) &=& f_R(z) \\
&=& \sum_{r=0}^R a_r \prod_{i=0}^{r-1}(z - y_i).
\end{eqnarray}

In practice, a consecutive zero on the sequence $a_r$ can be taken as the termination condition for this algorithm.\footnote{
We have not proved, but higher power will be dominant when we take sufficiently big input, so we terminate this sequence when we get a consecutive zero in $a_r$.
}

\subsection{Towards canonical representations}
Once we get the Newton's representation
\begin{eqnarray}
\sum_{r=0}^R a_r \prod_{i=0}^{r-1}(z - y_i) = a_0 + (z-y_0) \left(a_1 + (z-y_1)(\cdots + (z - y_{R-1})a_R \right) \quad
\end{eqnarray}
as the reconstructed polynomial, it is convenient to convert it into the canonical form:
\begin{eqnarray}
\sum_{r=0}^R c_r z^r.
\end{eqnarray}
This conversion only requires addition and multiplication of univariate polynomials.
These operations are reasonably cheap, especially on $\mathbb{Z}_p$. 

%\subsection{Simplification of our problem}
%Without loss of generality, we can put 
%\begin{eqnarray}
%\texttt{[0..]}
%\end{eqnarray}
%as our input list. 
%We usually take its finite part but we assume it has enough length.
%Corresponding to above input,
%\begin{eqnarray}
%\texttt{map f [0..] = [f 0, f 1, ..]}
%\end{eqnarray}
%of \texttt{f :: Ratio Int -> Ratio Int} is our output list.
%
%Then we have slightly simpler forms of coefficients:
%\begin{eqnarray}
%f_r(z) &:=& a_0 + z*\left( a_1 +(z-1)\left(a_2 + (z-2)\left(a_3 + \cdots + (z-r+1)a_r \right) \right) \right) \qquad\qquad \\
%a_0 &=& f(0) \\
%a_1 &=& f(y_1) - a_0 \\
%&=& f(1) - f(0) =: \Delta(f)(0) \\
%a_2 &=& \frac{f(2)-a_0}{2}-a_1 \\
%&=& \frac{f(2) - f(0)}{2} - \left( f(1) - f(0) \right) \\
%&=& \frac{f(2)-2f(1)-f(0)}{2} \\
%&=& \frac{\left( f(2)-f(1) \right) -\left(f(1)-f(0) \right)}{2} =: \frac{\Delta^2(f)(0)}{2} \\
%\nonumber
%&\vdots&\\
%a_r &=& \frac{\Delta^r(f)(0)}{r!},
%\end{eqnarray}
%where $\Delta$ is the difference operator in eq.(\ref{difference}):
%\begin{eqnarray}
%\Delta(f)(n) := f(n+1) - f(n).
%\end{eqnarray}
%
%In order to simplify our expression, we introduce a falling power:
%\begin{eqnarray}
%(x)_0 &:=& 1 \\
%(x)_n &:=& x(x-1) \cdots (x-n+1) \\
%&=& \prod_{i=0}^{n-1} (x-i).
%\end{eqnarray}
%
%Under these settings, we have
%\begin{eqnarray}
%f(z) &=& f_R(z) \\
%&=& \sum_{r=0}^R \frac{\Delta^r(f)(0)}{r!} (x)_r,
%\end{eqnarray}
%where we have assume
%\begin{eqnarray}
%\Delta^{R+1}(f) = [0,0,\cdots].
%\end{eqnarray}
%
%
%\subsubsection{Example}
%Consider a polynomial
%\begin{eqnarray}
%f(z) := 2*z^3+3*z,
%\end{eqnarray}
%and its out put list
%\begin{eqnarray}
%\left[ f(0), f(1), f(3), \cdots\right] = \left[0,5,22,63,140,265, \cdots \right]
%\end{eqnarray}
%This polynomial is 3rd degree, so we compute up to $\Delta^3(f)(0)$:
%\begin{eqnarray}
%f(0) &=& 0 \\
%\Delta(f)(0) &=& f(1) - f(0) = 5\\
%\nonumber
%\Delta^2(f)(0) &=& \Delta(f)(1) - \Delta(f)(0) \\
%&=& f(2) - f(1) - 5 = 22 -5 -5= 12 \\
%\nonumber
%\Delta^3(f)(0) &=& \Delta^2(f)(1) - \Delta^2(f)(0) \\
%&=& f(3)-f(2) - \left\{ f(2) - f(1)\right\} - 12 = 12
%\end{eqnarray}
%so we get
%\begin{eqnarray}
%\label{exOfDiff}
%\left[0,5,12,12\right]
%\end{eqnarray}
%as the first difference list.
%Therefore, we get the falling power representation of $f$:
%\begin{eqnarray}
%f(z) &=& 5(x)_1 + \frac{12}{2}(x)_2 + \frac{12}{3!}(x)_3 \\
%\label{exOfNewton} &=&  5(x)_1 + 6(x)_2 + 2(x)_3.
%\end{eqnarray}
%
%\section{Univariate polynomial reconstruction with Haskell}
%\subsection{Newton interpolation formula with Haskell}
%First, the falling power is naturally given by recursively:
%\begin{verbatim}
%> infixr 8 ^- -- falling power
%> (^-) :: (Integral a) => a -> a -> a
%> x ^- 0 = 1
%> x ^- n = (x ^- (n-1)) * (x - n + 1)
%\end{verbatim}
%
%Assume the differences are given in a list
%\begin{eqnarray}
%\texttt{xs} = \left[f(0), \Delta(f)(0), \Delta^2(f)(0), \cdots \right].
%\end{eqnarray}
%Then the implementation of the Newton interpolation formula is as follows:
%\begin{verbatim}
%> newtonC :: (Fractional t, Enum t) => [t] -> [t]
%> newtonC xs = [x / factorial k | (x,k) <- zip xs [0..]]
%>   where
%>     factorial k = product [1..fromInteger k]
%\end{verbatim}
%Consider a polynomial
%\begin{eqnarray}
%\verb|f x = 2*x^3+3*x|
%\end{eqnarray}
%Let us try to reconstruct this polynomial from output list.
%In order to get the list \verb+[x_0, x_1 ..]+, take \texttt{difLists} and pick the first elements:
%\begin{verbatim}
%  > let f x = 2*x^3+3*x
%  > take 10 $ map f [0..]
%  [0,5,22,63,140,265,450,707,1048,1485]
%  > difLists [it]
%  [[12,12,12,12,12,12,12]
%  ,[12,24,36,48,60,72,84,96]
%  ,[5,17,41,77,125,185,257,341,437]
%  ,[0,5,22,63,140,265,450,707,1048,1485]
%  ]
%  > reverse $ map head it
%  [0,5,12,12]
%\end{verbatim}
%This list is the same as eq.(\ref{exOfDiff}) and we get the same expression as eq.(\ref{exOfNewton}) $5(x)_1 + 6(x)_2 + 2(x)_3$:
%\begin{verbatim}  
%  > newtonC it
%  [0 % 1,5 % 1,6 % 1,2 % 1]
%\end{verbatim}
%
%The list of first differences, i.e.,
%\begin{eqnarray}
%\left[ f(0), \Delta(f)(0), \Delta^2(f)(0), \cdots \right]
%\end{eqnarray}
%can be computed as follows:
%\begin{verbatim}
%> firstDifs :: (Eq a, Num a) => [a] -> [a]
%> firstDifs xs = reverse $ map head $ difLists [xs]
%\end{verbatim}
%Mapping a list of integers to a Newton representation:
%\begin{verbatim}
%> list2npol :: (Integral a) => [Ratio a] -> [Ratio a]
%> list2npol = newtonC . firstDifs
%
%  *NewtonInterpolation> take 10 $ map f [0..]
%  [0,5,22,63,140,265,450,707,1048,1485]
%  *NewtonInterpolation> list2npol it
%  [0 % 1,5 % 1,6 % 1,2 % 1]
%\end{verbatim}
%Therefore, we get the Newton coefficients from the output list.
%
%\subsection{Stirling numbers of the first kind}
%We need to map Newton falling powers to standard powers to get the canonical representation.  
%This is a matter of applying combinatorics, by means of a convention formula that uses the so-called Stirling cyclic numbers 
%\begin{eqnarray}
%\left[\begin{array}{c}n \\k \end{array}\right]
%\end{eqnarray}
%Its defining relation is, $\forall n > 0$,
%\begin{eqnarray}
%(x)_n = \sum_{k=1}^n (-)^{n-k} \left[\begin{array}{c}n \\k \end{array}\right] x^k, 
%\end{eqnarray}
%and
%\begin{eqnarray}
%\left[\begin{array}{c}0 \\0 \end{array}\right] := 1.
%\end{eqnarray}
%From the highest order, $x^n$, we get
%\begin{eqnarray}
%\left[\begin{array}{c}n \\n \end{array}\right] = 1, \forall n > 0.
%\end{eqnarray}
%We also put
%\begin{eqnarray}
%\left[\begin{array}{c}0 \\1 \end{array}\right] = \left[\begin{array}{c}0 \\2 \end{array}\right] = \left[\begin{array}{c}0 \\3 \end{array}\right] = \cdots = 0,
%\end{eqnarray}
%and
%\begin{eqnarray}
%\left[\begin{array}{c}1 \\ 0 \end{array}\right] = \left[\begin{array}{c}2  \\ 0 \end{array}\right] =\left[\begin{array}{c}3 \\ 0 \end{array}\right] = \cdots = 0.
%\end{eqnarray}
%
%The key equation is
%\begin{eqnarray}
%(x)_n = (x)_{n-1}*  (x-n+1)
%\end{eqnarray}
%and we get
%\begin{eqnarray}
%(x)_n &=& \sum_{k=1}^n (-)^{n-k} \left[\begin{array}{c}n \\k \end{array}\right] x^k\\
%&=& x^n + \sum_{k=1}^{n-1} (-)^{n-k} \left[\begin{array}{c}n \\k \end{array}\right] x^k\\
%(x)_{n-1}*  (x-n+1) &=&  \sum_{k=1}^{n-1} (-)^{n-1-k} \left\{ \left[\begin{array}{c}n-1 \\k \end{array}\right] x^{k+1} -(n-1) \left[\begin{array}{c}n-1 \\k \end{array}\right] x^k \right\} \qquad \qquad \\
%&=& \sum_{l=2}^n (-)^{n-l} \left[\begin{array}{c}n-1 \\l-1 \end{array}\right] x^l + (n-1)\sum_{k=1}^{n-1} (-)^{n-k} \left[\begin{array}{c}n \\k \end{array}\right] x^k \\
%\nonumber &=& x^n + (n-1)(-)^{n-1} x \\
%&&+ \sum_{k=2}^{n-1} (-)^{n-k} \left\{ \left[\begin{array}{c}n-1 \\k-1 \end{array}\right]  + (n-1)  \left[\begin{array}{c}n-1 \\k \end{array}\right] \right\} x^k \\
%&=& x^n + \sum_{k=1}^{n-1} (-)^{n-k} \left\{ \left[\begin{array}{c}n-1 \\k-1 \end{array}\right]  + (n-1)  \left[\begin{array}{c}n-1 \\k \end{array}\right] \right\} x^k 
%\end{eqnarray}
%Therefore, $\forall n,k > 0$,
%\begin{eqnarray}
%\left[\begin{array}{c}n \\k \end{array}\right] = \left[\begin{array}{c}n-1 \\k-1 \end{array}\right]  + (n-1)  \left[\begin{array}{c}n-1 \\k \end{array}\right]
%\end{eqnarray}
%
%Now we have the following canonical, power representation of reconstructed polynomial
%\begin{eqnarray}
%f(z) &=& f_R(z) \\
%&=& \sum_{r=0}^R \frac{\Delta^r(f)(0)}{r!} (x)_r \\
%&=& \sum_{r=0}^R \frac{\Delta^r(f)(0)}{r!} \sum_{k=1}^r (-)^{r-k} \left[\begin{array}{c}r \\k \end{array}\right] x^k, 
%\end{eqnarray}
%So, what shall we do is to sum up order by order.
%
%Here is an implementation, first the Stirling numbers:
%\begin{verbatim}
%> stirlingC :: Integer -> Integer -> Integer
%> stirlingC 0 0 = 1
%> stirlingC 0 _ = 0
%> stirlingC n k = (n-1)*(stirlingC (n-1) k) + stirlingC (n-1) (k-1)
%\end{verbatim}
%This definition can be used to convert from falling powers to standard powers.
%\begin{verbatim}
%> fall2pol :: (Integral a) => a -> [a]
%> fall2pol 0 = [1]
%> fall2pol n = 0   -- No constant term. 
%>            : [(-1)^(n-k) * stirlingC n k| k<-[1..n]]
%\end{verbatim}
%We use \texttt{fall2pol} to convert Newton representations to standard polynomials in coefficients list representation.
%Here we have uses \verb+sum+ to collect same order terms in list representation.
%\begin{verbatim}
%> npol2pol :: (Integral a) => [Ratio a] -> [Ratio a]
%> npol2pol xs = sum [ [x] * map fromInteger (fall2pol k)
%>                   | (x,k) <- zip xs [0..]
%>                   ]
%\end{verbatim}
%
%\subsection{\texttt{list2pol}: from output list to canonical coefficients}
%Finally, here is the function for computing a polynomial from an output sequence:
%\begin{verbatim}
%> list2pol :: (Integral a) => [Ratio a] -> [Ratio a]
%> list2pol = npol2pol . list2npol
%\end{verbatim}
%Here are some checks on these functions:
%\begin{verbatim}
%Reconstruction as curve fitting
%  *NewtonInterpolation> list2pol $ map (\n -> 7*n^2+3*n-4) [0..100]
%  [(-4) % 1,3 % 1,7 % 1]
%
%  *NewtonInterpolation> list2pol [0,1,5,14,30]
%  [0 % 1,1 % 6,1 % 2,1 % 3]
%  *NewtonInterpolation> map (\n -> n%6 + n^2%2 + n^3%3) [0..4]
%  [0 % 1,1 % 1,5 % 1,14 % 1,30 % 1]
%
%  *NewtonInterpolation> map (p2fct $ list2pol [0,1,5,14,30]) [0..8]
%  [0 % 1,1 % 1,5 % 1,14 % 1,30 % 1,55 % 1,91 % 1,140 % 1,204 % 1]
%
%\end{verbatim}
%First example shows that from the sufficiently long output list, we can reconstruct the list of coefficients.
%Second example shows that from a given outputs, we have a list coefficients.
%Then use these coefficients, we define the output list of the function, and they match.
%The last example shows that from a limited (but sufficient) output information, we reconstruct a function and get extra outputs outside from the given data.

\section{Univariate rational functions}
We use the same notion, i.e., what we can know is the output-list of a univariate rational function, say \texttt{f::Int -> Ratio Int}:
\begin{eqnarray}
\texttt{map f [0..] == [f 0, f 1 ..]}
\end{eqnarray}

\subsection{Thiele's interpolation formula}
We evaluate the polynomial form $f(z)$ as a continued fraction:
\begin{eqnarray}
f_0(z) &=& a_0 \\
f_1(z) &=& a_0 + \frac{z}{a_1} \\
\nonumber
&\vdots& \\
f_r(z) &=& a_0 + \cfrac{z}{a_1 + \cfrac{z-1}{a_2 + \cfrac{z- 2}{a_{r-2} + \cfrac{\vdots}{a_{r-1} + \cfrac{z-r+1}{a_r}}}}},
\end{eqnarray}
where
\begin{eqnarray}
a_0 &=& f(0) \\
a_1 &=& \frac{1}{f(1) - a_0}\\
a_2 &=& \cfrac{1}{\cfrac{2}{f(2)-a_0} - a_1} \\
\nonumber
&\vdots& \\
a_r &=&\cfrac{1}{\cfrac{2}{\cfrac{3}{\cfrac{\vdots}{\cfrac{r}{f(r)-a_0}-a_1}-a_2} - a_{r-2}} - a_{r-1}} \\
&=& \left( \left( \left( f(r)-a_0 \right)^{-1} r - a_1 \right)^{-1} (r - 1) - \cdots - a_{r-1} \right)^{-1} 1 \qquad\qquad
\end{eqnarray}

\subsection{Towards canonical representations}
In order to get a unique representation of canonical form
\begin{eqnarray}
\frac{\sum_\alpha n_\alpha z^\alpha}{\sum_\beta d_\beta z^\beta}
\end{eqnarray}
we put
\begin{eqnarray}
d_{\min r'} = 1
\end{eqnarray}
as a normalization, instead of $d_0$.
However, if we meet 0 as a singular value, then we can shift s.t. the new $d_0 \neq 0$.
So without loss of generality, we can assume $f(0)$ is not singular, i.e., the denominator of $f$ has a nonzero constant term:
\begin{eqnarray}
d_0 &=& 1\\
f(z) &=& \frac{\sum_i n_i z^i}{1 + \sum_{j >0} d_ z^j}.
\end{eqnarray}

%\section{Univariate rational function reconstruction with Haskell}
%Here we the same notion of
%\begin{quotation}
%\url{https://rosettacode.org/wiki/Thiele%27s_interpolation_formula}
%\end{quotation}
%and especially
%\begin{quotation}
%\url{https://rosettacode.org/wiki/Thiele%27s_interpolation_formula#C}
%\end{quotation}
% 
%\subsection{Reciprocal difference}
%We claim, without proof\footnote{
%See the ref.\ref{Numerical}, Theorem (2.2.2.5) in 2nd edition.
%}, that the Thiele coefficients are given by
%\begin{eqnarray}
%a_0 &:=& f(0) \\
%a_n &:=& \rho_{n,0} - \rho_{{n-2},0},
%\end{eqnarray}
%where $\rho$ is so called the reciprocal difference:
%\begin{eqnarray}
%\rho_{n,i} &:=& 0, n<0 \\
%\rho_{0,i} &:=& f(i), i=0,1,2,\cdots \\
%\rho_{n,i} &:=& \frac{n}{\rho_{{n-1}, i+1} - \rho_{{n-1},i}} + \rho_{{n-2},i+1}
%\end{eqnarray}
%
%These preparation helps us to write the following codes:
%\begin{verbatim}
%Thiele's interpolation formula
%
%Reciprocal difference rho, using the same notation of 
%https://rosettacode.org/wiki/Thiele%27s_interpolation_formula#C
%
%> rho :: [Ratio Int] -- A list of output of f :: Int -> Ratio Int
%>     -> Int -> Int -> Ratio Int
%> rho fs 0 i = fs !! i
%> rho fs n _ 
%>   | n < 0 = 0
%> rho fs n i = (n*den)%num + rho fs (n-2) (i+1)
%>   where
%>     num  = numerator next
%>     den  = denominator next
%>     next = (rho fs (n-1) (i+1)) - (rho fs (n-1) i)
%
%Note that (%) has the following type,
%  (%) :: Integral a => a -> a -> Ratio a
%
%> a fs 0 = fs !! 0
%> a fs n = rho fs n 0 - rho fs (n-2) 0
%\end{verbatim}
%
%\subsection{\texttt{tDegree} for termination}
%Now let us consider a simple example which is given by the following Thiele coefficients
%\begin{eqnarray}
%a_0 = 1, a_1 = 2, a_2 = 3, a_3=4.
%\end{eqnarray}
%The function is now
%\begin{eqnarray}
%f(x) &:=& 1 + \cfrac{x}{2+\cfrac{x-1}{3+\cfrac{x-2}{4}}} \\
%&=& \frac{x^2+16x+16}{16+6x}
%\end{eqnarray}
%Using Maxima\footnote{
%\url{http://maxima.sourceforge.net}
%}, we can verify this:
%\begin{verbatim}
%  (%i25) f(x) := 1+(x/(2+(x-1)/(3+(x-2)/4)));
%  (%o25) f(x):=x/(2+(x-1)/(3+(x-2)/4))+1
%  (%i26) ratsimp(f(x));
%  (%o26) (x^2+16*x+16)/(16+6*x)
%\end{verbatim}
%Let us come back Haskell, and try to get the Thiele coefficients of
%\begin{verbatim}
%  *Univariate> let func x = (x^2 + 16*x + 16)%(6*x + 16)
%  *Univariate> let fs = map func [0..]
%  *Univariate> map (a fs) [0..]
%  [1 % 1,2 % 1,3 % 1,4 % 1,*** Exception: Ratio has zero denominator\end{verbatim}
%This is clearly unsafe, so let us think more carefully.
%Observe the reciprocal differences
%\begin{verbatim}
%  *Univariate> let fs = map func [0..]
%  *Univariate> take 5 $ map (rho fs 0) [0..]
%  [1 % 1,3 % 2,13 % 7,73 % 34,12 % 5]
%  *Univariate> take 5 $ map (rho fs 1) [0..]
%  [2 % 1,14 % 5,238 % 69,170 % 43,230 % 53]
%  *Univariate> take 5 $ map (rho fs 2) [0..]
%  [4 % 1,79 % 16,269 % 44,667 % 88,413 % 44]
%  *Univariate> take 5 $ map (rho fs 3) [0..]
%  [6 % 1,6 % 1,6 % 1,6 % 1,6 % 1]
%\end{verbatim}
%So, the constancy of the reciprocal differences can be used to get the depth of Thiele series:
%\begin{verbatim}
%> tDegree :: [Ratio Int] -> Int
%> tDegree fs = helper fs 0
%>   where
%>     helper fs n
%>       | isConstants fs' = n
%>       | otherwise       = helper fs (n+1)
%>       where
%>         fs' = map (rho fs n) [0..]
%>     isConstants (i:j:_) = i==j -- 2 times match
%> --  isConstants (i:j:k:_) = i==j && j==k
%\end{verbatim}
%Using this \verb+tDegree+ function, we can safely take the (finite) Thiele sequence.
%
%\subsection{\texttt{thieleC}: from output list to Thiele coefficients}
%From the equation (3.26) of ref.\ref{Tiziano},
%\begin{verbatim}
%  *Univariate> let h t = (3+6*t+18*t^2)%(1+2*t+20*t^2)
%  *Univariate> let hs = map h [0..]
%  *Univariate> tDegree hs
%  4
%\end{verbatim}
%So we get the Thiele coefficients
%\begin{verbatim}  
%  *Univariate> map (a hs) [0..(tDegree hs)]
%  [3 % 1,(-23) % 42,(-28) % 13,767 % 14,7 % 130]
%\end{verbatim}
%Plug these in the continued fraction, and simplify with Maxima
%\begin{verbatim}
%  (%i35) h(t):=3+t/((-23/42)+(t-1)/((-28/13)+(t-2)/((767/14)+(t-3)/(7/130))));
%  (%o35) h(t):=t/((-23)/42+(t-1)/((-28)/13+(t-2)/(767/14+(t-3)/(7/130))))+3
%  (%i36) ratsimp(h(t));
%  (%o36) (18*t^2+6*t+3)/(1+2*t+20*t^2)
%\end{verbatim}
%
%Finally we make a function \verb+thieleC+ that returns the Thiele coefficients:
%\begin{verbatim}
%> thieleC :: [Ratio Int] -> [Ratio Int]
%> thieleC lst = map (a lst) [0..(tDegree lst)]
%
%  *Univariate> thieleC hs
%  [3 % 1,(-23) % 42,(-28) % 13,767 % 14,7 % 130]
%\end{verbatim}
%
%We need a convertor from this Thiele sequence to continuous form of rational function.
%\begin{verbatim}
%> nextStep [a0,a1] (v:_)  = a0 + v/a1
%> nextStep (a:as)  (v:vs) = a + (v / nextStep as vs)
%>
%> -- From thiele sequence to (rational) function.
%> thiele2ratf :: Integral a => [Ratio a] -> (Ratio a -> Ratio a)
%> thiele2ratf as x
%>   | x == 0 = head as
%>   | otherwise = nextStep as [x,x-1 ..]
%\end{verbatim}
%The following example shows that, the given output lists \verb+hs+, we can interpolate the value between our discrete data.
%\begin{verbatim}
%  *Univariate> let h t = (3+6*t+18*t^2)%(1+2*t+20*t^2)
%  *Univariate> let hs = map h [0..]
%  *Univariate> take 5 hs
%  [3 % 1,27 % 23,87 % 85,183 % 187,45 % 47]
%  *Univariate> let as = thieleC hs
%  *Univariate> as
%  [3 % 1,(-23) % 42,(-28) % 13,767 % 14,7 % 130]
%  *Univariate> let th x = thiele2ratf as x
%  *Univariate> map th [0..5]
%  [3 % 1,27 % 23,87 % 85,183 % 187,45 % 47,69 % 73]
%  *Univariate> th 0.5
%  3 % 2
%\end{verbatim}
%
%\subsection{Haskell representation for rational functions}
%We represent a rational function by a tuple of coefficient lists, like,
%\begin{eqnarray}
%\texttt{(ns,ds) :: ([Ratio Int],[Ratio Int])}
%\end{eqnarray}
%
%Here is a translator from coefficients lists to rational function.
%\begin{verbatim}
%> lists2ratf :: (Integral a) => 
%>   ([Ratio a],[Ratio a]) -> (Ratio a -> Ratio a)
%> lists2ratf (ns,ds) x = (p2fct ns x)/(p2fct ds x)
%
%  *Univariate> let frac x = lists2ratf ([1,1%2,1%3],[2,2%3]) x
%  *Univariate> take 10 $ map frac [0..]
%  [1 % 2,11 % 16,1 % 1,11 % 8,25 % 14,71 % 32,8 % 3,25 % 8,79 % 22,65 % 16]
%  *Univariate> let ffrac x = (1+(1%2)*x+(1%3)*x^2)/(2+(2%3)*x)
%  *Univariate> take 10 $ map ffrac [0..]
%  [1 % 2,11 % 16,1 % 1,11 % 8,25 % 14,71 % 32,8 % 3,25 % 8,79 % 22,65 % 16]  
%\end{verbatim}
%Simply taking numerator and denominator polynomials.
%
%The following \texttt{canonicalizer} reduces the tuple-rep of rational function in canonical form, i.e., the coefficient of the lowest degree term of the denominator to be 1\footnote{
%Here our data point start from 0, i.e., the output data is given by \texttt{map f [0..]}, 0 is not singular, i.e., the denominator should have constant term and that means non empty.
%Therefore, the function firstNonzero is actually \texttt{head}.
%}.
%\begin{verbatim}
%> canonicalize :: (Integral a) => 
%>   ([Ratio a],[Ratio a]) -> ([Ratio a],[Ratio a])
%> canonicalize rat@(ns,ds)
%>   | dMin == 1 = rat
%>   | otherwise = (map (/dMin) ns, map (/dMin) ds)
%>   where
%>     dMin = firstNonzero ds
%>     firstNonzero [a] = a -- head
%>     firstNonzero (a:as)
%>       | a /= 0 = a
%>       | otherwise = firstNonzero as
%
%  *Univariate> canonicalize ([1,1%2,1%3],[2,2%3])
%  ([1 % 2,1 % 4,1 % 6],[1 % 1,1 % 3])
%  *Univariate> canonicalize ([1,1%2,1%3],[0,0,2,2%3])
%  ([1 % 2,1 % 4,1 % 6],[0 % 1,0 % 1,1 % 1,1 % 3])
%  *Univariate> canonicalize ([1,1%2,1%3],[0,0,0,2%3])
%  ([3 % 2,3 % 4,1 % 2],[0 % 1,0 % 1,0 % 1,1 % 1])
%\end{verbatim}
%
%What we need is a translator from Thiele coefficients to this tuple-rep.
%Since the list of Thiele coefficients is finite, we can naturally think recursively.
%
%Before we go to a general case, consider
%\begin{eqnarray}
%f(x) := 1 + \cfrac{x}{2+\cfrac{x-1}{3+\cfrac{x-2}{4}}} 
%\end{eqnarray}
%When we simplify this expression, we should start from the bottom:
%\begin{eqnarray}
%f(x) &=& 1 + \cfrac{x}{2+\cfrac{x-1}{\cfrac{4*3+x-2}{4}}} \\
%&=& 1 + \cfrac{x}{2+\cfrac{x-1}{\cfrac{x+10}{4}}} \\
%&=& 1 + \cfrac{x}{\cfrac{2*(x+10) +4*(x-1)}{x+10}} \\
%&=& 1 + \cfrac{x}{\cfrac{6x+16}{x+10}} \\
%&=& \frac{1*(6x+16) + x*(x+10)}{6x+16} \\
%&=& \frac{x^2+16x+16}{6x+16}
%\end{eqnarray}
%Finally, if we need, we take its canonical form:
%\begin{eqnarray}
%f(x) = \frac{1+ x+ \frac{1}{16}x^2}{1+ \frac{3}{8} x}
%\end{eqnarray}
%
%In general, we have the following Thiele representation:
%\begin{eqnarray}
%a_0 + \cfrac{z}{a_1 + \cfrac{z-1}{a_2 + \cfrac{z- 2}{ \cfrac{\vdots}{a_{n} + \cfrac{z-n}{a_{n+1}}}}}}
%\end{eqnarray}
%The base case should be
%\begin{eqnarray}
%a_{n}+ \frac{z-n}{a_{n+1}} &=& \frac{a_{n+1}* a_{n}-n + z }{a_{n+1}} 
%\end{eqnarray}
%and induction step $0 \leq r \leq n$ should be
%\begin{eqnarray}
%a_{r}(z)
%&=&a_{r}+ \frac{z-r}{a_{r+1}(z)} \\
%&=& \frac{a_{r}a_{r+1}(z)+ z -r}{a_{r+1}(z)} \\
%&=& \frac{a_{r}*\texttt{num}\left(a_{r+1}(z) \right)+ \texttt{den}\left(a_{r+1}(z) \right) * \left(z -r\right)}{\texttt{num}\left(a_{r+1}(z) \right)} 
%\end{eqnarray}
%where
%\begin{eqnarray}
%a_{r+1}(z) = \frac{\texttt{num}\left(a_{r+1}(z) \right)}{\texttt{den}\left(a_{r+1}(z) \right)}
%\end{eqnarray}
%is a canonical representation of $a_{n+1}(z)$\footnote{
%Not necessary being a canonical representation, it suffices to express $a_{n+1}(z)$ in a polynomial over polynomial form, that is, two lists in Haskell.
%}.
%
%Thus, the implementation is the followings.
%\begin{verbatim}
%> thiele2coef :: (Integral a) => 
%>   [Ratio a] -> ([Ratio a],[Ratio a])
%> thiele2coef as = canonicalize $ t2r as 0
%>   where
%>     t2r [an,an'] n = ([an*an'-n,1],[an'])
%>     t2r (a:as)   n = ((a .* num) + ([-n,1] * den), num)
%>       where
%>         (num, den) = t2r as (n+1)\end{verbatim}
%
%From the first example,
%\begin{verbatim}
%  *Univariate> let func x = (x^2+16*x+16)%(6*x+16)
%  *Univariate> let funcList = map func [0..]
%  *Univariate> tDegree funcList 
%  3
%  *Univariate> take 5 funcList 
%  [1 % 1,3 % 2,13 % 7,73 % 34,12 % 5]
%  *Univariate> let aFunc = thieleC funcList 
%  *Univariate> aFunc
%  [1 % 1,2 % 1,3 % 1,4 % 1]
%  *Univariate> thiele2coef aFunc
%  ([1 % 1,1 % 1,1 % 16],[1 % 1,3 % 8])
%\end{verbatim}
%
%From the other example, equation (3.26) of ref.\ref{Tiziano},
%\begin{verbatim}
%  *Univariate> let h t = (3+6*t+18*t^2)%(1+2*t+20*t^2)
%  *Univariate> let hs = map h [0..]
%  *Univariate> take 5 hs
%  [3 % 1,27 % 23,87 % 85,183 % 187,45 % 47]
%  *Univariate> let th x = thiele2ratf as x
%  *Univariate> map th [0..5]
%  [3 % 1,27 % 23,87 % 85,183 % 187,45 % 47,69 % 73]
%  *Univariate> as
%  [3 % 1,(-23) % 42,(-28) % 13,767 % 14,7 % 130]
%  *Univariate> thiele2coef as
%  ([3 % 1,6 % 1,18 % 1],[1 % 1,2 % 1,20 % 1])
%\end{verbatim}
%
%\subsection{\texttt{list2rat}: from output list to canonical coefficients}
%Finally, we get
%\begin{verbatim}
%> list2rat :: (Integral a) => [Ratio a] -> ([Ratio a], [Ratio a])
%> list2rat = thiele2Coef . thieleC
%\end{verbatim}
%as the reconstruction function from the output sequence.
%\begin{verbatim}
%  *Univariate> let h t = (3+6*t+18*t^2)%(1+2*t+20*t^2)
%  *Univariate> list2rat $ map h [0..]
%  ([3 % 1,6 % 1,18 % 1],[1 % 1,2 % 1,20 % 1])
%\end{verbatim}

%\section{Multivariate polynomials}
%From now on, we will use only the following functions from univariate cases.
%\begin{verbatim}
%Multivariate.lhs
%
%> module Multivariate 
%>   where
%
%> import Data.Ratio
%> import Univariate 
%>   ( degree, list2pol
%>   , thiele2ratf, lists2ratf, thiele2coef, lists2rat
%>   )
%\end{verbatim}
%
%\subsection{Foldings as recursive applications}
%Consider an arbitrary multivariate polynomial
%\begin{eqnarray}
%f(z_1,\cdots, z_n) \in \mathbb{K}[z_1,\cdots, z_n].
%\end{eqnarray}
%First, fix all the variable but 1st and apply the univariate Newton's reconstruction:
%\begin{eqnarray}
%f(z_1, z_2, \cdots, z_n) = \sum_{r=0}^R a_r (z_2,\cdots, z_n) \prod_{i=0}^{r-1}(z_1 - y_i)
%\end{eqnarray}
%Recursively, pick up one "coefficient" and apply the univariate Newton's reconstruction on $z_2$:
%\begin{eqnarray}
%a_r(z_2, \cdots, z_n) = \sum_{s=0}^{S} b_s (z_3,\cdots, z_n) \prod_{j=0}^{s-1}(z_2 - x_j)
%\end{eqnarray}
%The terminate cotndition should be the univariate case.
%
%\subsection{Experiments, 2 variables case}
%Let us take a polynomial from the denominator in eq.(3.23) of ref.\ref{Tiziano}.
%\begin{eqnarray}
%f(z_1,z_2) = 3 + 2z_1 + 4z_2 + 7z_1^2 + 5z_1z_2 + 6z_2^2
%\end{eqnarray}
%In Haskell, first, fix $z_2=0,1,2$ and identify $f(z_1, 0), f(z_1,1), f(z_1,2)$ as our univariate polynomials.
%\begin{verbatim}
%  *Multivariate> let f z1 z2 = 3+2*z1+4*z2+7*z1^2+5*z1*z2+6*z2^2
%  *Multivariate> let fs z = map (`f` z) [0..]
%  *Multivariate> let llst = map fs [0,1,2]
%  *Multivariate> map degree llst
%  [2,2,2]
%\end{verbatim}
%Fine, so the canonical form can be
%\begin{eqnarray}
%f(z_1, z) = c_0(z) + c_1(z)z_1 + c_2(z) z_1^2.
%\end{eqnarray}
%Now our new target is three univariate polynomials $c_0(z), c_1(z), c_2(z)$.
%\begin{verbatim}
%  *Multivariate> list2pol $ take 10 $ fs 0
%  [3 % 1,2 % 1,7 % 1]
%  *Multivariate> list2pol $ take 10 $ fs 1
%  [13 % 1,7 % 1,7 % 1]
%  *Multivariate> list2pol $ take 10 $ fs 2
%  [35 % 1,12 % 1,7 % 1]
%\end{verbatim}
%That is
%\begin{eqnarray}
%f(z,0) &=& 3+ 2z+7z^2 \\
%f(z,1) &=& 13 + 7z + 7z^2 \\
%f(z,2) &=& 35 + 12z + 7z^2.
%\end{eqnarray}
%From these observation, we can determine $c_2(z)$, since it already a constant sequence.
%\begin{eqnarray}
%c_2(z) = 7
%\end{eqnarray}
%Consider $c_1(z)$, the sequence is now enough to determine $c_1(z)$:
%\begin{verbatim}
%  *Multivariate> degree [2,7,12]
%  1
%  *Multivariate> list2pol [2,7,12]
%  [2 % 1,5 % 1]
%\end{verbatim}
%i.e.,
%\begin{eqnarray}
%c_1(z) = 2 + 5z.
%\end{eqnarray}
%However, for $c_1(z)$
%\begin{verbatim}
%  *Multivariate> degree [3, 13, 35]
%  *** Exception: difLists: lack of data, or not a polynomial
%  CallStack (from HasCallStack):
%    error, called at ./Univariate.lhs:61:19 in main:Univariate
%\end{verbatim}
%so we need more numbers.
%Let us try one more:
%\begin{verbatim}
%  *Multivariate> list2pol $ take 10 $ map (`f` 3) [0..]
%  [69 % 1,17 % 1,7 % 1]
%  *Multivariate> degree [3, 13, 35, 69]
%  2
%  *Multivariate> list2pol [3,13,35,69]
%  [3 % 1,4 % 1,6 % 1]
%\end{verbatim}
%Thus we have
%\begin{eqnarray}
%c_0(z) = 3+4z+6z^2
%\end{eqnarray}
%and these fully determine our polynomial:
%\begin{eqnarray}
%f(z_1, z_2) = (3+4z_2+6z_2^2) + (2 + 5z_2)z_1 + 7z_1^2.
%\end{eqnarray}
%
%As another experiment, take the denominator.
%\begin{verbatim}
%  *Multivariate> let g x y = 1+7*x + 8*y + 10*x^2 + x*y+9*y^2
%  *Multivariate> let gs x = map (g x) [0..]
%  *Multivariate> map degree $ map gs [0..3] 
%  [2,2,2,2]
%\end{verbatim}
%So the canonical form should be
%\begin{eqnarray}
%g(x,y) = c_0(x) + c_1(x)y + c_2(x)y^2
%\end{eqnarray}
%Let us look at these coefficient polynomial:
%\begin{verbatim}
%  *Multivariate> list2pol $ take 10 $ gs 0
%  [1 % 1,8 % 1,9 % 1]
%  *Multivariate> list2pol $ take 10 $ gs 1
%  [18 % 1,9 % 1,9 % 1]
%  *Multivariate> list2pol $ take 10 $ gs 2
%  [55 % 1,10 % 1,9 % 1]
%  *Multivariate> list2pol $ take 10 $ gs 3
%  [112 % 1,11 % 1,9 % 1]
%\end{verbatim}
%So we get
%\begin{eqnarray}
%c_2(x) = 9
%\end{eqnarray}
%and 
%\begin{verbatim}  
%  *Multivariate> map (list2pol . (take 10) . gs) [0..4] 
%  [[1 % 1,8 % 1,9 % 1]
%  ,[18 % 1,9 % 1,9 % 1]
%  ,[55 % 1,10 % 1,9 % 1]
%  ,[112 % 1,11 % 1,9 % 1]
%  ,[189 % 1,12 % 1,9 % 1]
%  ]
%  *Multivariate> map head it
%  [1 % 1,18 % 1,55 % 1,112 % 1,189 % 1]
%  *Multivariate> list2pol it
%  [1 % 1,7 % 1,10 % 1]
%  *Multivariate> list2pol $ map (head . list2pol . (take 10) . gs) [0..4] 
%  [1 % 1,7 % 1,10 % 1]
%\end{verbatim}
%Using index operator \texttt{(!!)},
%\begin{verbatim}
%  *Multivariate> list2pol $ map ((!! 0) . list2pol . (take 10) . gs) [0..4] 
%  [1 % 1,7 % 1,10 % 1]
%  *Multivariate> list2pol $ map ((!! 1) . list2pol . (take 10) . gs) [0..4] 
%  [8 % 1,1 % 1]
%  *Multivariate> list2pol $ map ((!! 2) . list2pol . (take 10) . gs) [0..4] 
%  [9 % 1]
%\end{verbatim}
%Finally we get
%\begin{eqnarray}
%c_0(x) = 1 + 7x+10x^2, c_1(x) = 8+x, \left( c_2(x) = 9, \right)
%\end{eqnarray}
%and
%\begin{eqnarray}
%g(x,y) = (1+7x+10x^2) + (8+x)y + 9y^2
%\end{eqnarray}
%
%\subsection{Haskell implementation, 2 variables case}
%Let us assume that we are given a "table" of the values of a 2-variate function.
%We represent this table as a list of lists.
%\begin{verbatim}
%  *Multivariate> let f z1 z2 = 3+2*z1+4*z2+7*z1^2+5*z1*z2+6*z2^2
%  *Multivariate> [[f x y | y <- [0..9]] | x <- [0..9]]
%  [[3,13,35,69,115,173,243,325,419,525]
%  ,[12,27,54,93,144,207,282,369,468,579]
%  ,[35,55,87,131,187,255,335,427,531,647]
%  ,[72,97,134,183,244,317,402,499,608,729]
%  ,[123,153,195,249,315,393,483,585,699,825]
%  ,[188,223,270,329,400,483,578,685,804,935]
%  ,[267,307,359,423,499,587,687,799,923,1059]
%  ,[360,405,462,531,612,705,810,927,1056,1197]
%  ,[467,517,579,653,739,837,947,1069,1203,1349]
%  ,[588,643,710,789,880,983,1098,1225,1364,1515]
%  ]
%
%> tablize :: (Enum t1, Num t1) => (t1 -> t1 -> t) -> Int -> [[t]]
%> tablize f n = [[f x y | y <- range] | x <- range]
%>   where
%>     range = take n [0..]
%\end{verbatim}
%So, this "table" is like
%\begin{eqnarray}
%\left(\begin{array}{ccc} f_{0,0} & f_{0,1} & \cdots \\ f_{1,0} & f_{1,1} & \cdots \\f_{2,0} & f_{2,1} & \cdots \\ \vdots && \ddots \end{array}\right)
%\end{eqnarray}
%Then we can apply the univariate technique.
%\begin{verbatim}
%  *Multivariate> let fTable = tablize f 10
%  *Multivariate> map list2pol fTable 
%  [[3 % 1,4 % 1,6 % 1]
%  ,[12 % 1,9 % 1,6 % 1]
%  ,[35 % 1,14 % 1,6 % 1]
%  ,[72 % 1,19 % 1,6 % 1]
%  ,[123 % 1,24 % 1,6 % 1]
%  ,[188 % 1,29 % 1,6 % 1]
%  ,[267 % 1,34 % 1,6 % 1]
%  ,[360 % 1,39 % 1,6 % 1]
%  ,[467 % 1,44 % 1,6 % 1]
%  ,[588 % 1,49 % 1,6 % 1]
%  ]
%\end{verbatim}
%Now we need to see the behavior of each coefficient, so take the "transpose" of it:
%\begin{verbatim}
%> wellOrd :: [[a]] -> [[a]]
%> wellOrd xss 
%>   | null (head xss) = [] 
%>   | otherwise       = map head xss : wellOrd (map tail xss)
%
%  *Multivariate> let f z1 z2 = 3+2*z1+4*z2+7*z1^2+5*z1*z2+6*z2^2
%  *Multivariate> let fTable = tablize f 10
%  *Multivariate> map list2pol fTable 
%  [[3 % 1,4 % 1,6 % 1]
%  ,[12 % 1,9 % 1,6 % 1]
%  ,[35 % 1,14 % 1,6 % 1]
%  ,[72 % 1,19 % 1,6 % 1]
%  ,[123 % 1,24 % 1,6 % 1]
%  ,[188 % 1,29 % 1,6 % 1]
%  ,[267 % 1,34 % 1,6 % 1]
%  ,[360 % 1,39 % 1,6 % 1]
%  ,[467 % 1,44 % 1,6 % 1]
%  ,[588 % 1,49 % 1,6 % 1]
%  ]
%  *Multivariate> wellOrd it
%  [[3 % 1,12 % 1,35 % 1,72 % 1,123 % 1,188 % 1,267 % 1,360 % 1,467 % 1,588 % 1]
%  ,[4 % 1,9 % 1,14 % 1,19 % 1,24 % 1,29 % 1,34 % 1,39 % 1,44 % 1,49 % 1]
%  ,[6 % 1,6 % 1,6 % 1,6 % 1,6 % 1,6 % 1,6 % 1,6 % 1,6 % 1,6 % 1]
%  ]
%  *Multivariate> map list2pol it
%  [[3 % 1,2 % 1,7 % 1]
%  ,[4 % 1,5 % 1]
%  ,[6 % 1]]
%\end{verbatim}
%Therefore, the whole procedure becomes
%\begin{verbatim}  
%> table2pol :: [[Ratio Integer]] -> [[Ratio Integer]]
%> table2pol = map list2pol . wellOrd . map list2pol
%
%  *Multivariate> let g x y = 1+7*x + 8*y + 10*x^2 + x*y+9*y^2
%  *Multivariate> table2pol $ tablize g 5
%  [[1 % 1,7 % 1,10 % 1],[8 % 1,1 % 1],[9 % 1]]
%\end{verbatim}

\section{Multivariate rational functions}
\subsection{The canonical normalization}
Our target is a pair of coefficients $(\{ n_\alpha\}_\alpha, \{ d_\beta\}_\beta)$ in
\begin{eqnarray}
\frac{\sum_\alpha n_\alpha z^\alpha}{\sum_\beta d_\beta z^\beta}
\end{eqnarray}
A canonical choice is
\begin{eqnarray}
d_0 = d_{(0,\cdots,0)} = 1.
\end{eqnarray}
Accidentally we might face $d_0 = 0$, but we can shift our function and make
\begin{eqnarray}
d'_0 = d_{s} \neq 0.
\end{eqnarray}

\subsection{An auxiliary $t$}
Introducing an auxiliary variable $t$, let us define
\begin{eqnarray}
h(z,t) := f(tz_1, \cdots, tz_n),
\end{eqnarray}
and reconstruct $h(t,z)$ as a univariate rational function of $t$:
\begin{eqnarray}
h(z, t) = \frac{\sum_{r=0}^R p_r(z) t^r}{1+ \sum_{r'=1}^{R'} q_{r'}(z) t^{r'}}
\end{eqnarray}
where
\begin{eqnarray}
p_r(z) &=& \sum_{|\alpha| = r} n_\alpha z^\alpha \\
q_{r'}(z) &=& \sum_{|\beta| = r'} n_\beta z^\beta
\end{eqnarray}
are homogeneous polynomials.

Thus, what we shall do is the (homogeneous) polynomial reconstructions of $\left. p_r(z) \right|_{0 \leq r \leq R}, \left. q_{r'} \right|_{1 \leq r' \leq R'}$.

\subsubsection{A simplification}
Since our new targets are homogeneous polynomials, we can consider, say,
\begin{eqnarray}
p_r(1, z_2, \cdots, z_n)
\end{eqnarray}
instead of $p_r(z_1, z_2, \cdots, z_n)$, reconstruct it using multivariate Newton's method, and homogenize with $z_1$.

%\subsection{Experiments, 2 variables case}
%Consider the equation (3.23) in ref.\ref{Tiziano}.
%\begin{verbatim}
%  *Multivariate> let f x y = (3+2*x+4*y+7*x^2+5*x*y+6*y^2)
%                              % (1+7*x+8*y+10*x^2+x*y+9*y^2)
%  *Multivariate> :t f
%  f :: Integral a => a -> a -> Ratio a
%  *Multivariate> let h x y t = f (t*x) (t*y)
%  *Multivariate> let hs x y = map (h x y) [0..]
%  *Multivariate> take 5 $ hs 0 0
%  [3 % 1,3 % 1,3 % 1,3 % 1,3 % 1]
%  *Multivariate> take 5 $ hs 0 1
%  [3 % 1,13 % 18,35 % 53,69 % 106,115 % 177]
%  *Multivariate> take 5 $ hs 1 0
%  [3 % 1,2 % 3,7 % 11,9 % 14,41 % 63]
%  *Multivariate> take 5 $ hs 1 1
%  [3 % 1,3 % 4,29 % 37,183 % 226,105 % 127]
%\end{verbatim}
%Here we have introduced the auxiliary $t$ as third argument.
%
%We take $(x,y) = (1,0), (1,1), (1,2), (1,3)$ and reconstruct them\footnote{Eq.(3.26) in ref.\ref{Tiziano} is different from our reconstruction.
%}.
%\begin{verbatim}
%  *Multivariate> lists2rat $ hs 1 0
%  ([3 % 1,2 % 1,7 % 1],[1 % 1,7 % 1,10 % 1])
%  *Multivariate> lists2rat $ hs 1 1
%  ([3 % 1,6 % 1,18 % 1],[1 % 1,15 % 1,20 % 1])
%  *Multivariate> lists2rat $ hs 1 2
%  ([3 % 1,10 % 1,41 % 1],[1 % 1,23 % 1,48 % 1])
%  *Multivariate> lists2rat $ hs 1 3
%  ([3 % 1,14 % 1,76 % 1],[1 % 1,31 % 1,94 % 1])
%\end{verbatim}
%So we have
%\begin{eqnarray}
%\label{tizianoExample1}
%h(1,0,t) &=& \frac{3+2t+7t^2}{1+7t+10t^2} \\
%\label{tizianoExample2}
%h(1,1,t) &=& \frac{3+6t+18t^2}{1+15t+20t^2} \\
%\label{tizianoExample3}
%h(1,2,t) &=& \frac{3+10t+41t^2}{1+23t+48t^2} \\
%\label{tizianoExample4}
%h(1,3,t) &=& \frac{3+14t+76t^2}{1+31t+94t^2}
%\end{eqnarray}
%Our next targets are the coefficients as polynomials in $y$ \footnote{
%In our example, we take $x=1$ fixed and reproduce $x$-dependence using homogenization
%}.
%
%Let us consider numerator first.
%This \texttt{list} is Haskell representation for eq.(\ref{tizianoExample1}), eq.(\ref{tizianoExample2}), eq.(\ref{tizianoExample3}) and eq.(\ref{tizianoExample4}).
%\begin{verbatim}
%  *Multivariate> let list = map (lists2rat . (hs 1)) [0..4]
%  *Multivariate> let numf = map fst list
%  *Multivariate> list
%  [([3 % 1,2 % 1,7 % 1],[1 % 1,7 % 1,10 % 1])
%  ,([3 % 1,6 % 1,18 % 1],[1 % 1,15 % 1,20 % 1])
%  ,([3 % 1,10 % 1,41 % 1],[1 % 1,23 % 1,48 % 1])
%  ,([3 % 1,14 % 1,76 % 1],[1 % 1,31 % 1,94 % 1])
%  ,([3 % 1,18 % 1,123 % 1],[1 % 1,39 % 1,158 % 1])
%  ]
%  *Multivariate> numf
%  [[3 % 1,2 % 1,7 % 1]
%  ,[3 % 1,6 % 1,18 % 1]
%  ,[3 % 1,10 % 1,41 % 1]
%  ,[3 % 1,14 % 1,76 % 1]
%  ,[3 % 1,18 % 1,123 % 1]
%  ]
%\end{verbatim}
%From this information, we reconstruct each polynomials
%\begin{verbatim}
%  *Multivariate> list2pol $ map head numf
%  [3 % 1]
%  *Multivariate> list2pol $ map (head . tail) numf
%  [2 % 1,4 % 1]
%  *Multivariate> list2pol $ map last numf
%  [7 % 1,5 % 1,6 % 1]
%\end{verbatim}
%that is we have $3, 2+4y, 7+5y+6y^2$ as results.
%Similarly,
%\begin{verbatim}
%  *Multivariate> let denf = map snd list
%  *Multivariate> denf
%  [[1 % 1,7 % 1,10 % 1]
%  ,[1 % 1,15 % 1,20 % 1]
%  ,[1 % 1,23 % 1,48 % 1]
%  ,[1 % 1,31 % 1,94 % 1]
%  ,[1 % 1,39 % 1,158 % 1]
%  ]
%  *Multivariate> list2pol $ map head denf
%  [1 % 1]
%  *Multivariate> list2pol $ map (head . tail) denf
%  [7 % 1,8 % 1]
%  *Multivariate> list2pol $ map last denf
%  [10 % 1,1 % 1,9 % 1]
%\end{verbatim}
%So we get
%\begin{eqnarray}
%h(1,y,t) = \frac{3 + (2+4y)t + (7+5y+6y^2)t^2}{1 + (7+8y)t + (10+y+9y^2)t^2}
%\end{eqnarray}
%Finally, we use the homogeneous property for each powers:
%\begin{eqnarray}
%h(x,y,t) = \frac{3 + (2x+4y)t + (7x^2+5xy+6y^2)t^2}{1 + (7x+8y)t + (10x^2+xy+9y^2)t^2}
%\end{eqnarray}
%Putting $t=1$, we get
%\begin{eqnarray}
%f(x,y) &=& h(x,y,1) \\
%&=& \frac{3 + (2x+4y) + (7x^2+5xy+6y^2)}{1 + (7x+8y) + (10x^2+xy+9y^2)}
%\end{eqnarray}
%
%\subsection{Haskell implementation, 2 variables case}
%Assume we have a "table" of data:
%\begin{verbatim}
%  *Multivariate> let h x y = (3+2*x+4*y+7*x^2+5*x*y+6*y^2) % (1+7*x+8*y+10*x^2+x*y+9*y^2)
%  *Multivariate> let auxh x y t = h (t*x) (t*y)
%  *Multivariate> let h x y = (3+2*x+4*y+7*x^2+5*x*y+6*y^2)% (1+7*x+8*y+10*x^2+x*y+9*y^2)
%  *Multivariate> let auxh x y t = h (t*x) (t*y)
%
%Using the homogenious property, we just take x=1:
%
%  *Multivariate> let auxhs = [map (auxh 1 y) [0..5] | y <- [0..5]]
%  *Multivariate> auxhs
%  [[3 % 1,2 % 3,7 % 11,9 % 14,41 % 63,94 % 143]
%  ,[3 % 1,3 % 4,29 % 37,183 % 226,105 % 127,161 % 192]
%  ,[3 % 1,3 % 4,187 % 239,201 % 251,233 % 287,77 % 94]
%  ,[3 % 1,31 % 42,335 % 439,729 % 940,425 % 543,1973 % 2506]
%  ,[3 % 1,8 % 11,59 % 79,291 % 385,681 % 895,528 % 691]
%  ,[3 % 1,23 % 32,155 % 211,1707 % 2302,1001 % 1343,4663 % 6236]
%  ]
%\end{verbatim}
%Now, each list can be seen as a univariate rational function:  
%\begin{verbatim}  
%  *Multivariate> map list2rat auxhs
%  [([3 % 1,2 % 1,7 % 1],[1 % 1,7 % 1,10 % 1])
%  ,([3 % 1,6 % 1,18 % 1],[1 % 1,15 % 1,20 % 1])
%  ,([3 % 1,10 % 1,41 % 1],[1 % 1,23 % 1,48 % 1])
%  ,([3 % 1,14 % 1,76 % 1],[1 % 1,31 % 1,94 % 1])
%  ,([3 % 1,18 % 1,123 % 1],[1 % 1,39 % 1,158 % 1])
%  ,([3 % 1,22 % 1,182 % 1],[1 % 1,47 % 1,240 % 1])
%  ]
%  *Multivariate> map fst it
%  [[3 % 1,2 % 1,7 % 1]
%  ,[3 % 1,6 % 1,18 % 1]
%  ,[3 % 1,10 % 1,41 % 1]
%  ,[3 % 1,14 % 1,76 % 1]
%  ,[3 % 1,18 % 1,123 % 1]
%  ,[3 % 1,22 % 1,182 % 1]
%  ]
%\end{verbatim}
%We need to see the behavior of each coefficients:
%\begin{verbatim}  
%  *Multivariate> wellOrd it
%  [[3 % 1,3 % 1,3 % 1,3 % 1,3 % 1,3 % 1]
%  ,[2 % 1,6 % 1,10 % 1,14 % 1,18 % 1,22 % 1]
%  ,[7 % 1,18 % 1,41 % 1,76 % 1,123 % 1,182 % 1]
%  ]
%  *Multivariate> map list2pol it
%  [[3 % 1],[2 % 1,4 % 1],[7 % 1,5 % 1,6 % 1]]
%\end{verbatim}  
%So, the numerator is given by
%\begin{verbatim}  
%  *Multivariate> map list2pol . wellOrd . map (fst . list2rat) $ auxhs
%  [[3 % 1],[2 % 1,4 % 1],[7 % 1,5 % 1,6 % 1]]
%\end{verbatim}    
%and the denominator is
%\begin{verbatim}  
%  *Multivariate> map list2pol . wellOrd . map (snd . list2rat) $ auxhs
%  [[1 % 1],[7 % 1,8 % 1],[10 % 1,1 % 1,9 % 1]]
%\end{verbatim}
%Thus, we finally get the following function
%\begin{verbatim}
%> table2ratf table = (t2r fst table, t2r snd table)
%>   where
%>     t2r third = map list2pol . wellOrd . map (third . list2rat)
%  
%  *Multivariate> table2ratf auxhs
%  ([[3 % 1],[2 % 1,4 % 1],[7 % 1,5 % 1,6 % 1]],[[1 % 1],[7 % 1,8 % 1],[10 % 1,1 % 1,9 % 1]])
%\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Functional reconstruction over finite fields}
\section{Univariate polynomials}
\subsection{Special data types}
We introduce few new data types.
\begin{verbatim}
> type Q = Ratio Int   -- Rational fields
> type Graph = [(Q,Q)] -- [(x, f x) | x <- someFinieRange]

> -- using record syntax
> data PDiff 
>   = PDiff { points    :: (Int, Int) -- end points
>           , value     :: Int        -- Zp value
>           , basePrime :: Int
>           }
>   deriving (Show, Read)
\end{verbatim}

To apply difference analysis, we introduce a higher order function.
\begin{verbatim}
> -- f [a,b,c ..] -> [(f a b), (f b c) ..]
> -- pair wise application
> map' :: (a -> a -> b) -> [a] -> [b]
> map' f as = zipWith f as (tail as)
\end{verbatim}

\subsection{Implementations}
\begin{verbatim}
> -- To select Z_p valid inputs.
> sample :: Int   -- prime
>        -> Graph -- increasing input
>        -> Graph 
> sample p = filter ((< (fromIntegral p)) . fst)
>
> -- To eliminate (1%p) type "fake" infinity.
> -- After eliminating these, we can freely use 'modp', primed version.
> check :: Int   -- prime
>       -> Graph 
>       -> Graph -- safe data sets
> check p = filter (not . isDanger p)
>   where
>     isDanger -- To detect (1%p) type infinity.
>       :: Int -- prime 
>       -> (Q,Q) -> Bool
>     isDanger p (_, fx) = (d `rem` p) == 0
>       where 
>         d = denominator fx
> 
> project :: Int -> (Q,Q) -> (Int, Int)
> project p (x, fx) -- for simplicity
>   | denominator x == 1 = (numerator x, fx `modp'` p)
>   | otherwise          = error "project: integer input?"
>
> -- From Graph to Zp (safe) values.
> onZp 
>   :: Int                -- base prime
>   -> Graph
>   -> [(Int, Int)] -- in-out on Zp value 
> onZp p = map (project p) . check p . sample p
>
> toPDiff 
>   :: Int        -- prime
>   -> (Int, Int) -- in and out mod p 
>   -> PDiff
> toPDiff p (x,fx) = PDiff (x,x) fx p
>

\end{verbatim}

\begin{verbatim}
> newtonTriangleZp :: [PDiff] -> [[PDiff]]
> newtonTriangleZp fs
>   | length fs < 3 = []
>   | otherwise     = helper [sf3] (drop 3 fs)
>   where
>     sf3 = reverse . take 3 $ fs -- [[f2,f1,f0]]
>     helper fss [] = error "newtonTriangleZp: need more evaluation" 
>     helper fss (f:fs)
>       | isConsts 3 . last $ fss = fss
>       | otherwise               = helper (add1 f fss) fs
>
> isConsts 
>   :: Int -- 3times match
>   -> [PDiff] -> Bool
> isConsts n ds
>   | length ds < n = False    
> -- isConsts n ds     = all (==l) $ take (n-1) ls
>   | otherwise     = all (==l) $ take (n-1) ls
>   where 
>     (l:ls) = map value ds
>
> -- backward, each [PDiff] is decreasing inputs (i.e., reversed)
> add1 :: PDiff -> [[PDiff]] -> [[PDiff]]
> add1 f [gs] = fgs : [zipWith bdiffStep fgs gs] -- singleton
>   where 
>     fgs = f:gs
> add1 f (gg@(g:gs) : hhs) -- gg is reversed order
>             = (f:gg) : add1 fg hhs
>   where
>     fg = bdiffStep f g
>
> -- backward
> bdiffStep :: PDiff -> PDiff -> PDiff
> bdiffStep (PDiff (y,y') g q) (PDiff (x,x') f p)
>   | p == q    = PDiff (x,y') finiteDiff p
>   | otherwise = error "bdiffStep: different primes?"
>   where
>     finiteDiff = ((fg % xy') `modp'` p)
>     xy' = (x - y' `mod` p)
>     fg = ((f-g) `mod` p) 
>
> graph2Zp :: Int -> Graph -> [(Int, Int)]
> graph2Zp p = onZp p . check p . sample p 
>
> graph2PDiff :: Int -> Graph -> [PDiff]
> graph2PDiff p = map (toPDiff p) . graph2Zp p
>
> newtonTriangleZp' :: Int -> Graph -> [[PDiff]]
> newtonTriangleZp' p = newtonTriangleZp . graph2PDiff p
> 
> newtonCoeffZp :: Int -> Graph -> [PDiff]
> newtonCoeffZp p = map head . newtonTriangleZp' p

  *GUniFin> let gs = map (\x -> (x,x^2 + (1%2)*x + 1%3)) 
                         [1,2,4,5,9,10,11] :: Graph 
  *GUniFin> newtonCoeffZp 101 gs
  [PDiff {points = (9,9), value = 69, basePrime = 101}
  ,PDiff {points = (5,9), value = 65, basePrime = 101}
  ,PDiff {points = (4,9), value = 1, basePrime = 101}
  ]
  *GUniFin> map (\x -> (Just . value $ x, basePrime x)) it
  [(Just 69,101),(Just 65,101),(Just 1,101)]

We take formally the canonical form on Zp, 
then apply rational "number" reconstruction.

> n2cZp :: [PDiff] -> ([Int], Int)
> n2cZp graph = (helper graph, p)
>   where
>     p = basePrime . head $ graph
>     helper [d]    = [value d]
>     helper (d:ds) = map (`mod` p) $ ([value d] + (z * next)) 
>                                    - (map (`mod` p) (zd .* next))
>       where 
>         zd = fst . points $ d
>         next = helper ds
>
> format :: ([Int],Int) -> [(Maybe Int, Int)]
> format (as,p) = [(return a,p) | a <- as]
  
  *GUniFin> let gs = map (\x -> (x,x^2 + (1%2)*x + 1%3)) 
                         [0,2,3,5,7,8,11] :: Graph 
  *GUniFin> newtonCoeffZp 10007 gs
  [PDiff {points = (7,7), value = 8392, basePrime = 10007}
  ,PDiff {points = (5,7), value = 5016, basePrime = 10007}
  ,PDiff {points = (3,7), value = 1, basePrime = 10007}
  ]
  *GUniFin> n2cZp it
  ([3336,5004,1],10007)
  *GUniFin> format it
  [(Just 3336,10007),(Just 5004,10007),(Just 1,10007)]
  *GUniFin> map guess it
  [Just (1 % 3,10007),Just (1 % 2,10007),Just (1 % 1,10007)]

  *GUniFin> let gs = map (\x -> (x,x^2 + (1%2)*x + 1%3)) 
                         [0,2,3,5,7,8,11] :: Graph 
  *GUniFin> map guess . format . n2cZp . newtonCoeffZp 10007 $ gs
  [Just (1 % 3,10007),Just (1 % 2,10007),Just (1 % 1,10007)]
  *GUniFin> let gs = map (\x -> (x,x^5 + x^2 + (1%2)*x + 1%3)) 
                         [0,2,3,5,7,8,11,13,17,18,19,21,24,28,31,33,34] 
                         :: Graph 
  *GUniFin> map guess . format . n2cZp . newtonCoeffZp 10007 $ gs
  [Just (1 % 3,10007),Just (1 % 2,10007),Just (1 % 1,10007)
  ,Just (0 % 1,10007),Just (0 % 1,10007),Just (1 % 1,10007)
  ] 

> preTrial gs p = format . n2cZp . newtonCoeffZp p $ gs

  *GUniFin> let gs = map (\x -> (x,x^5 + x^2 + (1%2)*x + 1%3)) 
                         [0,2,3,5,7,8,11,13,17,18,19,21,24,28,31,33,34] 
                         :: Graph 
  *GUniFin> map reconstruct . transpose . map (preTrial gs) $ bigPrimes 
  [Just (1 % 3),Just (1 % 2),Just (1 % 1)
  ,Just (0 % 1),Just (0 % 1),Just (1 % 1)
  ]

Here is "a" final version, the univariate polynomial reconstruction 
with finite fields.

> uniPolCoeff :: Graph -> Maybe [(Ratio Int)]
> uniPolCoeff gs
>   = (mapM reconstruct' . transpose . map (preTrial gs)) bigPrimes

  *GUniFin> let gs = map (\x -> (x,x^5 + x^2 + (1%2)*x + 1%3)) 
                         [0,2,3,5,7,8,11,13,17,18,19,21,24,28,31,33,34]
                         :: Graph
  *GUniFin> gs
  [(0 % 1,1 % 3),(2 % 1,112 % 3),(3 % 1,1523 % 6),(5 % 1,18917 % 6)
  ,(7 % 1,101159 % 6),(8 % 1,98509 % 3),(11 % 1,967067 % 6)
  ,(13 % 1,2228813 % 6),(17 % 1,8520929 % 6),(18 % 1,5669704 % 3)
  ,(19 % 1,14858819 % 6),(21 % 1,24507317 % 6),(24 % 1,23889637 % 3)
  ,(28 % 1,51633499 % 3),(31 % 1,171780767 % 6),(33 % 1,234818993 % 6)
  ,(34 % 1,136309792 % 3)
  ]
  *GUniFin> uniPolCoeff gs
  Just [1 % 3,1 % 2,1 % 1,0 % 1,0 % 1,1 % 1]

  *GUniFin> let fs = map (\x -> (x,(3+x+(1%3)*x^9)/(1))) 
                         [1,3..101] :: Graph
  *GUniFin> uniPolCoeff fs
  Just [3 % 1,1 % 1,0 % 1,0 % 1,0 % 1,0 % 1,0 % 1,0 % 1,0 % 1,1 % 3]
  *GUniFin> let fs = map (\x -> (x,(3+x+(1%3)*x^10)/(1))) 
                         [1,3..101] :: Graph
  *GUniFin> uniPolCoeff fs
  *** Exception: newtonBT: need more evaluation
  CallStack (from HasCallStack):
    error, called at GUniFin.lhs:79:23 in main:GUniFin
  *GUniFin> let fs = map (\x -> (x,(3+x+(1%3)*x^10)/(1))) 
                         [1,3..1001] :: Graph
  *GUniFin> uniPolCoeff fs
  *** Exception: newtonBT: need more evaluation
  CallStack (from HasCallStack):
    error, called at GUniFin.lhs:79:23 in main:GUniFin

Rough estimation says, in 64-bits system with sequential inputs,
the upper limit of degree is about 15.
If we use non sequential inputs, this upper limit will go down.
\end{verbatim}

\section{Univariate rational functions}

%
%We choose our new target the first differences, since once we get it, to reconstruct polynomial is an easy task.
%Once we get the first differences of a polynomial, we get the coefficient list by applying \texttt{npol2pol . newtonC} on it.
%
%\subsection{Pre-cook}
%We need a convertor, or function-modular which takes function and prime, and returns a function on $\mathbb{Z}_p$.
%\begin{verbatim}
%> -- Function-modular.
%> fmodp :: Integral c => (a -> Ratio c) -> c -> a -> c
%> f `fmodp` p = (`modp` p) . f
%
%  *FROverZp> let f x = (1%3) + (3%5)*x + (7%6)*x^2
%  *FROverZp> let fs = map f [0..]
%  *FROverZp> take 5 $ map (f `fmodp` 101) [0..]
%  [34,93,87,16,82]
%  *FROverZp> take 5 $ map (`modp` 101) fs
%  [34,93,87,16,82]
%\end{verbatim}
%
%What we can access is the output list of our target polynomial.
%On $\mathbb{Z}_p$, our input is a finite list
%\begin{eqnarray}
%\texttt{[0,1,2 .. (p-1)]}
%\end{eqnarray}
%so as the output list.
%\begin{verbatim}
%> accessibleData :: (Ratio Int -> Ratio Int) -> Int -> [Int]
%> accessibleData f p = take p $ map (f `fmodp` p) [0..]
%> 
%> accessibleData' :: [Ratio Int] -> Int -> [Int]
%> accessibleData' fs p = take p $ map (`modp` p) fs
%\end{verbatim}
%
%\subsection{Difference analysis on $\mathbb{Z}_p$}
%Play the same game over prime field $\mathbb{Z}_p$, i.e., every arithmetic in under $\mod p$.
%
%\begin{verbatim}
%Difference analysis over Z_p
%Every arithmetic should be on Z_p, i.e., (`mod` p).
%
%> difsp :: Integral b => b -> [b] -> [b]
%> difsp p xs = map (`mod` p) (zipWith (-) (tail xs) xs)
%
%  *FROverZp> let f x = (1%3) + (3%5)*x + (7%6)*x^2
%  *FROverZp> take 5 $ accessibleData f 101
%  [34,93,87,16,82]
%  *FROverZp> difsp 101 it
%  [59,95,30,66]
%  *FROverZp> difsp 101 it
%  [36,36,36]
%  *FROverZp> difsp 101 it
%  [0,0]
%\end{verbatim}
%Here what we do is, first to take the differences (\texttt{zipWith (-) (tail xs) xs}) and take modular $p$ for all element (\texttt{map (`mod` p)}).
%Now we can recursively apply this \texttt{difsp} over our data.
%\begin{verbatim}
%> difListsp :: Integral b => b -> [[b]] -> [[b]]
%> difListsp _ [] = []
%> difListsp p xx@(xs:xxs) =
%>   if isConst xs then xx
%>                 else difListsp p $ difsp p xs : xx
%>   where
%>     isConst (i:jj@(j:js)) = all (==i) jj
%>     isConst _ = error "difListsp: "
%
%  *FROverZp> let f x = (1%3) + (3%5)*x + (7%6)*x^2
%  *FROverZp> map head $ difListsp 101 [accessibleData f 101]
%  [36,59,34]
%\end{verbatim}
%
%\subsection{Eager and lazy degree}
%From the above difference analysis on $\mathbb{Z}_p$, we get degree of the polynomial.
%Here we have a combination of two degree functions, one is eager and the other lazy:
%\begin{verbatim}
%Degree, eager and lazy versions
%
%> degreep' p xs = length (difListsp p [xs]) -1
%> degreep'Lazy p xs = helper xs 0
%>   where
%>     helper as@(a:b:c:_) n
%>       | a==b && b==c = n -- two times matching
%>       | otherwise    = helper (difsp p as) (n+1)
%>
%> degreep :: Integral b => b -> [b] -> Int
%> degreep p xs = let l = degreep'Lazy p xs in
%>   degreep' p $ take (l+2) xs
%
%  *FROverZp> let f x = (1%3) + (3%5)*x + (7%6)*x^2
%  *FROverZp> let myDeg p = degreep p $ accessibleData f p
%  *FROverZp> myDeg 101
%  2
%  *FROverZp> myDeg 103
%  2
%  *FROverZp> myDeg 107
%  2
%  *FROverZp> degreep 101 $ accessibleData 
%    (\n -> (1%2)+(2%3)*n+(3%4)*n^2+(6%7)*n^7) 101
%  7
%\end{verbatim}
%Now we can take first differences.
%\begin{verbatim}
%> firstDifsp :: Integral a => a -> [a] -> [a]
%> firstDifsp p xs = reverse $ map head $ difListsp p [xs']
%>   where
%>     xs' = take n xs
%>     n   = 2+ degreep p xs
%
%  *FROverZp> let f x = (1%3) + (3%5)*x + (7%6)*x^2
%  *FROverZp> firstDifsp 101 $ accessibleData f 101
%  [34,59,36]
%  *FROverZp> firstDifsp 101 $ accessibleData 
%    (\n -> (1%2)+(2%3)*n+(3%4)*n^2+(6%7)*n^7) 101
%  [51,66,59,33,29,58,32,78]
%\end{verbatim}
%
%\subsection{Term by term reconstruction}
%The output list of \texttt{firstDifsp} are basically the coefficients of Newton representation on $\mathbb{Z}_p$.
%So we zip it with our base prime $p$ and map these pair over several primes.
%\begin{verbatim}
%> wellOrd :: [[a]] -> [[a]]
%> wellOrd xss 
%>   | null (head xss) = [] 
%>   | otherwise       = map head xss : wellOrd (map tail xss)
%
%  *FROverZp> let f x = (1%3) + (3%5)*x + (7%6)*x^2
%  *FROverZp> let fps p = accessibleData f p
%  *FROverZp> let ourData p = firstDifsp p (fps p)
%  *FROverZp> let fivePrimes = take 5 bigPrimes 
%  *FROverZp> map (\p -> zip (ourData p) (repeat p)) fivePrimes 
%  [[(299158,897473),(867559,897473),(299160,897473)]
%  ,[(299166,897497),(329084,897497),(299168,897497)]
%  ,[(598333,897499),(388918,897499),(598335,897499)]
%  ,[(598345,897517),(29919,897517),(598347,897517)]
%  ,[(299176,897527),(329095,897527),(299178,897527)]
%  ]
%  *FROverZp> wellOrd it
%  [[(299158,897473),(299166,897497),(598333,897499)
%   ,(598345,897517),(299176,897527)]
%  ,[(867559,897473),(329084,897497),(388918,897499)
%   ,(29919,897517),(329095,897527)]
%  ,[(299160,897473),(299168,897497),(598335,897499)
%   ,(598347,897517),(299178,897527)]
%  ]
%  *FROverZp> :t it
%  it :: [[(Int, Int)]]
%\end{verbatim}
%Finally we get the images of first differences over prime fields.
%
%One minor issue is to change the data type, since our tools (say the functions of Chinese Remainder Theorem) use limit-less integer \texttt{Integer}.
%\begin{verbatim}
%> toInteger2 :: (Integral a1, Integral a) => (a, a1) -> (Integer, Integer)
%> toInteger2 (a,b) = (toInteger a, toInteger b)
%\end{verbatim}
%
%Let us take an example:
%\begin{verbatim}
%  *FROverZp> let f x = (895 % 922) + (1080 % 6931)*x + (2323 % 1248)*x^2
%  *FROverZp> let fps p = accessibleData f p
%  *FROverZp> let longList = map (map toInteger2) $ wellOrd $ 
%    map (\p -> zip (firstDifsp p (fps p)) (repeat p)) bigPrimes 
%  *FROverZp> map recCRT' longList 
%  [(895 % 922,805479325081)
%  ,(17448553 % 8649888,722916888780872419)
%  ,(2323 % 624,805479325081)
%  ]
%
%This result is consistent to that of on Q:
%
%  *FROverZp> :l Univariate
%  [1 of 2] Compiling Polynomials      ( Polynomials.hs, interpreted )
%  [2 of 2] Compiling Univariate       ( Univariate.lhs, interpreted )
%  Ok, modules loaded: Univariate, Polynomials.
%  *Univariate> let f x = (895 % 922) + (1080 % 6931)*x + (2323 % 1248)*x^2
%  *Univariate> firstDifs (map f [0..20])
%  [895 % 922,17448553 % 8649888,2323 % 624]
%\end{verbatim}
%
%\subsection{\texttt{list2polZp}: from the output list to coefficient lists}
%Finally we get the function which takes an output list of our unknown univariate polynomial and returns the coefficient.
%\begin{verbatim}
%> list2firstDifZp' fs = 
%>   map recCRT' $ map (map toInteger2) $ wellOrd $ map helper bigPrimes
%>   where helper p = zip (firstDifsp p (accessibleData' fs p)) (repeat p)
%
%  *FROverZp> let f x = (895 % 922) + (1080 % 6931)*x + (2323 % 1248)*x^2
%  *FROverZp> let fs = map f [0..]
%  *FROverZp> list2firstDifZp' fs
%  [(895 % 922,805479325081)
%  ,(17448553 % 8649888,722916888780872419)
%  ,(2323 % 624,805479325081)
%  ]
%  *FROverZp> map fst it
%  [895 % 922,17448553 % 8649888,2323 % 624]
%  *FROverZp> newtonC it
%  [895 % 922,17448553 % 8649888,2323 % 1248]
%  *FROverZp> npol2pol it
%  [895 % 922,1080 % 6931,2323 % 1248]
%
%> list2polZp :: [Ratio Int] -> [Ratio Integer]
%> list2polZp = npol2pol . newtonC . (map fst) . list2firstDifZp'
%\end{verbatim}

\section{TBA Univariate rational functions}


















%%%%%%%%%%

\chapter{Codes}
\section{\texttt{Ffield.lhs}}
\lstinputlisting[caption=Ffield.lhs,label=Ffield]{Ffield.lhs}

\section{\texttt{Polynomials.hs}}
\lstinputlisting[caption=Polynomials.hs,label=Polynomials]{Polynomials.hs}

\section{\texttt{Univariate.lhs}}
\lstinputlisting[caption=Univariate.lhs,label=Univariate]{Univariate.lhs}

\section{\texttt{Multivariate.lhs}}
\lstinputlisting[caption=Multivariate.lhs,label=Multivariate]{Multivariate.lhs}

\section{\texttt{GUniFin.lhs}}
\lstinputlisting[caption=GUniFin.lhs,label=GUniFin]{GUniFin.lhs}

\section{\texttt{GMulFin.lhs}}
\lstinputlisting[caption=GMulFin.lhs,label=GMulFin]{GMulFin.lhs}




\end{document}