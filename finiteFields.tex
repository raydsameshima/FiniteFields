\documentclass[11pt]{book}
\usepackage{amsmath,amssymb}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage[all]{xy}
\usepackage[yyyymmdd]{datetime}
\usepackage{listings}

\usepackage{hyperref}

\DeclareMathOperator*{\colim}{colim}
\DeclareMathOperator*{\coker}{coker}

\begin{document}

\lstset{ language = Haskell
         , numbers = left
         , breaklines = true
         , basicstyle = \small\ttfamily
         }

\newcommand{\Slash}[1]{{\ooalign{\hfil/\crcr$#1$}}}

\title{Finite fields and functional reconstructions}
\author{Ray D. Sameshima}
\date{2016/09/23 $\sim$ \today \, \currenttime}
\maketitle

\tableofcontents

%%%%%%body
\setcounter{chapter}{-1}
\chapter{Preface}
\section{References}
\begin{enumerate}
\item \label{Tiziano}
Scattering amplitudes over finite fields and multivariate functional reconstruction\\
(Tiziano Peraro)\\
\url{https://arxiv.org/pdf/1608.01902.pdf}

\item Haskell Language \\
\url{www.haskell.org}

%\item \url{http://qiita.com/bra_cat_ket/items/205c19611e21f3d422b7}\\
% (Japanese tech support sns)

\item \label{Haskellroad}
The Haskell Road to Logic, Maths and Programming\\ 
(Kees Doets, Jan van Eijck)\\
\url{http://homepages.cwi.nl/~jve/HR/}

\item \label{Numerical}
Introduction to numerical analysis\\ 
(Stoer Josef, Bulirsch Roland)

\end{enumerate}

\section{Set theoretical gadgets}
\subsection{Numbers}
Here is a list of what we assumed that the readers are familiar with:
\begin{enumerate}
\item $\mathbb{N}$ (Peano axiom: $\emptyset, \text{suc}$)
\item $\mathbb{Z}$
\item $\mathbb{Q}$
\item $\mathbb{R}$ (Dedekind cut)
\item $\mathbb{C}$ 
\end{enumerate}

\subsection{Algebraic structures}
\begin{enumerate}
\item Monoid: $(\mathbb{N},+), (\mathbb{N},\times)$
\item Group: $(\mathbb{Z},+), (\mathbb{Z},\times)$
\item Ring: $\mathbb{Z}$
\item Field: $\mathbb{Q}$, $\mathbb{R}$ (continuous), $\mathbb{C}$ (algebraic closed)
\end{enumerate}

\section{Haskell language}
From "A Brief, Incomplete and Mostly Wrong History of Programming Languages":\footnote{
\url{http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html}
}
\begin{quotation}
1990 - A committee formed by Simon Peyton-Jones, Paul Hudak, Philip Wadler, Ashton Kutcher, and People for the Ethical Treatment of Animals creates Haskell, a pure, non-strict, functional language. Haskell gets some resistance due to the complexity of using monads to control side effects. Wadler tries to appease critics by explaining that "a monad is a monoid in the category of endofunctors, what's the problem?" 
\end{quotation}

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=3cm, bb= 0 0 1280 904]{Haskell-Logo.png}
\caption{Haskell's logo, the combinations of $\lambda$ and monad's bind \texttt{>>=}.}
\label{Haskell-Logo}
\end{center}
\end{figure}

Haskell language is a standardized purely functional declarative statically typed programming language.

In declarative languages, we describe "what" or "definition" in its codes, however imperative languages, like C/C++, "how" or "procedure".
\begin{quotation}
Functional languages can be seen as 'executable mathematics'; the notation was designed to be as close as possible to the mathematical way of writing.\footnote{
Algorithms: A Functional Programming Approach (Fethi A. Rabhi, Guy Lapalme)
}
\end{quotation}
Instead of loops, we use (implicit) recursions in functional language.\footnote{Of course, as a best practice, we should use higher order function (in this case \texttt{foldr} or \texttt{foldl}) rather than explicit recursions.
}
\begin{verbatim}
> sum :: [Int] -> Int
> sum []     = 0
> sum (i:is) = i + sum is
\end{verbatim}



%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Basics}
We have assumed living knowledge on (axiomatic, i.e., ZFC) set theory, algebraic structures.

\section{Finite fields}
\begin{verbatim}
Ffield.lhs

https://arxiv.org/pdf/1608.01902.pdf

> module Ffield where

> import Data.Ratio 
> import Data.Maybe
> import Data.Numbers.Primes
\end{verbatim}

\subsection{Rings}
A ring $(R,+,*)$ is a structured set $R$ with two binary operations
\begin{eqnarray}
\verb|(+) :: R -> R -> R|\\
\verb|(*) :: R -> R -> R|
\end{eqnarray}
satisfying the following 3 (ring) axioms:
\begin{enumerate}
\item $(R,+)$ is an abelian, i.e., commutative group,
i.e.,
\begin{eqnarray}
\forall a,b,c \in R, (a+b) + c = a + (b + c) & \text{ (associativity for $+$)} \\
\forall a, b, \in R, a+b = b+a & \text{ (commutativity)} \\
\exists 0 \in R, \text{ s.t. } \forall a \in R, a + 0 = a & \text{ (additive identity) } \\
\forall a \in R, \exists (-a) \in R \text{ s.t. } a + (-a) = 0 & \text{ (additive inverse)}
\end{eqnarray}

\item $(R,*)$ is a monoid, i.e.,
\begin{eqnarray}
\forall a,b,c \in R, (a*b) * c = a * (b * c) & \text{ (associativity for $*$)} \\
\exists 1 \in R, \text{ s.t. } \forall a \in R, a * 1 = a = 1*a & \text{ (multiplicative identity) } 
\end{eqnarray}

\item Multiplication is distributive w.r.t addition, i.e., $\forall a,b,c \in R$, 
\begin{eqnarray}
a*(b+c) = (a*b) + (a*c) & \text{ (left distributivity)} \\
(a+b)*c = (a*c) + (b*c) & \text{ (right distributivity)} 
\end{eqnarray}

\end{enumerate}

\subsection{Fields}
A field is a ring $(\mathbb{K},+,*)$ whose non-zero elements form an abelian group under multiplication, i.e., $\forall r \in \mathbb{K}$,
\begin{eqnarray}
r \neq 0 \Rightarrow \exists r^{-1} \in \mathbb{K} \text{ s.t. } r*r^{-1} = 1 = r^{-1}*r.
\end{eqnarray}
A field $\mathbb{K}$ is a finite field iff the underlying set $\mathbb{K}$ is finite.
A field $\mathbb{K}$ is called infinite field iff the underlying set is infinite.

\subsection{An example of finite rings $\mathbb{Z}_n$}
Let $n (>0) \in \mathbb{N}$ be a non-zero natural number.
Then the quotient set
\begin{eqnarray}
\mathbb{Z}_n &:=& \mathbb{Z} / n\mathbb{Z} \\
&\cong& \{0, \cdots, (n-1)\}
\end{eqnarray}
with addition, subtraction and multiplication under modulo $n$ is a ring.\footnote{
Here we have taken an equivalence class, 
\begin{eqnarray}
0 \leq \forall k \leq (n-1), [k] := \{k + n*z | z \in \mathbb{Z} \}
\end{eqnarray}
with the following operations:
\begin{eqnarray}
\left[k \right] + \left[l \right] &:=& \left[k+l\right] \\
\left[k \right] * \left[l \right] &:=& \left[k * l\right]
\end{eqnarray}
This is equivalent to take modular $n$:
\begin{eqnarray}
(k \mod n) + (l \mod n) &:=& (k+l \mod n) \\
(k \mod n) * (l \mod n) &:=& (k*l \mod n).
\end{eqnarray}

}

\subsection{B\'ezout's lemma}
Consider $a,b \in \mathbb{Z}$ be nonzero integers.
Then there exist $x,y \in \mathbb{Z}$ s.t.
\begin{eqnarray}
a*x + b*y = \gcd(a,b),
\end{eqnarray}
where $\gcd$ is the greatest common divisor (function), see \S\ref{gcdDefinition}.
We will prove this statement in \S\ref{exGCD}.

\subsection{Greatest common divisor}
\label{gcdDefinition}
Before the proof, here is an implementation of $\gcd$ using Euclidean algorithm with Haskell language:

\begin{verbatim}
> -- Eucledian algorithm.
> myGCD :: Integral a => a -> a -> a
> myGCD a b
>   | b < 0 = myGCD a (-b)
> myGCD a b
>   | a == b = a
>   | b >  a = myGCD b a
>   | b <  a = myGCD (a-b) b
\end{verbatim}

\subsubsection{Example, by hands}
Let us consider the gcd of 7 and 13.
Since they are primes, the gcd should be 1.
First it binds \texttt{a} with 7 and \texttt{b} with 13, and hit \texttt{b > a}.
\begin{eqnarray}
\texttt{myGCD 7 13 == myGCD 13 7}
\end{eqnarray}
Then it hits main line:
\begin{eqnarray}
\texttt{myGCD 13 7 == myGCD (13-7) 7}
\end{eqnarray}
In order to go to next step, Haskell evaluate $(13-7)$,\footnote{
Since Haskell language adopts lazy evaluation, i.e., call by need, not call by name.
}
and
\begin{eqnarray}
\texttt{myGCD (13-7) 7} &\texttt{==}& \texttt{myGCD 6 7} \\
&\texttt{==}& \texttt{myGCD 7 6} \\
&\texttt{==}& \texttt{myGCD (7-6) 6} \\
&\texttt{==}& \texttt{myGCD 1 6} \\
&\texttt{==}& \texttt{myGCD 6 1}
\end{eqnarray}
Finally it ends with 1:
\begin{eqnarray}
\texttt{myGCD 1 1 == 1} 
\end{eqnarray}

As another example, consider $15$ and $25$:
\begin{eqnarray}
\texttt{myGCD 15 25} &\texttt{==}& \texttt{myGCD 25 15}\\
&\texttt{==}& \texttt{myGCD (25-15) 15}\\
&\texttt{==}& \texttt{myGCD 10 15}\\
&\texttt{==}& \texttt{myGCD 15 10}\\
&\texttt{==}& \texttt{myGCD (15-10) 10}\\
&\texttt{==}& \texttt{myGCD 5 10}\\
&\texttt{==}& \texttt{myGCD 10 5}\\
&\texttt{==}& \texttt{myGCD (10-5) 5}\\
&\texttt{==}& \texttt{myGCD 5 5}\\
&\texttt{==}& \texttt{5}
\end{eqnarray}

\subsubsection{Example, with Haskell}
Let us check simple example using Haskell:
\begin{verbatim}
  *Ffield> myGCD 7 13
  1
  *Ffield> myGCD 7 14
  7
  *Ffield> myGCD (-15) (20)
  5
  *Ffield> myGCD (-299) (-13)
  13
\end{verbatim}
The final result is from
\begin{verbatim}
  *Ffield> 13*23
  299
\end{verbatim}

\subsection{Extended Euclidean algorithm}
\label{exGCD}
Here we treat the extended Euclidean algorithm, this is a constructive solution for B\'ezout's lemma.

As intermediate steps, this algorithm makes sequences of integers $\{r_i\}_i$, $\{s_i\}_i$, $\{t_i\}_i$ and quotients $\{q_i\}_i$ as follows.
The base cases are
\begin{eqnarray}
\left(r_0, s_0, t_0 \right) &:=& (a,1,0) \\
\left(r_1, s_1, t_1 \right) &:=& (b,0,1) 
\end{eqnarray}
and inductively, for $i \geq 2$,
\begin{eqnarray}
q_i &:=& \text{quot}(r_{i-2}, r_{i-1}) \\
r_i &:=& r_{i-2} - q_i * r_{i-1} \\
s_i &:=& s_{i-2} - q_i * s_{i-1} \\
t_i &:=& t_{i-2} - q_i * t_{i-1}.
\end{eqnarray}
The termination condition\footnote{
This algorithm will terminate eventually, since the sequence $\{r_i\}_i$ is non-negative by definition of $q_i$, but strictly decreasing.
Therefore, $\{r_i\}_i$ will meet $0$ in finite step $k$.
} is
\begin{eqnarray}
r_k = 0
\end{eqnarray}
for some $k \in \mathbb{N}$ and
\begin{eqnarray}
\gcd(a,b) &=& r_{k-1} \\
x &=& s_{k-1} \\
y &=& t_{k-1}.
\end{eqnarray}

\subsubsection{Proof}
By definition,
\begin{eqnarray}
\gcd(r_{i-1}, r_i) &=& \gcd(r_{i-1}, r_{i-2} - q_i * r_{i-1}) \\
&=& \gcd(r_{i-1}, r_{i-2})
\end{eqnarray}
and this implies 
\begin{eqnarray}
\gcd(a,b) =: \gcd(r_0, r_1) = \cdots = \gcd(r_{k-1}, 0),
\end{eqnarray}
i.e., 
\begin{eqnarray}
r_{k-1} = \gcd(a,b).
\end{eqnarray}

Next, for $i=0,1$ observe
\begin{eqnarray}
\label{guessOfRational}
a*s_i + b*t_i = r_i.
\end{eqnarray}
Let $i\geq 2$, then
\begin{eqnarray}
r_i &=& r_{i-2}  - q_i * r_{i-1} \\
&=& a*s_{i-2} + b*t_{i-2} - q_i *(a*s_{i-1} + b*t_{i-1} ) \\
&=& a*(s_{i-2} - q_i *s_{i-1}) + b* (t_{i-2} - q_i *t_{i-1} ) \\
&=:& a*s_i + b*t_i.
\end{eqnarray}
Therefore, inductively we get
\begin{eqnarray}
\gcd(a,b) = r_{k-1} = a*s_{k-1} + b*t_{k-1}. =: a*x + b*y.
\end{eqnarray}
This prove B\'ezout's lemma. \\
$\blacksquare$

\subsubsection{Haskell implementation}
\label{exGCDHaskell}
Here I use lazy lists for intermediate lists of $qs,rs,ss,ts$, and pick up (second) last elements for the results.

\label{extendedEuclideanAlgorithm}
\begin{verbatim}
Here we would like to implement the extended Euclidean algorithm.
See the algorithm, examples, and pseudo code at:

  https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm

> exGCD' :: (Integral n) => n -> n -> ([n], [n], [n], [n])
> exGCD' a b = (qs, rs, ss, ts)
>   where
>     qs = zipWith quot rs (tail rs)
>     rs = takeUntil (==0) r'
>     r' = steps a b
>     ss = steps 1 0
>     ts = steps 0 1
>     steps a b = rr
>       where 
>         rr@(_:rs) = a:b: zipWith (-) rr (zipWith (*) qs rs)
>
> takeUntil :: (a -> Bool) -> [a] -> [a]
> takeUntil p = foldr func []
>   where
>     func x xs 
>       | p x = []
>       | otherwise = x : xs
\end{verbatim}
Here we have used so called lazy lists, and higher order function\footnote{
Naively speaking, the function whose inputs and/or outputs are functions is called a higher order function.
}.
The gcd of $a$ and $b$ should be the last element of second list \verb+rs+, and our targets $(s,t)$ are second last elements of last two lists \verb+ss+ and \verb+ts+.
The following example is from wikipedia:
\begin{verbatim}
  *Ffield> exGCD' 240 46
  ([5,4,1,1,2],[240,46,10,6,4,2],[1,0,1,-4,5,-9,23],[0,1,-5,21,-26,47,-120])
\end{verbatim}  
Look at the second lasts of \verb+[1,0,1,-4,5,-9,23],[0,1,-5,21,-26,47,-120]+, i.e., -9 and 47:
\begin{verbatim}  
  *Ffield> gcd 240 46
  2
  *Ffield> 240*(-9) + 46*(47)
  2
\end{verbatim}
It works, and we have other simpler examples:
\begin{verbatim}
  *Ffield> exGCD' 15 25
  ([0,1,1,2],[15,25,15,10,5],[1,0,1,-1,2,-5],[0,1,0,1,-1,3])
  *Ffield> 15 * 2 + 25*(-1)
  5
  *Ffield> exGCD' 15 26
  ([0,1,1,2,1,3],[15,26,15,11,4,3,1],[1,0,1,-1,2,-5,7,-26],[0,1,0,1,-1,3,-4,15])
  *Ffield> 15*7 + (-4)*26
  1
\end{verbatim}
Now what we should do is extract gcd of $a$ and $b$, and $(x, y)$ from the tuple of lists:
\begin{verbatim}
> -- a*x + b*y = gcd a b
> exGCD :: Integral t => t -> t -> (t, t, t)
> exGCD a b = (g, x, y)
>   where
>     (_,r,s,t) = exGCD' a b
>     g = last r
>     x = last . init $ s
>     y = last . init $ t
\end{verbatim}
where the underscore \verb+_+ is a special symbol in Haskell that hits every pattern, since we do not need the quotient list.
So, in order to get gcd and $(x, y)$ we don't need quotients list.
\begin{verbatim}
  *Ffield> exGCD 46 240
  (2,47,-9)
  *Ffield> 46*47 + 240*(-9)
  2
  *Ffield> gcd 46 240
  2
\end{verbatim}

\subsection{Coprime as a binary relation}
Let us define a binary relation as follows:
\begin{verbatim}
  coprime :: Integral a => a -> a -> Bool
  coprime a b = (gcd a b) == 1
\end{verbatim}

\subsection{Corollary (Inverses in $\mathbb{Z}_n$)}
For a non-zero element
\begin{eqnarray}
a \in \mathbb{Z}_n,
\end{eqnarray}
there is a unique number 
\begin{eqnarray}
b \in \mathbb{Z}_n \text{ s.t. } ((a*b) \mod n) = 1
\end{eqnarray}
iff $a$ and $n$ are coprime.

\subsubsection{Proof}
From B\'ezout's lemma, $a$ and $n$ are coprime iff
\begin{eqnarray}
\exists s,t \in \mathbb{Z}, a*s + n*t = 1.
\end{eqnarray}
Therefore
\begin{eqnarray}
\text{$a$ and $n$ are coprime} &\Leftrightarrow& \exists s,t \in \mathbb{Z}, a*s + n*t = 1 \\
&\Leftrightarrow &\exists s,t' \in \mathbb{Z}, a*s = 1 + n*t'.
\end{eqnarray}
This $s$, by taking its modulo $n$ is our $b = a^{-1}$:
\begin{eqnarray}
a*s = 1 \mod n.
\end{eqnarray}
We will make a Haskell implementation in \S\ref{inverses}.\\
$\blacksquare$

\subsection{Corollary (Finite field $\mathbb{Z}_p$)}
If $p$ is prime, then 
\begin{eqnarray}
\mathbb{Z}_p := \{0, \cdots, (p-1)\}
\end{eqnarray}
with addition, subtraction and multiplication under modulo $n$ is a field.

\subsubsection{Proof}
It suffices to show that 
\begin{eqnarray}
\forall a \in \mathbb{Z}_p, a \neq 0 \Rightarrow \exists a^{-1} \in \mathbb{K} \text{ s.t. } a*a^{-1} = 1 = a^{-1}*a,
\end{eqnarray}
but since $p$ is prime, and
\begin{eqnarray}
\forall a \in \mathbb{Z}_p, a \neq 0 \Rightarrow \texttt{gcd a p == 1}
\end{eqnarray}
so all non-zero element has its inverse in $ \mathbb{Z}_p$.\\
$\blacksquare$

\subsubsection{Example and implementation}
\label{inverses}
Let us pick 11 as a prime and consider $\mathbb{Z}_{11}$:
\begin{verbatim}
  Example Z_{11}

  *Ffield> isField 11
  True
  *Ffield> map (exGCD 11) [0..10]
  [(11,1,0),(1,0,1),(1,1,-5),(1,-1,4),(1,-1,3)
  ,(1,1,-2),(1,-1,2),(1,2,-3),(1,3,-4),(1,-4,5),(1,1,-1)
  ]
\end{verbatim}
This list of three-tuple let us know the candidate of inverse.
Take the last one, \verb+(1,1,-1)+.
This is the image of \verb+exGcd 11 10+, and 
\begin{eqnarray}
1 = 10*1 + 11*(-1)
\end{eqnarray}
holds.
This suggests -1 is a candidate of the inverse of 10 in $\mathbb{Z}_{11}$:
\begin{eqnarray}
10^{-1} &=& -1 \mod 11 \\
&=& 10 \mod 11
\end{eqnarray}
In fact,
\begin{eqnarray}
10*10 = 11*9+1.
\end{eqnarray}
So, picking up the third elements in tuple and zipping with nonzero elements, we have a list of inverses:
\begin{verbatim}
  *Ffield> map ((`mod` 11) . (\(_,_,x)->x) . exGCD 11) [1..10] 
  [1,6,4,3,9,2,8,7,5,10]

We get non-zero elements with its inverse:

  *Ffield> zip [1..10] it
  [(1,1),(2,6),(3,4),(4,3),(5,9),(6,2),(7,8),(8,7),(9,5),(10,10)]
\end{verbatim}
Let us generalize these flow into a function\footnote{
From \url{https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Maybe.html}:
\begin{quotation}
The Maybe type encapsulates an optional value. 
A value of type Maybe a either contains a value of type a (represented as Just a), or it is empty (represented as Nothing). 
Using Maybe is a good way to deal with errors or exceptional cases without resorting to drastic measures such as error.
\end{quotation}
}:
\begin{verbatim}  
> -- a^{-1} (in Z_p) == a `inversep` p
> inversep :: Integral a => a -> a -> Maybe a
> a `inversep` p = let (g,x,_) = exGCD a p in
>   if (g == 1) then Just (x `mod` p)
>               else Nothing
\end{verbatim}
This \texttt{inversep} function returns the inverse with respect to second argument, if they are coprime, i.e. $\gcd$ is 1.
So the second argument should not be prime.
\begin{verbatim}
> inversesp :: Integral a => a -> [Maybe a]
> inversesp p = map (`inversep` p) [1..(p-1)]

  *Ffield> inversesp 11
  [Just 1,Just 6,Just 4,Just 3,Just 9,Just 2,Just 8,Just 7,Just 5,Just 10]
  *Ffield> inversesp 9
  [Just 1,Just 5,Nothing,Just 7,Just 2,Nothing,Just 4,Just 8]
\end{verbatim}

\section{Rational number reconstruction}
\subsection{A map from $\mathbb{Q}$ to $\mathbb{Z}_p$}
Let $p$ be a prime.
Now we have a map
\begin{eqnarray}
- \mod p : \mathbb{Z} \to \mathbb{Z}_p; a \mapsto (a \mod p),
\end{eqnarray}
and a natural inclusion (or a forgetful map)\footnote{
By introducing this forgetful map, we can use 
\begin{eqnarray}
\times : (\mathbb{Z}, \mathbb{Z}) \to \mathbb{Z} 
\end{eqnarray}
of normal product on $\mathbb{Z}$.
}
\begin{eqnarray}
\text{\textquestiondown} : \mathbb{Z}_p \hookrightarrow \mathbb{Z}.
\end{eqnarray}
Then we can define a map
\begin{eqnarray}
- \mod p : \mathbb{Q} \to \mathbb{Z}_p
\end{eqnarray}
by\footnote{
This is an example of operator overloadings.
}
\begin{eqnarray}
q = \frac{a}{b} \mapsto (q \mod p) := \left( \left( a \times \text{\textquestiondown} \left( b^{-1} \mod p\right) \right) \mod p \right).
\end{eqnarray}

\subsubsection{Example and implementation}
An easy implementation is the followings:\footnote{
The backquotes makes any binary function infix operator.
For example,
\begin{eqnarray}
\texttt{add 1 2 == 1 `add` 2}
\end{eqnarray}
Similarly, use parenthesis we can use an infix binary operator to a function:
\begin{eqnarray}
\texttt{(+) 1 2 == 1 + 2}
\end{eqnarray}
}
\begin{verbatim}
A map from Q to Z_p.

> -- p should be prime.
> modp :: Integral a => Ratio a -> a -> a
> q `modp` p = (a * (bi `mod` p)) `mod` p
>   where
>     (a,b) = (numerator q, denominator q)
>     bi = fromJust (b `inversep` p)
\end{verbatim}
Let us consider a rational number $\frac{3}{7}$ on a finite field $\mathbb{Z}_{11}$:
\begin{verbatim}
Example: on Z_{11}
Consider (3 % 7).

  *Ffield> let q = 3%7
  *Ffield> 3 `mod` 11
  3
  *Ffield> 7 `inversep` 11
  Just 8
  *Ffield> (3*8) `mod` 11
  2
\end{verbatim}
For example, pick 7:
\begin{verbatim}  
  *Ffield> 7*8 == 11*5+1
  True
\end{verbatim}
Therefore, on $\mathbb{Z}_{11}$, $(7^{-1} \mod 11)$ is equal to $(8 \mod 11)$ and
\begin{eqnarray}
\frac{3}{7} \in \mathbb{Q} &\mapsto& (3 \times \text{\textquestiondown}(7^{-1} \mod 11) \mod 11) \\
&&= (3 \times 8) \mod 11 \\
&&= 24 \mod 11 \\
&&= 2 \mod 11.
\end{eqnarray}
Haskell returns the same result
\begin{verbatim}  
  *Ffield> q `modp` 11
  2
\end{verbatim}
and consistent.

\subsection{Reconstruction from $\mathbb{Z}_p$ to $\mathbb{Q}$}
Consider a rational number $q$ and its image $a \in \mathbb{Z}_p$.
\begin{eqnarray}
a := q \mod p
\end{eqnarray}
The extended Euclidean algorithm can be used for guessing a rational number $q$ from the images $a := q \mod p$ of several primes $p$'s.

At each step, the extended Euclidean algorithm satisfies eq.(\ref{guessOfRational}).
\begin{eqnarray}
a*s_i + p*t_i = r_i
\end{eqnarray}
Therefore
\begin{eqnarray}
r_i = a*s_i \mod p. %\Leftrightarrow \frac{r_i}{s_i} \mod p = a.
\end{eqnarray}
Hence $\frac{r_i}{s_i}$ is a possible guess for $q$.
We take
\begin{eqnarray}
\label{terminationOfRec}
r_i^2 , s_i^2 < p
\end{eqnarray}
as the termination condition for this reconstruction.

\subsubsection{Haskell implementation}
Let us first try to reconstruct from the image $(\frac{1}{3} \mod p)$ of some prime $p$.
Here we have chosen three primes
\begin{verbatim}
Reconstruction Z_p -> Q
  *Ffield> let q = (1%3)
  *Ffield> take 3 $ dropWhile (<100) primes
  [101,103,107]
\end{verbatim}
The images are basically given by the first elements of second lists ($s_0$'s):
\begin{verbatim}  
  *Ffield> q `modp` 101
  34
  *Ffield> let try x = exGCD' (q `modp` x) x
  *Ffield> try 101
  ([0,2,1,33],[34,101,34,33,1],[1,0,1,-2,3,-101],[0,1,0,1,-1,34])
  *Ffield> try 103
  ([0,1,2,34],[69,103,69,34,1],[1,0,1,-1,3,-103],[0,1,0,1,-2,69])
  *Ffield> try 107
  ([0,2,1,35],[36,107,36,35,1],[1,0,1,-2,3,-107],[0,1,0,1,-1,36])  
\end{verbatim}
Look at the first hit of termination condition eq.(\ref{terminationOfRec}), $r_4=1$ and $s_4=3$.
They give us the same guess $\frac{1}{3}$, and that the reconstructed number.

From the above observations we can make a simple "guess" function:
\begin{verbatim}
> guess :: Integral t =>
>          (t, t)       -- (q `modp` p, p)
>       -> (Ratio t, t)
> guess (a, p) = let (_,rs,ss,_) = exGCD' a p in
>   (select rs ss p, p)
>     where
>       select :: Integral t => [t] -> [t] -> t -> Ratio t
>       select [] _ _ = 0%1
>       select (r:rs) (s:ss) p
>         | s /= 0 && r^2 <= p && s^2 <= p = r%s
>         | otherwise = select rs ss p
\end{verbatim}
We have put a list of big primes as follows.
\begin{verbatim}
> -- Hard code of big primes
> -- For chinese reminder theorem we declare it as [Integer].
> bigPrimes :: [Integer]
> bigPrimes = dropWhile (< 897473) $ takeWhile (< 978948) primes  
\end{verbatim}
We choose 3 times match as the termination condition.
\begin{verbatim}
> matches3 :: Eq a => [a] -> a
> matches3 (a:bb@(b:c:cs))
>   | a == b && b == c = a
>   | otherwise        = matches3 bb
\end{verbatim}
Finally, we can check our gadgets.

What we know is a list of (q `modp` p) and prime p for several (big) primes.
\begin{verbatim}
  *Ffield> let q = 10%19
  *Ffield> let knownData = zip (map (modp q) bigPrimes) bigPrimes 
  *Ffield> take 3 knownData 
  [(614061,897473),(377894,897497),(566842,897499)]
  *Ffield> matches3 $  map (fst . guess) knownData
  10 % 19
\end{verbatim}
The following is the function we need, its input is the list of tuple which first element is the image in $\mathbb{Z}_p$ and second element is that prime $p$.
\begin{verbatim}
> reconstruct :: Integral a =>
>                [(a, a)]  -- :: [(Z_p, primes)]
>             -> Ratio a
> reconstruct aps = matches3 $ map (fst . guess) aps

Here is a naive test:
  > let qs = [1 % 3,10 % 19,41 % 17,30 % 311,311 % 32
             ,869 % 232,778 % 123,331 % 739]
  > let modmap q = zip (map (modp q) bigPrimes) bigPrimes 
  > let longList = map modmap qs
  > map reconstruct longList 
  [1 % 3,10 % 19,41 % 17,30 % 311,311 % 32
  ,869 % 232,778 % 123,331 % 739]
  > it == qs
  True
\end{verbatim}

For later use, let us define
\begin{verbatim}
> imagesAndPrimes ::  Rational-> [(Integer, Integer)]
> imagesAndPrimes q = zip (map (modp q) bigPrimes) bigPrimes
\end{verbatim}
to generate a list of images (of our target rational number) in $Z_p$ and the base primes.

As another example, we have slightly involved function:
\begin{verbatim}
> matches3' :: Eq a => [(a, t)] -> (a, t)
> matches3' (a0@(a,_):bb@((b,_):(c,_):cs))
>   | a == b && b == c = a0
>   | otherwise        = matches3' bb
\end{verbatim}
Let us see the first good guess, Haskell tells us that in order to reconstruct, say $\frac{331}{739}$, we should take three primes start from 614693:
\begin{verbatim}
  *Ffield> let knowData q = zip (map (modp q) primes) primes
  *Ffield> matches3' $ map guess $ knowData (331%739)
  (331 % 739,614693)
  (18.31 secs, 12,393,394,032 bytes)
  
  *Ffield> matches3' $ map guess $ knowData (11%13)
  (11 % 13,311)
  (0.02 secs, 2,319,136 bytes)
  *Ffield> matches3' $ map guess $ knowData (1%13)
  (1 % 13,191)
  (0.01 secs, 1,443,704 bytes)
  *Ffield> matches3' $ map guess $ knowData (1%3)
  (1 % 3,13)
  (0.01 secs, 268,592 bytes)
  *Ffield> matches3' $ map guess $ knowData (11%31)
  (11 % 31,1129)
  (0.03 secs, 8,516,568 bytes)
  *Ffield> matches3' $ map guess $ knowData (12%312)
  (1 % 26,709)
\end{verbatim}

\subsubsection{A problem}
Since our choice of \texttt{bigPrimes} are order $10^6$, our reconstruction can fail for rational numbers of
\begin{eqnarray}
\frac{O(10^3)}{O(10^3)},
\end{eqnarray}
say
\begin{verbatim}
  *Ffield> let q = 895%922
  *Ffield> let knownData = imagesAndPrimes q
  *Ffield> take 4 knownData 
  [(882873,897473)
  ,(365035,897497)
  ,(705735,897499)
  ,(511060,897517)
  ]
  *Ffield> map guess it
  [((-854) % 123,897473)
  ,((-656) % 327,897497)
  ,((-192) % 805,897499)
  ,((-491) % 497,897517)
  ]
\end{verbatim}
We can solve this by introducing the following theorem.

\subsection{Chinese remainder theorem}
From wikipedia\footnote{
\url{https://en.wikipedia.org/wiki/Chinese_remainder_theorem}
}
\begin{quotation}
There are certain things whose number is unknown. If we count them by threes, we have two left over; by fives, we have three left over; and by sevens, two are left over. How many things are there? 
\end{quotation}
Here is a solution with Haskell:
\begin{verbatim}
*Ffield> let lst = [n|n<-[0..], mod n 3==2, mod n 5==3, mod n 7==2]
*Ffield> head lst
23
\end{verbatim}
We define an infinite list of natural numbers that satisfy
\begin{eqnarray}
n \mod 3 = 2, n \mod 5 = 3, n \mod 7 = 2.
\end{eqnarray}
Then take the first element, and this is the answer.

\subsubsection{Claim}
The statement for binary case is the following.
Let $n_1, n_2 \in \mathbb{Z}$ be coprime, then for arbitrary $a_1,a_2 \in \mathbb{Z}$, the following a system of equations
\begin{eqnarray}
x &=& a_1 \mod n_1\\
x &=& a_2 \mod n_2
\end{eqnarray}
have a unique solution modular $n_1*n_2$\footnote{
Note that, this is equivalent that there is a unique solution $a$ in
\begin{eqnarray}
0 \leq a < n_1\times n_2.
\end{eqnarray}
}.

\subsubsection{Proof}
(existence) With \S\ref{exGCD}, there are $m_1,m_2 \in \mathbb{Z}$ s.t.
\begin{eqnarray}
n_1 * m_1 + n_2 * m_2 = 1.
\end{eqnarray}
Now we have
\begin{eqnarray}
n_1 * m_1 &=& 1 \mod n_2 \\
n_2 * m_2 &=& 1 \mod n_1
\end{eqnarray}
that is\footnote{
Here we have used slightly different notions from \ref{Tiziano}.
$m_1$ in \ref{Tiziano} is our $m_2$ times our $n_2$.
}
\begin{eqnarray}
m_1 &=& n_1^{-1} \mod n_2 \\
m_2 &=& n_2^{-1} \mod n_1.
\end{eqnarray}
Then
\begin{eqnarray}
a := a_1 * n_2 * m_2 + a_2 * n_1 * m_1 \mod (n_1*n_2)
\end{eqnarray}
is a solution.

(uniqueness)
If $a'$ is also a solution, then
\begin{eqnarray}
a - a' &=& 0 \mod n_1 \\
a - a' &=& 0 \mod n_2.
\end{eqnarray}
Since $n_1$ and $n_2$ are coprime, i.e., no common divisors, this difference is divisible by $n_1*n_2$, and
\begin{eqnarray}
a - a' = 0 \mod (n_1 * n_2).
\end{eqnarray}
Therefore, the solution is unique modular $n_1*n_2$. \\
$\blacksquare$

%\subsubsection{Generalization}
%Given $a \in Z_n$ of pairwise coprime numbers
%\begin{eqnarray}
%n := n_1 * \cdots * n_k,
%\end{eqnarray}
%a system of equations
%\begin{eqnarray}
%\left. a_i = a \mod n_i \right|_{i=1}^k
%\end{eqnarray}
%have a unique solution
%\begin{eqnarray}
%a = \sum_i m_i a_i \mod n,
%\end{eqnarray}
%where
%\begin{eqnarray}
%\left. m_i = \left( \frac{n_i}{n} \mod n_i \right) \frac{n}{n_i} \right|_{i=1}^k.
%\end{eqnarray}

\subsubsection{Haskell implementation}
Let us see how our naive \texttt{guess} function fail one more time:
\begin{verbatim}
Chinese Remainder Theorem, and its usage
 
  *Ffield> let q = 895%922
  *Ffield> let knownData = imagesAndPrimes q
  *Ffield> let [(a1,p1),(a2,p2)] = take 2 knownData 
  *Ffield> take 2 knownData 
  [(882873,897473),(365035,897497)]
  *Ffield> map guess it
  [((-854) % 123,897473),((-656) % 327,897497)]
\end{verbatim}

It suffices to make a binary version of Chinese Remainder theorem in Haskell:
\begin{verbatim}
> crtRec' :: Integral t => (t, t) -> (t, t) -> (t, t)
> crtRec' (a1,p1) (a2,p2) = (a,p)
>   where
>     a = (a1*p2*m2 + a2*p1*m1) `mod` p
>     m1 = fromJust (p1 `inversep` p2) 
>     m2 = fromJust (p2 `inversep` p1)
>     p = p1*p2
\end{verbatim}
\texttt{crtRec'} function takes two tuples of image in $\mathbb{Z}_p$ and primes, and returns these combination.
Now let us fold.
\begin{verbatim}
> pile :: (a -> a -> a) -> [a] -> [a]
> pile f [] = []
> pile f dd@(d:ds) = d : zipWith' f (pile f dd) ds
\end{verbatim}
Schematically, this \texttt{pile f} function takes
\begin{eqnarray}
\left[d_0, d_1, d_2, d_3, \cdots \right]
\end{eqnarray}
and returns
\begin{eqnarray}
\left[d_0, f(d_0,d_1), f(f(d_0,d_1),d_2), f(f(f(d_0,d_1),d_2), d_3), \cdots \right]
\end{eqnarray}
We have used another higher order function which is slightly modified from standard definition:
\begin{verbatim}
> -- Strict zipWith, from:
> --   http://d.hatena.ne.jp/kazu-yamamoto/touch/20100624/1277348961
> zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]
> zipWith' f (a:as) (b:bs) = (x `seq` x) : zipWith' f as bs
>   where x = f a b
> zipWith' _ _      _      = []
\end{verbatim}

Let us check our implementation.
\begin{verbatim}
  *Ffield> let q = 895%922
  *Ffield> let knownData = imagesAndPrimes q
  *Ffield> take 4 knownData 
  [(882873,897473)
  ,(365035,897497)
  ,(705735,897499)
  ,(511060,897517)
  ]
  *Ffield> pile crtRec' it
  [(882873,897473)
  ,(86488560937,805479325081)
  ,(397525881357811624,722916888780872419)
  ,(232931448259966259937614,648830197267942270883623)
  ]
  *Ffield> map guess it
  [((-854) % 123,897473)
  ,(895 % 922,805479325081)
  ,(895 % 922,722916888780872419)
  ,(895 % 922,648830197267942270883623)
\end{verbatim}
So on a product ring $\mathbb{Z}_{805479325081}$, we get the right answer.

\subsection{\texttt{recCRT}: from image in $\mathbb{Z}_p$ to rational number}
From above discussion, here we can define a function which takes a list of images in $\mathbb{Z}_p$ and returns the rational number.
What we do is, basically, to take a list of image (of our target rational number) and primes, then applying Chinese Remainder theorem recursively, return several guess of rational number.
\begin{verbatim}
> recCRT :: Integral a => [(a,a)] -> Ratio a
> recCRT = reconstruct . pile crtRec'

> recCRT' = matches3' . map guess . pile crtRec'

  *Ffield> let q = 895%922
  *Ffield> let knownData = imagesAndPrimes q
  *Ffield> recCRT knownData 
  895 % 922
  *Ffield> recCRT' knownData 
  (895 % 922,805479325081)
\end{verbatim}
Here is some random checks and results.
\begin{verbatim}
todo: use QuickCheck

> trial = do
>   n <- randomRIO (0,10000) :: IO Integer
>   d <- randomRIO (1,10000) :: IO Integer
>   let q = (n%d)
>   putStrLn $ "input: " ++ show q
>   return $ recCRT' . imagesAndPrimes $ q

  *Ffield> trial
  input: 1080 % 6931
  (1080 % 6931,805479325081)
  *Ffield> trial
  input: 2323 % 1248
  (2323 % 1248,805479325081)
  *Ffield> trial
  input: 6583 % 1528
  (6583 % 1528,805479325081)
  *Ffield> trial
  input: 721 % 423
  (721 % 423,897473)
  *Ffield> trial
  input: 9967 % 7410
  (9967 % 7410,805479325081)
\end{verbatim}


\section{Polynomials and rational functions}
The following discussion on an arbitrary field $\mathbb{K}$.

\subsection{Notations}
Let $n \in \mathbb{N}$ be positive. 
We use multi-index notation:
\begin{eqnarray}
\alpha = (\alpha_1, \cdots, \alpha_n) \in \mathbb{N}^n.
\end{eqnarray}
A monomial is defined as
\begin{eqnarray}
z^\alpha := \prod_i z_i^{\alpha_i}.
\end{eqnarray}
The total degree of this monomial is given by
\begin{eqnarray}
|\alpha| := \sum_i \alpha_i.
\end{eqnarray}

\subsection{Polynomials and rational functions}
Let $\mathbb{K}$ be a field.
Consider a map
\begin{eqnarray}
f : \mathbb{K}^n \to \mathbb{K}; z \mapsto f(z) := \sum_\alpha c_\alpha z^\alpha,
\end{eqnarray}
where
\begin{eqnarray}
c_\alpha \in \mathbb{K}.
\end{eqnarray}
We call the value $f(z)$ at the dummy $z \in \mathbb{K}^n$ a polynomial:
\begin{eqnarray}
f(z) := \sum_\alpha c_\alpha z^\alpha.
\end{eqnarray}
We denote
\begin{eqnarray}
\mathbb{K}[z] := \left\{ \sum_\alpha c_\alpha z^\alpha \right\}
\end{eqnarray}
as the ring of all polynomial functions in the variable $z$ with $\mathbb{K}$-coefficients.

Similarly, a rational function can be expressed as a ratio of two polynomials $p(z),q(z) \in \mathbb{K}[z]$:
\begin{eqnarray}
\frac{p(z)}{q(z)} = \frac{\sum_\alpha n_\alpha z^\alpha}{\sum_\beta d_\beta z^\beta}.
\end{eqnarray}
We denote
\begin{eqnarray}
\mathbb{K}(z) := \left\{ \frac{\sum_\alpha n_\alpha z^\alpha}{\sum_\beta d_\beta z^\beta} \right\}
\end{eqnarray}
as the field of rational functions in the variable $z$ with $\mathbb{F}$-coefficients.
Similar to fractional numbers, there are several equivalent representation of a rational function, even if we simplify with gcd.
However there still is an overall constant ambiguity.
To have a unique representation, usually we put the lowest degree of term of the denominator to be 1.

\subsection{As data, coefficients list}
We can identify a polynomial
\begin{eqnarray}
\sum_\alpha c_\alpha z^\alpha
\end{eqnarray}
as a set of coefficients
\begin{eqnarray}
\{ c_\alpha\}_{\alpha}.
\end{eqnarray}

Similarly, for a rational function, we can identify
\begin{eqnarray}
\frac{\sum_\alpha n_\alpha z^\alpha}{\sum_\beta d_\beta z^\beta}
\end{eqnarray}
as an ordered pair of coefficients
\begin{eqnarray}
(\{ n_\alpha\}_\alpha, \{ d_\beta\}_\beta).
\end{eqnarray}
However, there still is an overall factor ambiguity even after gcd simplifications.

\section{Haskell implementation of univariate polynomials}
Here we basically follows some part of \S9 of ref.\ref{Haskellroad}, and its addendum\footnote{
See \url{http://homepages.cwi.nl/~jve/HR/PolAddendum.pdf}
}.

\begin{verbatim}
Univariate.lhs

> module Univariate where
> import Data.Ratio
> import Polynomials 
\end{verbatim}

\subsection{A polynomial as a list of coefficients}
Let us start \texttt{instance} declaration, which enable us to use basic arithmetics, e.g., addition and multiplication.
\begin{verbatim}
-- Polynomials.hs
-- http://homepages.cwi.nl/~jve/rcrh/Polynomials.hs

module Polynomials where

default (Integer, Rational, Double) 

-- polynomials, as coefficients lists
instance (Num a, Ord a) => Num [a] where
  fromInteger c = [fromInteger c] 
  -- operator overloading
  negate []     = []
  negate (f:fs) = (negate f) : (negate fs)

  signum [] = []
  signum gs 
    | signum (last gs) < (fromInteger 0) = negate z
    | otherwise = z

  abs [] = []
  abs gs 
    | signum gs == z = gs
    | otherwise      = negate gs

  fs     + []     = fs
  []     + gs     = gs
  (f:fs) + (g:gs) = f+g : fs+gs

  fs     * []     = []
  []     * gs     = []
  (f:fs) * gg@(g:gs) = f*g : (f .* gs + fs * gg)

delta :: (Num a, Ord a) => [a] -> [a]
delta = ([1,-1] *)

shift :: [a] -> [a]
shift = tail 

p2fct :: Num a => [a] -> a -> a
p2fct [] x = 0
p2fct (a:as) x = a + (x * p2fct as x)

comp :: (Eq a, Num a, Ord a) => [a] -> [a] -> [a]
comp _     []      = error ".."
comp []     _      = []
comp (f:fs) g0@(0:gs) = f : gs * (comp fs g0)
comp (f:fs) gg@(g:gs) = ([f] + [g] * (comp fs gg))
                      + (0 : gs * (comp fs gg))

deriv :: Num a => [a] -> [a]
deriv []     = []
deriv (f:fs) = deriv1 fs 1 
  where 
    deriv1 []     _ = []
    deriv1 (g:gs) n = n*g : deriv1 gs (n+1)

\end{verbatim}
Note that the above operators are overloaded, say \texttt{(*)}, \texttt{f*g} is a multiplication of two numbers but \texttt{fs*gg} is a multiplication of two list of coefficients.
We can not extend this overloading to scalar multiplication, since Haskell type system takes the operands of \texttt{(*)} the same type
\begin{eqnarray}
\verb+(*) :: Num a => a -> a -> a+
\end{eqnarray}

\begin{verbatim}
> -- scalar multiplication
> infixl 7 .*
> (.*) :: Num a => a -> [a] -> [a]
> c .* []     = []
> c .* (f:fs) = c*f : c .* fs
\end{verbatim}
Let us see few examples.
If we take a scalar multiplication, say
\begin{eqnarray}
3 * \left( 1+2z+3z^2+4z^3\right)
\end{eqnarray}
the result should be
\begin{eqnarray}
3 * \left( 1+2z+3z^2+4z^3\right)
=
3+6z+9z^2+12z^3
\end{eqnarray}
In Haskell 
\begin{verbatim}
  *Univariate> 3 .* [1,2,3,4]
  [3,6,9,12]
\end{verbatim}
and this is exactly same as map with section:
\begin{verbatim}
  *Univariate> map (3*) [1,2,3,4]
  [3,6,9,12]
\end{verbatim}
When we multiply two polynomials, say
\begin{eqnarray}
(1+2z) * (3+4z+5z^2+6z^3)
\end{eqnarray}
the result should be
\begin{eqnarray}
\nonumber
(1+2z) * (3+4z+5z^2+6z^3)
&=& 1*(3+4z+5z^2+6z^3) + 2z*(3+4z+5z^2+6z^3) \\
\nonumber
&=& 3+(4+2*3)z+(5+2*4)z^2+(6+2*5)z^3 + 2*6 z^4 \\
&=& 3+ 10z + 13z^2 + 16 z^3 + 12 z^4 
\end{eqnarray}
In Haskell,
\begin{verbatim}
  *Univariate> [1,2] * [3,4,5,6]
  [3,10,13,16,12]
\end{verbatim}

Now the (dummy) variable is given as 
\begin{verbatim}
> -- z of f(z), variable
> z :: Num a => [a]
> z = [0,1]
\end{verbatim}

A polynomial of degree $R$ is given by a finite sum of the following form:
\begin{eqnarray}
f(z) := \sum_{i=0}^R c_i z^i.
\end{eqnarray}
Therefore, it is natural to represent $f(z)$ by a list of coefficient $\{c_i\}_i$.
Here is the translator from the coefficient list to a polynomial function:
\begin{verbatim}
> p2fct :: Num a => [a] -> a -> a
> p2fct [] x = 0
> p2fct (a:as) x = a + (x * p2fct as x)
\end{verbatim}
This gives us\footnote{
Here we have used lambda, or so called anonymous function.
From\\
\url{http://learnyouahaskell.com/higher-order-functions}
\begin{quote}
To make a lambda, we write a \textbackslash (because it kind of looks like the greek letter lambda if you squint hard enough) and then we write the parameters, separated by spaces. 
\end{quote}
For example,
\begin{eqnarray}
f(x) &:=& x^2 + 1 \\
f &:=& \lambda x. x^2+1
\end{eqnarray}
are the same definition.
}
\begin{verbatim}
*Univariate> take 10 $ map (p2fct [1,2,3]) [0..]
[1,6,17,34,57,86,121,162,209,262]
*Univariate> take 10 $ map (\n -> 1+2*n+3*n^2) [0..]
[1,6,17,34,57,86,121,162,209,262]
\end{verbatim}

\subsection{Difference analysis}
We do not know in general this canonical form of the polynomial, nor the degree.
That means, what we can access is the graph of $f$, i.e., the list of inputs and outputs.
Without loss of generality, we can take
\begin{eqnarray}
\texttt{[0..]}
\end{eqnarray}
as the input data.
Usually we take a finite sublist of this, but we assume it is sufficiently long.
The outputs should be
\begin{eqnarray}
\texttt{map f [0..] = [f 0, f 1 ..]}
\end{eqnarray}
For example
\begin{verbatim}
*Univariate> take 10 $ map (\n -> n^2+2*n+1) [0..]
[1,4,9,16,25,36,49,64,81,100]
\end{verbatim}

Let us consider the difference sequence
\begin{eqnarray}
\label{difference}
\Delta(f) (n) := f(n+1) - f(n).
\end{eqnarray}
Its Haskell version is
\begin{verbatim}
> -- difference analysis
> difs :: (Num a) => [a] -> [a]
> difs [] = []
> difs [_] = []
> difs (i:jj@(j:js)) = j-i : difs jj
\end{verbatim}
This gives
\begin{verbatim}
*Univariate> difs [1,4,9,16,25,36,49,64,81,100]
[3,5,7,9,11,13,15,17,19]
*Univariate> difs [3,5,7,9,11,13,15,17,19]
[2,2,2,2,2,2,2,2]
\end{verbatim}

We claim that if $f(z)$ is a polynomial of degree $R$, then $\Delta(f)(z)$ is a polynomial of degree $R-1$.
Since the degree is given, we can write $f(z)$ in canonical form
\begin{eqnarray}
f(n) = \sum_{i=0}^R c_i n^i
\end{eqnarray}
and
\begin{eqnarray}
\Delta(f)(n) &:=& f(n+1) - f(n) \\
&=& \sum_{i=0}^R c_i \left\{ (n+1)^i - n^i\right\} \\
&=& \sum_{i=1}^R c_i \left\{ (n+1)^i - n^i\right\} \\
&=& \sum_{i=1}^R c_i \left\{ i*n^{i-1} + O(n^{i-2}) \right\} \\
&=& c_R*R*n^{R-1} + O(n^{R-2})
\end{eqnarray}
where $O(n^{i-2})$ is some polynomial(s) of degree $i-2$.

This guarantees the following function will terminate in finite steps\footnote{
If a given lists is generated by a polynomial.
}; \texttt{difLists} keeps generating difference lists until the difference get constant.
\begin{verbatim}
> difLists :: (Eq a, Num a) => [[a]] -> [[a]]
> difLists [] = []
> difLists xx@(xs:xss) =
>   if isConst xs then xx
>                 else difLists $ difs xs : xx
>   where
>     isConst (i:jj@(j:js)) = all (==i) jj
>     isConst _ = error "difLists: lack of data, or not a polynomial"
\end{verbatim}
Let us try:
\begin{verbatim}
  *Univariate> difLists [[-12,-11,6,45,112,213,354,541,780,1077]]
  [[6,6,6,6,6,6,6]
  ,[16,22,28,34,40,46,52,58]
  ,[1,17,39,67,101,141,187,239,297]
  ,[-12,-11,6,45,112,213,354,541,780,1077]
  ]
\end{verbatim}

The degree of the polynomial can be computed by difference analysis:
\begin{verbatim}
> degree' :: (Eq a, Num a) => [a] -> Int
> degree' xs = length (difLists [xs]) -1
\end{verbatim}
For example,
\begin{verbatim}
*Univariate> degree [1,4,9,16,25,36,49,64,81,100]
2
*Univariate> take 10 $ map (\n -> n^2+2*n+1) [0..]
[1,4,9,16,25,36,49,64,81,100]
*Univariate> degree $ take 10 $ map (\n -> n^5+4*n^3+1) [0..]
5
\end{verbatim}

Above \verb+degree'+ function can only treat finite list, however, the following function can compute the degree of infinite list.
\begin{verbatim} 
> degreeLazy :: (Eq a, Num a) => [a] -> Int
> degreeLazy xs = helper xs 0
>   where
>     helper as@(a:b:c:_) n
>       | a==b && b==c = n
>       | otherwise    = helper (difs as) (n+1)
\end{verbatim}
Note that this lazy function only sees the first two elements of the list (of difference).
So first take the lazy \verb+degreeLazy+ and guess the degree, take sufficient finite sublist of output and apply \verb+degree'+.
Here is the hybrid version:
\begin{verbatim}
> degree :: (Num a, Eq a) => [a] -> Int
> degree xs = let l = degreeLazy xs in
>   degree' $ take (l+2) xs
\end{verbatim}

\chapter{Functional reconstruction over $\mathbb{Q}$}
The goal of a functional reconstruction algorithm is to identify the monomials appearing in their definition and the corresponding coefficients.

From here, we use $\mathbb{Q}$ as our base field, but every algorithm can be computed on any field, e.g., finite field $\mathbb{Z}_p$.

\section{Univariate polynomials}
\subsection{Newtons' polynomial representation}
Consider a univariate polynomial $f(z)$.
Given a sequence of distinct values $\left. y_n \right|_{n \in \mathbb{N}}$, we evaluate the polynomial form $f(z)$ sequentially:
\begin{eqnarray}
f_0(z) &=& a_0 \\
f_1(z) &=& a_0 + (z-y_0)a_1 \\
\nonumber
&\vdots& \\
f_r(z) &=& a_0 + (z-y_0) \left(a_1 + (z-y_1)(\cdots + (z - y_{r-1})a_r \right) \\
&=& f_{r-1}(z) + (z-y_0) (z-y_1) \cdots (z - y_{r-1})a_r,
\end{eqnarray}
where
\begin{eqnarray}
a_0 &=& f(y_0) \\
a_1 &=& \frac{f(y_1) - a_0}{y_1 - y_0} \\
\nonumber
&\vdots& \\
a_r &=& \left( \left( \left( f(y_r)-a_0 \right)\frac{1}{y_r - y_0} - a_1 \right)\frac{1}{y_r - y_1} - \cdots - a_{r-1} \right) \frac{1}{y_r - y_{r-1}} \qquad
\end{eqnarray}
It is easy to see that, $f_r(z)$ and the original $f(z)$ match on the given data points, i.e.,
\begin{eqnarray}
f_r(n) = f(n), 0 \leq n \leq r.
\end{eqnarray}

When we have already known the total degree of $f(z)$, say $R$, then we can terminate this sequential trial:
\begin{eqnarray}
f(z) &=& f_R(z) \\
&=& \sum_{r=0}^R a_r \prod_{i=0}^{r-1}(z - y_i).
\end{eqnarray}

In practice, a consecutive zero on the sequence $a_r$ can be taken as the termination condition for this algorithm.\footnote{
We have not proved, but higher power will be dominant when we take sufficiently big input, so we terminate this sequence when we get a consecutive zero in $a_r$.
}

\subsection{Towards canonical representations}
Once we get the Newton's representation
\begin{eqnarray}
\sum_{r=0}^R a_r \prod_{i=0}^{r-1}(z - y_i) = a_0 + (z-y_0) \left(a_1 + (z-y_1)(\cdots + (z - y_{R-1})a_R \right) \quad
\end{eqnarray}
as the reconstructed polynomial, it is convenient to convert it into the canonical form:
\begin{eqnarray}
\sum_{r=0}^R c_r z^r.
\end{eqnarray}
This conversion only requires addition and multiplication of univariate polynomials.
These operations are reasonably cheap, especially on $\mathbb{Z}_p$. 

\subsection{Simplification of our problem}
Without loss of generality, we can put 
\begin{eqnarray}
\texttt{[0..]}
\end{eqnarray}
as our input list. 
We usually take its finite part but we assume it has enough length.
Corresponding to above input,
\begin{eqnarray}
\texttt{map f [0..] = [f 0, f 1, ..]}
\end{eqnarray}
of \texttt{f :: Ratio Int -> Ratio Int} is our output list.

Then we have slightly simpler forms of coefficients:
\begin{eqnarray}
f_r(z) &:=& a_0 + z*\left( a_1 +(z-1)\left(a_2 + (z-2)\left(a_3 + \cdots + (z-r+1)a_r \right) \right) \right) \qquad\qquad \\
a_0 &=& f(0) \\
a_1 &=& f(y_1) - a_0 \\
&=& f(1) - f(0) =: \Delta(f)(0) \\
a_2 &=& \frac{f(2)-a_0}{2}-a_1 \\
&=& \frac{f(2) - f(0)}{2} - \left( f(1) - f(0) \right) \\
&=& \frac{f(2)-2f(1)-f(0)}{2} \\
&=& \frac{\left( f(2)-f(1) \right) -\left(f(1)-f(0) \right)}{2} =: \frac{\Delta^2(f)(0)}{2} \\
\nonumber
&\vdots&\\
a_r &=& \frac{\Delta^r(f)(0)}{r!},
\end{eqnarray}
where $\Delta$ is the difference operator in eq.(\ref{difference}):
\begin{eqnarray}
\Delta(f)(n) := f(n+1) - f(n).
\end{eqnarray}

In order to simplify our expression, we introduce a falling power:
\begin{eqnarray}
(x)_0 &:=& 1 \\
(x)_n &:=& x(x-1) \cdots (x-n+1) \\
&=& \prod_{i=0}^{n-1} (x-i).
\end{eqnarray}

Under these settings, we have
\begin{eqnarray}
f(z) &=& f_R(z) \\
&=& \sum_{r=0}^R \frac{\Delta^r(f)(0)}{r!} (x)_r,
\end{eqnarray}
where we have assume
\begin{eqnarray}
\Delta^{R+1}(f) = [0,0,\cdots].
\end{eqnarray}


\subsubsection{Example}
Consider a polynomial
\begin{eqnarray}
f(z) := 2*z^3+3*z,
\end{eqnarray}
and its out put list
\begin{eqnarray}
\left[ f(0), f(1), f(3), \cdots\right] = \left[0,5,22,63,140,265, \cdots \right]
\end{eqnarray}
This polynomial is 3rd degree, so we compute up to $\Delta^3(f)(0)$:
\begin{eqnarray}
f(0) &=& 0 \\
\Delta(f)(0) &=& f(1) - f(0) = 5\\
\nonumber
\Delta^2(f)(0) &=& \Delta(f)(1) - \Delta(f)(0) \\
&=& f(2) - f(1) - 5 = 22 -5 -5= 12 \\
\nonumber
\Delta^3(f)(0) &=& \Delta^2(f)(1) - \Delta^2(f)(0) \\
&=& f(3)-f(2) - \left\{ f(2) - f(1)\right\} - 12 = 12
\end{eqnarray}
so we get
\begin{eqnarray}
\label{exOfDiff}
\left[0,5,12,12\right]
\end{eqnarray}
as the first difference list.
Therefore, we get the falling power representation of $f$:
\begin{eqnarray}
f(z) &=& 5(x)_1 + \frac{12}{2}(x)_2 + \frac{12}{3!}(x)_3 \\
\label{exOfNewton} &=&  5(x)_1 + 6(x)_2 + 2(x)_3.
\end{eqnarray}

\section{Univariate polynomial reconstruction with Haskell}
\subsection{Newton interpolation formula with Haskell}
First, the falling power is naturally given by recursively:
\begin{verbatim}
> infixr 8 ^- -- falling power
> (^-) :: (Integral a) => a -> a -> a
> x ^- 0 = 1
> x ^- n = (x ^- (n-1)) * (x - n + 1)
\end{verbatim}

Assume the differences are given in a list
\begin{eqnarray}
\texttt{xs} = \left[f(0), \Delta(f)(0), \Delta^2(f)(0), \cdots \right].
\end{eqnarray}
Then the implementation of the Newton interpolation formula is as follows:
\begin{verbatim}
> newtonC :: (Fractional t, Enum t) => [t] -> [t]
> newtonC xs = [x / factorial k | (x,k) <- zip xs [0..]]
>   where
>     factorial k = product [1..fromInteger k]
\end{verbatim}
Consider a polynomial
\begin{eqnarray}
\verb|f x = 2*x^3+3*x|
\end{eqnarray}
Let us try to reconstruct this polynomial from output list.
In order to get the list \verb+[x_0, x_1 ..]+, take \texttt{difLists} and pick the first elements:
\begin{verbatim}
  > let f x = 2*x^3+3*x
  > take 10 $ map f [0..]
  [0,5,22,63,140,265,450,707,1048,1485]
  > difLists [it]
  [[12,12,12,12,12,12,12]
  ,[12,24,36,48,60,72,84,96]
  ,[5,17,41,77,125,185,257,341,437]
  ,[0,5,22,63,140,265,450,707,1048,1485]
  ]
  > reverse $ map head it
  [0,5,12,12]
\end{verbatim}
This list is the same as eq.(\ref{exOfDiff}) and we get the same expression as eq.(\ref{exOfNewton}) $5(x)_1 + 6(x)_2 + 2(x)_3$:
\begin{verbatim}  
  > newtonC it
  [0 % 1,5 % 1,6 % 1,2 % 1]
\end{verbatim}

The list of first differences, i.e.,
\begin{eqnarray}
\left[ f(0), \Delta(f)(0), \Delta^2(f)(0), \cdots \right]
\end{eqnarray}
can be computed as follows:
\begin{verbatim}
> firstDifs :: (Eq a, Num a) => [a] -> [a]
> firstDifs xs = reverse $ map head $ difLists [xs]
\end{verbatim}
Mapping a list of integers to a Newton representation:
\begin{verbatim}
> list2npol :: (Integral a) => [Ratio a] -> [Ratio a]
> list2npol = newtonC . firstDifs

  *NewtonInterpolation> take 10 $ map f [0..]
  [0,5,22,63,140,265,450,707,1048,1485]
  *NewtonInterpolation> list2npol it
  [0 % 1,5 % 1,6 % 1,2 % 1]
\end{verbatim}
Therefore, we get the Newton coefficients from the output list.

\subsection{Stirling numbers of the first kind}
We need to map Newton falling powers to standard powers to get the canonical representation.  
This is a matter of applying combinatorics, by means of a convention formula that uses the so-called Stirling cyclic numbers 
\begin{eqnarray}
\left[\begin{array}{c}n \\k \end{array}\right]
\end{eqnarray}
Its defining relation is, $\forall n > 0$,
\begin{eqnarray}
(x)_n = \sum_{k=1}^n (-)^{n-k} \left[\begin{array}{c}n \\k \end{array}\right] x^k, 
\end{eqnarray}
and
\begin{eqnarray}
\left[\begin{array}{c}0 \\0 \end{array}\right] := 1.
\end{eqnarray}
From the highest order, $x^n$, we get
\begin{eqnarray}
\left[\begin{array}{c}n \\n \end{array}\right] = 1, \forall n > 0.
\end{eqnarray}
We also put
\begin{eqnarray}
\left[\begin{array}{c}0 \\1 \end{array}\right] = \left[\begin{array}{c}0 \\2 \end{array}\right] = \left[\begin{array}{c}0 \\3 \end{array}\right] = \cdots = 0,
\end{eqnarray}
and
\begin{eqnarray}
\left[\begin{array}{c}1 \\ 0 \end{array}\right] = \left[\begin{array}{c}2  \\ 0 \end{array}\right] =\left[\begin{array}{c}3 \\ 0 \end{array}\right] = \cdots = 0.
\end{eqnarray}

The key equation is
\begin{eqnarray}
(x)_n = (x)_{n-1}*  (x-n+1)
\end{eqnarray}
and we get
\begin{eqnarray}
(x)_n &=& \sum_{k=1}^n (-)^{n-k} \left[\begin{array}{c}n \\k \end{array}\right] x^k\\
&=& x^n + \sum_{k=1}^{n-1} (-)^{n-k} \left[\begin{array}{c}n \\k \end{array}\right] x^k\\
(x)_{n-1}*  (x-n+1) &=&  \sum_{k=1}^{n-1} (-)^{n-1-k} \left\{ \left[\begin{array}{c}n-1 \\k \end{array}\right] x^{k+1} -(n-1) \left[\begin{array}{c}n-1 \\k \end{array}\right] x^k \right\} \qquad \qquad \\
&=& \sum_{l=2}^n (-)^{n-l} \left[\begin{array}{c}n-1 \\l-1 \end{array}\right] x^l + (n-1)\sum_{k=1}^{n-1} (-)^{n-k} \left[\begin{array}{c}n \\k \end{array}\right] x^k \\
\nonumber &=& x^n + (n-1)(-)^{n-1} x \\
&&+ \sum_{k=2}^{n-1} (-)^{n-k} \left\{ \left[\begin{array}{c}n-1 \\k-1 \end{array}\right]  + (n-1)  \left[\begin{array}{c}n-1 \\k \end{array}\right] \right\} x^k \\
&=& x^n + \sum_{k=1}^{n-1} (-)^{n-k} \left\{ \left[\begin{array}{c}n-1 \\k-1 \end{array}\right]  + (n-1)  \left[\begin{array}{c}n-1 \\k \end{array}\right] \right\} x^k 
\end{eqnarray}
Therefore, $\forall n,k > 0$,
\begin{eqnarray}
\left[\begin{array}{c}n \\k \end{array}\right] = \left[\begin{array}{c}n-1 \\k-1 \end{array}\right]  + (n-1)  \left[\begin{array}{c}n-1 \\k \end{array}\right]
\end{eqnarray}

Now we have the following canonical, power representation of reconstructed polynomial
\begin{eqnarray}
f(z) &=& f_R(z) \\
&=& \sum_{r=0}^R \frac{\Delta^r(f)(0)}{r!} (x)_r \\
&=& \sum_{r=0}^R \frac{\Delta^r(f)(0)}{r!} \sum_{k=1}^r (-)^{r-k} \left[\begin{array}{c}r \\k \end{array}\right] x^k, 
\end{eqnarray}
So, what shall we do is to sum up order by order.

Here is an implementation, first the Stirling numbers:
\begin{verbatim}
> stirlingC :: Integer -> Integer -> Integer
> stirlingC 0 0 = 1
> stirlingC 0 _ = 0
> stirlingC n k = (n-1)*(stirlingC (n-1) k) + stirlingC (n-1) (k-1)
\end{verbatim}
This definition can be used to convert from falling powers to standard powers.
\begin{verbatim}
> fall2pol :: (Integral a) => a -> [a]
> fall2pol 0 = [1]
> fall2pol n = 0   -- No constant term. 
>            : [(-1)^(n-k) * stirlingC n k| k<-[1..n]]
\end{verbatim}
We use \texttt{fall2pol} to convert Newton representations to standard polynomials in coefficients list representation.
Here we have uses \verb+sum+ to collect same order terms in list representation.
\begin{verbatim}
> npol2pol :: (Integral a) => [Ratio a] -> [Ratio a]
> npol2pol xs = sum [ [x] * map fromInteger (fall2pol k)
>                   | (x,k) <- zip xs [0..]
>                   ]
\end{verbatim}

\subsection{\texttt{list2pol}: from output list to canonical coefficients}
Finally, here is the function for computing a polynomial from an output sequence:
\begin{verbatim}
> list2pol :: (Integral a) => [Ratio a] -> [Ratio a]
> list2pol = npol2pol . list2npol
\end{verbatim}
Here are some checks on these functions:
\begin{verbatim}
Reconstruction as curve fitting
  *NewtonInterpolation> list2pol $ map (\n -> 7*n^2+3*n-4) [0..100]
  [(-4) % 1,3 % 1,7 % 1]

  *NewtonInterpolation> list2pol [0,1,5,14,30]
  [0 % 1,1 % 6,1 % 2,1 % 3]
  *NewtonInterpolation> map (\n -> n%6 + n^2%2 + n^3%3) [0..4]
  [0 % 1,1 % 1,5 % 1,14 % 1,30 % 1]

  *NewtonInterpolation> map (p2fct $ list2pol [0,1,5,14,30]) [0..8]
  [0 % 1,1 % 1,5 % 1,14 % 1,30 % 1,55 % 1,91 % 1,140 % 1,204 % 1]

\end{verbatim}
First example shows that from the sufficiently long output list, we can reconstruct the list of coefficients.
Second example shows that from a given outputs, we have a list coefficients.
Then use these coefficients, we define the output list of the function, and they match.
The last example shows that from a limited (but sufficient) output information, we reconstruct a function and get extra outputs outside from the given data.

\section{Univariate rational functions}
We use the same notion, i.e., what we can know is the output-list of a univariate rational function, say \texttt{f::Int -> Ratio Int}:
\begin{eqnarray}
\texttt{map f [0..] == [f 0, f 1 ..]}
\end{eqnarray}

\subsection{Thiele's interpolation formula}
We evaluate the polynomial form $f(z)$ as a continued fraction:
\begin{eqnarray}
f_0(z) &=& a_0 \\
f_1(z) &=& a_0 + \frac{z}{a_1} \\
\nonumber
&\vdots& \\
f_r(z) &=& a_0 + \cfrac{z}{a_1 + \cfrac{z-1}{a_2 + \cfrac{z- 2}{a_{r-2} + \cfrac{\vdots}{a_{r-1} + \cfrac{z-r+1}{a_r}}}}},
\end{eqnarray}
where
\begin{eqnarray}
a_0 &=& f(0) \\
a_1 &=& \frac{1}{f(1) - a_0}\\
a_2 &=& \cfrac{1}{\cfrac{2}{f(2)-a_0} - a_1} \\
\nonumber
&\vdots& \\
a_r &=&\cfrac{1}{\cfrac{2}{\cfrac{3}{\cfrac{\vdots}{\cfrac{r}{f(r)-a_0}-a_1}-a_2} - a_{r-2}} - a_{r-1}} \\
&=& \left( \left( \left( f(r)-a_0 \right)^{-1} r - a_1 \right)^{-1} (r - 1) - \cdots - a_{r-1} \right)^{-1} 1 \qquad\qquad
\end{eqnarray}

\subsection{Towards canonical representations}
In order to get a unique representation of canonical form
\begin{eqnarray}
\frac{\sum_\alpha n_\alpha z^\alpha}{\sum_\beta d_\beta z^\beta}
\end{eqnarray}
we put
\begin{eqnarray}
d_{\min r'} = 1
\end{eqnarray}
as a normalization, instead of $d_0$.
However, if we meet 0 as a singular value, then we can shift s.t. the new $d_0 \neq 0$.
So without loss of generality, we can assume $f(0)$ is not singular, i.e., the denominator of $f$ has a nonzero constant term:
\begin{eqnarray}
d_0 &=& 1\\
f(z) &=& \frac{\sum_i n_i z^i}{1 + \sum_{j >0} d_ z^j}.
\end{eqnarray}

\section{Univariate rational function reconstruction with Haskell}
Here we the same notion of
\begin{quotation}
\url{https://rosettacode.org/wiki/Thiele%27s_interpolation_formula}
\end{quotation}
and especially
\begin{quotation}
\url{https://rosettacode.org/wiki/Thiele%27s_interpolation_formula#C}
\end{quotation}
 
\subsection{Reciprocal difference}
We claim, without proof\footnote{
See the ref.\ref{Numerical}, Theorem (2.2.2.5) in 2nd edition.
}, that the Thiele coefficients are given by
\begin{eqnarray}
a_0 &:=& f(0) \\
a_n &:=& \rho_{n,0} - \rho_{{n-2},0},
\end{eqnarray}
where $\rho$ is so called the reciprocal difference:
\begin{eqnarray}
\rho_{n,i} &:=& 0, n<0 \\
\rho_{0,i} &:=& f(i), i=0,1,2,\cdots \\
\rho_{n,i} &:=& \frac{n}{\rho_{{n-1}, i+1} - \rho_{{n-1},i}} + \rho_{{n-2},i+1}
\end{eqnarray}

These preparation helps us to write the following codes:
\begin{verbatim}
Thiele's interpolation formula

Reciprocal difference rho, using the same notation of 
https://rosettacode.org/wiki/Thiele%27s_interpolation_formula#C

> rho :: [Ratio Int] -- A list of output of f :: Int -> Ratio Int
>     -> Int -> Int -> Ratio Int
> rho fs 0 i = fs !! i
> rho fs n _ 
>   | n < 0 = 0
> rho fs n i = (n*den)%num + rho fs (n-2) (i+1)
>   where
>     num  = numerator next
>     den  = denominator next
>     next = (rho fs (n-1) (i+1)) - (rho fs (n-1) i)

Note that (%) has the following type,
  (%) :: Integral a => a -> a -> Ratio a

> a fs 0 = fs !! 0
> a fs n = rho fs n 0 - rho fs (n-2) 0
\end{verbatim}

\subsection{\texttt{tDegree} for termination}
Now let us consider a simple example which is given by the following Thiele coefficients
\begin{eqnarray}
a_0 = 1, a_1 = 2, a_2 = 3, a_3=4.
\end{eqnarray}
The function is now
\begin{eqnarray}
f(x) &:=& 1 + \cfrac{x}{2+\cfrac{x-1}{3+\cfrac{x-2}{4}}} \\
&=& \frac{x^2+16x+16}{16+6x}
\end{eqnarray}
Using Maxima\footnote{
\url{http://maxima.sourceforge.net}
}, we can verify this:
\begin{verbatim}
  (%i25) f(x) := 1+(x/(2+(x-1)/(3+(x-2)/4)));
  (%o25) f(x):=x/(2+(x-1)/(3+(x-2)/4))+1
  (%i26) ratsimp(f(x));
  (%o26) (x^2+16*x+16)/(16+6*x)
\end{verbatim}
Let us come back Haskell, and try to get the Thiele coefficients of
\begin{verbatim}
  *Univariate> let func x = (x^2 + 16*x + 16)%(6*x + 16)
  *Univariate> let fs = map func [0..]
  *Univariate> map (a fs) [0..]
  [1 % 1,2 % 1,3 % 1,4 % 1,*** Exception: Ratio has zero denominator\end{verbatim}
This is clearly unsafe, so let us think more carefully.
Observe the reciprocal differences
\begin{verbatim}
  *Univariate> let fs = map func [0..]
  *Univariate> take 5 $ map (rho fs 0) [0..]
  [1 % 1,3 % 2,13 % 7,73 % 34,12 % 5]
  *Univariate> take 5 $ map (rho fs 1) [0..]
  [2 % 1,14 % 5,238 % 69,170 % 43,230 % 53]
  *Univariate> take 5 $ map (rho fs 2) [0..]
  [4 % 1,79 % 16,269 % 44,667 % 88,413 % 44]
  *Univariate> take 5 $ map (rho fs 3) [0..]
  [6 % 1,6 % 1,6 % 1,6 % 1,6 % 1]
\end{verbatim}
So, the constancy of the reciprocal differences can be used to get the depth of Thiele series:
\begin{verbatim}
> tDegree :: [Ratio Int] -> Int
> tDegree fs = helper fs 0
>   where
>     helper fs n
>       | isConstants fs' = n
>       | otherwise       = helper fs (n+1)
>       where
>         fs' = map (rho fs n) [0..]
>     isConstants (i:j:_) = i==j -- 2 times match
> --  isConstants (i:j:k:_) = i==j && j==k
\end{verbatim}
Using this \verb+tDegree+ function, we can safely take the (finite) Thiele sequence.

\subsection{\texttt{thieleC}: from output list to Thiele coefficients}
From the equation (3.26) of ref.\ref{Tiziano},
\begin{verbatim}
  *Univariate> let h t = (3+6*t+18*t^2)%(1+2*t+20*t^2)
  *Univariate> let hs = map h [0..]
  *Univariate> tDegree hs
  4
\end{verbatim}
So we get the Thiele coefficients
\begin{verbatim}  
  *Univariate> map (a hs) [0..(tDegree hs)]
  [3 % 1,(-23) % 42,(-28) % 13,767 % 14,7 % 130]
\end{verbatim}
Plug these in the continued fraction, and simplify with Maxima
\begin{verbatim}
  (%i35) h(t):=3+t/((-23/42)+(t-1)/((-28/13)+(t-2)/((767/14)+(t-3)/(7/130))));
  (%o35) h(t):=t/((-23)/42+(t-1)/((-28)/13+(t-2)/(767/14+(t-3)/(7/130))))+3
  (%i36) ratsimp(h(t));
  (%o36) (18*t^2+6*t+3)/(1+2*t+20*t^2)
\end{verbatim}

Finally we make a function \verb+thieleC+ that returns the Thiele coefficients:
\begin{verbatim}
> thieleC :: [Ratio Int] -> [Ratio Int]
> thieleC lst = map (a lst) [0..(tDegree lst)]

  *Univariate> thieleC hs
  [3 % 1,(-23) % 42,(-28) % 13,767 % 14,7 % 130]
\end{verbatim}

We need a convertor from this Thiele sequence to continuous form of rational function.
\begin{verbatim}
> nextStep [a0,a1] (v:_)  = a0 + v/a1
> nextStep (a:as)  (v:vs) = a + (v / nextStep as vs)
>
> -- From thiele sequence to (rational) function.
> thiele2ratf :: Integral a => [Ratio a] -> (Ratio a -> Ratio a)
> thiele2ratf as x
>   | x == 0 = head as
>   | otherwise = nextStep as [x,x-1 ..]
\end{verbatim}
The following example shows that, the given output lists \verb+hs+, we can interpolate the value between our discrete data.
\begin{verbatim}
  *Univariate> let h t = (3+6*t+18*t^2)%(1+2*t+20*t^2)
  *Univariate> let hs = map h [0..]
  *Univariate> take 5 hs
  [3 % 1,27 % 23,87 % 85,183 % 187,45 % 47]
  *Univariate> let as = thieleC hs
  *Univariate> as
  [3 % 1,(-23) % 42,(-28) % 13,767 % 14,7 % 130]
  *Univariate> let th x = thiele2ratf as x
  *Univariate> map th [0..5]
  [3 % 1,27 % 23,87 % 85,183 % 187,45 % 47,69 % 73]
  *Univariate> th 0.5
  3 % 2
\end{verbatim}

\subsection{Haskell representation for rational functions}
We represent a rational function by a tuple of coefficient lists, like,
\begin{eqnarray}
\texttt{(ns,ds) :: ([Ratio Int],[Ratio Int])}
\end{eqnarray}

Here is a translator from coefficients lists to rational function.
\begin{verbatim}
> lists2ratf :: (Integral a) => 
>   ([Ratio a],[Ratio a]) -> (Ratio a -> Ratio a)
> lists2ratf (ns,ds) x = (p2fct ns x)/(p2fct ds x)

  *Univariate> let frac x = lists2ratf ([1,1%2,1%3],[2,2%3]) x
  *Univariate> take 10 $ map frac [0..]
  [1 % 2,11 % 16,1 % 1,11 % 8,25 % 14,71 % 32,8 % 3,25 % 8,79 % 22,65 % 16]
  *Univariate> let ffrac x = (1+(1%2)*x+(1%3)*x^2)/(2+(2%3)*x)
  *Univariate> take 10 $ map ffrac [0..]
  [1 % 2,11 % 16,1 % 1,11 % 8,25 % 14,71 % 32,8 % 3,25 % 8,79 % 22,65 % 16]  
\end{verbatim}
Simply taking numerator and denominator polynomials.

The following \texttt{canonicalizer} reduces the tuple-rep of rational function in canonical form, i.e., the coefficient of the lowest degree term of the denominator to be 1\footnote{
Here our data point start from 0, i.e., the output data is given by \texttt{map f [0..]}, 0 is not singular, i.e., the denominator should have constant term and that means non empty.
Therefore, the function firstNonzero is actually \texttt{head}.
}.
\begin{verbatim}
> canonicalize :: (Integral a) => 
>   ([Ratio a],[Ratio a]) -> ([Ratio a],[Ratio a])
> canonicalize rat@(ns,ds)
>   | dMin == 1 = rat
>   | otherwise = (map (/dMin) ns, map (/dMin) ds)
>   where
>     dMin = firstNonzero ds
>     firstNonzero [a] = a -- head
>     firstNonzero (a:as)
>       | a /= 0 = a
>       | otherwise = firstNonzero as

  *Univariate> canonicalize ([1,1%2,1%3],[2,2%3])
  ([1 % 2,1 % 4,1 % 6],[1 % 1,1 % 3])
  *Univariate> canonicalize ([1,1%2,1%3],[0,0,2,2%3])
  ([1 % 2,1 % 4,1 % 6],[0 % 1,0 % 1,1 % 1,1 % 3])
  *Univariate> canonicalize ([1,1%2,1%3],[0,0,0,2%3])
  ([3 % 2,3 % 4,1 % 2],[0 % 1,0 % 1,0 % 1,1 % 1])
\end{verbatim}

What we need is a translator from Thiele coefficients to this tuple-rep.
Since the list of Thiele coefficients is finite, we can naturally think recursively.

Before we go to a general case, consider
\begin{eqnarray}
f(x) := 1 + \cfrac{x}{2+\cfrac{x-1}{3+\cfrac{x-2}{4}}} 
\end{eqnarray}
When we simplify this expression, we should start from the bottom:
\begin{eqnarray}
f(x) &=& 1 + \cfrac{x}{2+\cfrac{x-1}{\cfrac{4*3+x-2}{4}}} \\
&=& 1 + \cfrac{x}{2+\cfrac{x-1}{\cfrac{x+10}{4}}} \\
&=& 1 + \cfrac{x}{\cfrac{2*(x+10) +4*(x-1)}{x+10}} \\
&=& 1 + \cfrac{x}{\cfrac{6x+16}{x+10}} \\
&=& \frac{1*(6x+16) + x*(x+10)}{6x+16} \\
&=& \frac{x^2+16x+16}{6x+16}
\end{eqnarray}
Finally, if we need, we take its canonical form:
\begin{eqnarray}
f(x) = \frac{1+ x+ \frac{1}{16}x^2}{1+ \frac{3}{8} x}
\end{eqnarray}

In general, we have the following Thiele representation:
\begin{eqnarray}
a_0 + \cfrac{z}{a_1 + \cfrac{z-1}{a_2 + \cfrac{z- 2}{ \cfrac{\vdots}{a_{n} + \cfrac{z-n}{a_{n+1}}}}}}
\end{eqnarray}
The base case should be
\begin{eqnarray}
a_{n}+ \frac{z-n}{a_{n+1}} &=& \frac{a_{n+1}* a_{n}-n + z }{a_{n+1}} 
\end{eqnarray}
and induction step $0 \leq r \leq n$ should be
\begin{eqnarray}
a_{r}(z)
&=&a_{r}+ \frac{z-r}{a_{r+1}(z)} \\
&=& \frac{a_{r}a_{r+1}(z)+ z -r}{a_{r+1}(z)} \\
&=& \frac{a_{r}*\texttt{num}\left(a_{r+1}(z) \right)+ \texttt{den}\left(a_{r+1}(z) \right) * \left(z -r\right)}{\texttt{num}\left(a_{r+1}(z) \right)} 
\end{eqnarray}
where
\begin{eqnarray}
a_{r+1}(z) = \frac{\texttt{num}\left(a_{r+1}(z) \right)}{\texttt{den}\left(a_{r+1}(z) \right)}
\end{eqnarray}
is a canonical representation of $a_{n+1}(z)$\footnote{
Not necessary being a canonical representation, it suffices to express $a_{n+1}(z)$ in a polynomial over polynomial form, that is, two lists in Haskell.
}.

Thus, the implementation is the followings.
\begin{verbatim}
> thiele2coef :: (Integral a) => 
>   [Ratio a] -> ([Ratio a],[Ratio a])
> thiele2coef as = canonicalize $ t2r as 0
>   where
>     t2r [an,an'] n = ([an*an'-n,1],[an'])
>     t2r (a:as)   n = ((a .* num) + ([-n,1] * den), num)
>       where
>         (num, den) = t2r as (n+1)\end{verbatim}

From the first example,
\begin{verbatim}
  *Univariate> let func x = (x^2+16*x+16)%(6*x+16)
  *Univariate> let funcList = map func [0..]
  *Univariate> tDegree funcList 
  3
  *Univariate> take 5 funcList 
  [1 % 1,3 % 2,13 % 7,73 % 34,12 % 5]
  *Univariate> let aFunc = thieleC funcList 
  *Univariate> aFunc
  [1 % 1,2 % 1,3 % 1,4 % 1]
  *Univariate> thiele2coef aFunc
  ([1 % 1,1 % 1,1 % 16],[1 % 1,3 % 8])
\end{verbatim}

From the other example, equation (3.26) of ref.\ref{Tiziano},
\begin{verbatim}
  *Univariate> let h t = (3+6*t+18*t^2)%(1+2*t+20*t^2)
  *Univariate> let hs = map h [0..]
  *Univariate> take 5 hs
  [3 % 1,27 % 23,87 % 85,183 % 187,45 % 47]
  *Univariate> let th x = thiele2ratf as x
  *Univariate> map th [0..5]
  [3 % 1,27 % 23,87 % 85,183 % 187,45 % 47,69 % 73]
  *Univariate> as
  [3 % 1,(-23) % 42,(-28) % 13,767 % 14,7 % 130]
  *Univariate> thiele2coef as
  ([3 % 1,6 % 1,18 % 1],[1 % 1,2 % 1,20 % 1])
\end{verbatim}

\subsection{\texttt{list2rat}: from output list to canonical coefficients}
Finally, we get
\begin{verbatim}
> list2rat :: (Integral a) => [Ratio a] -> ([Ratio a], [Ratio a])
> list2rat = thiele2Coef . thieleC
\end{verbatim}
as the reconstruction function from the output sequence.
\begin{verbatim}
  *Univariate> let h t = (3+6*t+18*t^2)%(1+2*t+20*t^2)
  *Univariate> list2rat $ map h [0..]
  ([3 % 1,6 % 1,18 % 1],[1 % 1,2 % 1,20 % 1])
\end{verbatim}

\section{Multivariate polynomials}
From now on, we will use only the following functions from univariate cases.
\begin{verbatim}
Multivariate.lhs

> module Multivariate 
>   where

> import Data.Ratio
> import Univariate 
>   ( degree, list2pol
>   , thiele2ratf, lists2ratf, thiele2coef, lists2rat
>   )
\end{verbatim}

\subsection{Foldings as recursive applications}
Consider an arbitrary multivariate polynomial
\begin{eqnarray}
f(z_1,\cdots, z_n) \in \mathbb{K}[z_1,\cdots, z_n].
\end{eqnarray}
First, fix all the variable but 1st and apply the univariate Newton's reconstruction:
\begin{eqnarray}
f(z_1, z_2, \cdots, z_n) = \sum_{r=0}^R a_r (z_2,\cdots, z_n) \prod_{i=0}^{r-1}(z_1 - y_i)
\end{eqnarray}
Recursively, pick up one "coefficient" and apply the univariate Newton's reconstruction on $z_2$:
\begin{eqnarray}
a_r(z_2, \cdots, z_n) = \sum_{s=0}^{S} b_s (z_3,\cdots, z_n) \prod_{j=0}^{s-1}(z_2 - x_j)
\end{eqnarray}
The terminate cotndition should be the univariate case.

\subsection{Experiments, 2 variables case}
Let us take a polynomial from the denominator in eq.(3.23) of ref.\ref{Tiziano}.
\begin{eqnarray}
f(z_1,z_2) = 3 + 2z_1 + 4z_2 + 7z_1^2 + 5z_1z_2 + 6z_2^2
\end{eqnarray}
In Haskell, first, fix $z_2=0,1,2$ and identify $f(z_1, 0), f(z_1,1), f(z_1,2)$ as our univariate polynomials.
\begin{verbatim}
  *Multivariate> let f z1 z2 = 3+2*z1+4*z2+7*z1^2+5*z1*z2+6*z2^2
  *Multivariate> let fs z = map (`f` z) [0..]
  *Multivariate> let llst = map fs [0,1,2]
  *Multivariate> map degree llst
  [2,2,2]
\end{verbatim}
Fine, so the canonical form can be
\begin{eqnarray}
f(z_1, z) = c_0(z) + c_1(z)z_1 + c_2(z) z_1^2.
\end{eqnarray}
Now our new target is three univariate polynomials $c_0(z), c_1(z), c_2(z)$.
\begin{verbatim}
  *Multivariate> list2pol $ take 10 $ fs 0
  [3 % 1,2 % 1,7 % 1]
  *Multivariate> list2pol $ take 10 $ fs 1
  [13 % 1,7 % 1,7 % 1]
  *Multivariate> list2pol $ take 10 $ fs 2
  [35 % 1,12 % 1,7 % 1]
\end{verbatim}
That is
\begin{eqnarray}
f(z,0) &=& 3+ 2z+7z^2 \\
f(z,1) &=& 13 + 7z + 7z^2 \\
f(z,2) &=& 35 + 12z + 7z^2.
\end{eqnarray}
From these observation, we can determine $c_2(z)$, since it already a constant sequence.
\begin{eqnarray}
c_2(z) = 7
\end{eqnarray}
Consider $c_1(z)$, the sequence is now enough to determine $c_1(z)$:
\begin{verbatim}
  *Multivariate> degree [2,7,12]
  1
  *Multivariate> list2pol [2,7,12]
  [2 % 1,5 % 1]
\end{verbatim}
i.e.,
\begin{eqnarray}
c_1(z) = 2 + 5z.
\end{eqnarray}
However, for $c_1(z)$
\begin{verbatim}
  *Multivariate> degree [3, 13, 35]
  *** Exception: difLists: lack of data, or not a polynomial
  CallStack (from HasCallStack):
    error, called at ./Univariate.lhs:61:19 in main:Univariate
\end{verbatim}
so we need more numbers.
Let us try one more:
\begin{verbatim}
  *Multivariate> list2pol $ take 10 $ map (`f` 3) [0..]
  [69 % 1,17 % 1,7 % 1]
  *Multivariate> degree [3, 13, 35, 69]
  2
  *Multivariate> list2pol [3,13,35,69]
  [3 % 1,4 % 1,6 % 1]
\end{verbatim}
Thus we have
\begin{eqnarray}
c_0(z) = 3+4z+6z^2
\end{eqnarray}
and these fully determine our polynomial:
\begin{eqnarray}
f(z_1, z_2) = (3+4z_2+6z_2^2) + (2 + 5z_2)z_1 + 7z_1^2.
\end{eqnarray}

As another experiment, take the denominator.
\begin{verbatim}
  *Multivariate> let g x y = 1+7*x + 8*y + 10*x^2 + x*y+9*y^2
  *Multivariate> let gs x = map (g x) [0..]
  *Multivariate> map degree $ map gs [0..3] 
  [2,2,2,2]
\end{verbatim}
So the canonical form should be
\begin{eqnarray}
g(x,y) = c_0(x) + c_1(x)y + c_2(x)y^2
\end{eqnarray}
Let us look at these coefficient polynomial:
\begin{verbatim}
  *Multivariate> list2pol $ take 10 $ gs 0
  [1 % 1,8 % 1,9 % 1]
  *Multivariate> list2pol $ take 10 $ gs 1
  [18 % 1,9 % 1,9 % 1]
  *Multivariate> list2pol $ take 10 $ gs 2
  [55 % 1,10 % 1,9 % 1]
  *Multivariate> list2pol $ take 10 $ gs 3
  [112 % 1,11 % 1,9 % 1]
\end{verbatim}
So we get
\begin{eqnarray}
c_2(x) = 9
\end{eqnarray}
and 
\begin{verbatim}  
  *Multivariate> map (list2pol . (take 10) . gs) [0..4] 
  [[1 % 1,8 % 1,9 % 1]
  ,[18 % 1,9 % 1,9 % 1]
  ,[55 % 1,10 % 1,9 % 1]
  ,[112 % 1,11 % 1,9 % 1]
  ,[189 % 1,12 % 1,9 % 1]
  ]
  *Multivariate> map head it
  [1 % 1,18 % 1,55 % 1,112 % 1,189 % 1]
  *Multivariate> list2pol it
  [1 % 1,7 % 1,10 % 1]
  *Multivariate> list2pol $ map (head . list2pol . (take 10) . gs) [0..4] 
  [1 % 1,7 % 1,10 % 1]
\end{verbatim}
Using index operator \texttt{(!!)},
\begin{verbatim}
  *Multivariate> list2pol $ map ((!! 0) . list2pol . (take 10) . gs) [0..4] 
  [1 % 1,7 % 1,10 % 1]
  *Multivariate> list2pol $ map ((!! 1) . list2pol . (take 10) . gs) [0..4] 
  [8 % 1,1 % 1]
  *Multivariate> list2pol $ map ((!! 2) . list2pol . (take 10) . gs) [0..4] 
  [9 % 1]
\end{verbatim}
Finally we get
\begin{eqnarray}
c_0(x) = 1 + 7x+10x^2, c_1(x) = 8+x, \left( c_2(x) = 9, \right)
\end{eqnarray}
and
\begin{eqnarray}
g(x,y) = (1+7x+10x^2) + (8+x)y + 9y^2
\end{eqnarray}

\subsection{Haskell implementation, 2 variables case}
Let us assume that we are given a "table" of the values of a 2-variate function.
We represent this table as a list of lists.
\begin{verbatim}
  *Multivariate> let f z1 z2 = 3+2*z1+4*z2+7*z1^2+5*z1*z2+6*z2^2
  *Multivariate> [[f x y | y <- [0..9]] | x <- [0..9]]
  [[3,13,35,69,115,173,243,325,419,525]
  ,[12,27,54,93,144,207,282,369,468,579]
  ,[35,55,87,131,187,255,335,427,531,647]
  ,[72,97,134,183,244,317,402,499,608,729]
  ,[123,153,195,249,315,393,483,585,699,825]
  ,[188,223,270,329,400,483,578,685,804,935]
  ,[267,307,359,423,499,587,687,799,923,1059]
  ,[360,405,462,531,612,705,810,927,1056,1197]
  ,[467,517,579,653,739,837,947,1069,1203,1349]
  ,[588,643,710,789,880,983,1098,1225,1364,1515]
  ]

> tablize :: (Enum t1, Num t1) => (t1 -> t1 -> t) -> Int -> [[t]]
> tablize f n = [[f x y | y <- range] | x <- range]
>   where
>     range = take n [0..]
\end{verbatim}
So, this "table" is like
\begin{eqnarray}
\left(\begin{array}{ccc} f_{0,0} & f_{0,1} & \cdots \\ f_{1,0} & f_{1,1} & \cdots \\f_{2,0} & f_{2,1} & \cdots \\ \vdots && \ddots \end{array}\right)
\end{eqnarray}
Then we can apply the univariate technique.
\begin{verbatim}
  *Multivariate> let fTable = tablize f 10
  *Multivariate> map list2pol fTable 
  [[3 % 1,4 % 1,6 % 1]
  ,[12 % 1,9 % 1,6 % 1]
  ,[35 % 1,14 % 1,6 % 1]
  ,[72 % 1,19 % 1,6 % 1]
  ,[123 % 1,24 % 1,6 % 1]
  ,[188 % 1,29 % 1,6 % 1]
  ,[267 % 1,34 % 1,6 % 1]
  ,[360 % 1,39 % 1,6 % 1]
  ,[467 % 1,44 % 1,6 % 1]
  ,[588 % 1,49 % 1,6 % 1]
  ]
\end{verbatim}
Now we need to see the behavior of each coefficient, so take the "transpose" of it:
\begin{verbatim}
> wellOrd :: [[a]] -> [[a]]
> wellOrd xss 
>   | null (head xss) = [] 
>   | otherwise       = map head xss : wellOrd (map tail xss)

  *Multivariate> let f z1 z2 = 3+2*z1+4*z2+7*z1^2+5*z1*z2+6*z2^2
  *Multivariate> let fTable = tablize f 10
  *Multivariate> map list2pol fTable 
  [[3 % 1,4 % 1,6 % 1]
  ,[12 % 1,9 % 1,6 % 1]
  ,[35 % 1,14 % 1,6 % 1]
  ,[72 % 1,19 % 1,6 % 1]
  ,[123 % 1,24 % 1,6 % 1]
  ,[188 % 1,29 % 1,6 % 1]
  ,[267 % 1,34 % 1,6 % 1]
  ,[360 % 1,39 % 1,6 % 1]
  ,[467 % 1,44 % 1,6 % 1]
  ,[588 % 1,49 % 1,6 % 1]
  ]
  *Multivariate> wellOrd it
  [[3 % 1,12 % 1,35 % 1,72 % 1,123 % 1,188 % 1,267 % 1,360 % 1,467 % 1,588 % 1]
  ,[4 % 1,9 % 1,14 % 1,19 % 1,24 % 1,29 % 1,34 % 1,39 % 1,44 % 1,49 % 1]
  ,[6 % 1,6 % 1,6 % 1,6 % 1,6 % 1,6 % 1,6 % 1,6 % 1,6 % 1,6 % 1]
  ]
  *Multivariate> map list2pol it
  [[3 % 1,2 % 1,7 % 1]
  ,[4 % 1,5 % 1]
  ,[6 % 1]]
\end{verbatim}
Therefore, the whole procedure becomes
\begin{verbatim}  
> table2pol :: [[Ratio Integer]] -> [[Ratio Integer]]
> table2pol = map list2pol . wellOrd . map list2pol

  *Multivariate> let g x y = 1+7*x + 8*y + 10*x^2 + x*y+9*y^2
  *Multivariate> table2pol $ tablize g 5
  [[1 % 1,7 % 1,10 % 1],[8 % 1,1 % 1],[9 % 1]]
\end{verbatim}

\section{Multivariate rational functions}
\subsection{The canonical normalization}
Our target is a pair of coefficients $(\{ n_\alpha\}_\alpha, \{ d_\beta\}_\beta)$ in
\begin{eqnarray}
\frac{\sum_\alpha n_\alpha z^\alpha}{\sum_\beta d_\beta z^\beta}
\end{eqnarray}
A canonical choice is
\begin{eqnarray}
d_0 = d_{(0,\cdots,0)} = 1.
\end{eqnarray}
Accidentally we might face $d_0 = 0$, but we can shift our function and make
\begin{eqnarray}
d'_0 = d_{s} \neq 0.
\end{eqnarray}

\subsection{An auxiliary $t$}
Introducing an auxiliary variable $t$, let us define
\begin{eqnarray}
h(z,t) := f(tz_1, \cdots, tz_n),
\end{eqnarray}
and reconstruct $h(t,z)$ as a univariate rational function of $t$:
\begin{eqnarray}
h(z, t) = \frac{\sum_{r=0}^R p_r(z) t^r}{1+ \sum_{r'=1}^{R'} q_{r'}(z) t^{r'}}
\end{eqnarray}
where
\begin{eqnarray}
p_r(z) &=& \sum_{|\alpha| = r} n_\alpha z^\alpha \\
q_{r'}(z) &=& \sum_{|\beta| = r'} n_\beta z^\beta
\end{eqnarray}
are homogeneous polynomials.

Thus, what we shall do is the (homogeneous) polynomial reconstructions of $\left. p_r(z) \right|_{0 \leq r \leq R}, \left. q_{r'} \right|_{1 \leq r' \leq R'}$.

\subsubsection{A simplification}
Since our new targets are homogeneous polynomials, we can consider, say,
\begin{eqnarray}
p_r(1, z_2, \cdots, z_n)
\end{eqnarray}
instead of $p_r(z_1, z_2, \cdots, z_n)$, reconstruct it using multivariate Newton's method, and homogenize with $z_1$.

\subsection{Experiments, 2 variables case}
Consider the equation (3.23) in ref.\ref{Tiziano}.
\begin{verbatim}
  *Multivariate> let f x y = (3+2*x+4*y+7*x^2+5*x*y+6*y^2)
                              % (1+7*x+8*y+10*x^2+x*y+9*y^2)
  *Multivariate> :t f
  f :: Integral a => a -> a -> Ratio a
  *Multivariate> let h x y t = f (t*x) (t*y)
  *Multivariate> let hs x y = map (h x y) [0..]
  *Multivariate> take 5 $ hs 0 0
  [3 % 1,3 % 1,3 % 1,3 % 1,3 % 1]
  *Multivariate> take 5 $ hs 0 1
  [3 % 1,13 % 18,35 % 53,69 % 106,115 % 177]
  *Multivariate> take 5 $ hs 1 0
  [3 % 1,2 % 3,7 % 11,9 % 14,41 % 63]
  *Multivariate> take 5 $ hs 1 1
  [3 % 1,3 % 4,29 % 37,183 % 226,105 % 127]
\end{verbatim}
Here we have introduced the auxiliary $t$ as third argument.

We take $(x,y) = (1,0), (1,1), (1,2), (1,3)$ and reconstruct them\footnote{Eq.(3.26) in ref.\ref{Tiziano} is different from our reconstruction.
}.
\begin{verbatim}
  *Multivariate> lists2rat $ hs 1 0
  ([3 % 1,2 % 1,7 % 1],[1 % 1,7 % 1,10 % 1])
  *Multivariate> lists2rat $ hs 1 1
  ([3 % 1,6 % 1,18 % 1],[1 % 1,15 % 1,20 % 1])
  *Multivariate> lists2rat $ hs 1 2
  ([3 % 1,10 % 1,41 % 1],[1 % 1,23 % 1,48 % 1])
  *Multivariate> lists2rat $ hs 1 3
  ([3 % 1,14 % 1,76 % 1],[1 % 1,31 % 1,94 % 1])
\end{verbatim}
So we have
\begin{eqnarray}
\label{tizianoExample1}
h(1,0,t) &=& \frac{3+2t+7t^2}{1+7t+10t^2} \\
\label{tizianoExample2}
h(1,1,t) &=& \frac{3+6t+18t^2}{1+15t+20t^2} \\
\label{tizianoExample3}
h(1,2,t) &=& \frac{3+10t+41t^2}{1+23t+48t^2} \\
\label{tizianoExample4}
h(1,3,t) &=& \frac{3+14t+76t^2}{1+31t+94t^2}
\end{eqnarray}
Our next targets are the coefficients as polynomials in $y$ \footnote{
In our example, we take $x=1$ fixed and reproduce $x$-dependence using homogenization
}.

Let us consider numerator first.
This \texttt{list} is Haskell representation for eq.(\ref{tizianoExample1}), eq.(\ref{tizianoExample2}), eq.(\ref{tizianoExample3}) and eq.(\ref{tizianoExample4}).
\begin{verbatim}
  *Multivariate> let list = map (lists2rat . (hs 1)) [0..4]
  *Multivariate> let numf = map fst list
  *Multivariate> list
  [([3 % 1,2 % 1,7 % 1],[1 % 1,7 % 1,10 % 1])
  ,([3 % 1,6 % 1,18 % 1],[1 % 1,15 % 1,20 % 1])
  ,([3 % 1,10 % 1,41 % 1],[1 % 1,23 % 1,48 % 1])
  ,([3 % 1,14 % 1,76 % 1],[1 % 1,31 % 1,94 % 1])
  ,([3 % 1,18 % 1,123 % 1],[1 % 1,39 % 1,158 % 1])
  ]
  *Multivariate> numf
  [[3 % 1,2 % 1,7 % 1]
  ,[3 % 1,6 % 1,18 % 1]
  ,[3 % 1,10 % 1,41 % 1]
  ,[3 % 1,14 % 1,76 % 1]
  ,[3 % 1,18 % 1,123 % 1]
  ]
\end{verbatim}
From this information, we reconstruct each polynomials
\begin{verbatim}
  *Multivariate> list2pol $ map head numf
  [3 % 1]
  *Multivariate> list2pol $ map (head . tail) numf
  [2 % 1,4 % 1]
  *Multivariate> list2pol $ map last numf
  [7 % 1,5 % 1,6 % 1]
\end{verbatim}
that is we have $3, 2+4y, 7+5y+6y^2$ as results.
Similarly,
\begin{verbatim}
  *Multivariate> let denf = map snd list
  *Multivariate> denf
  [[1 % 1,7 % 1,10 % 1]
  ,[1 % 1,15 % 1,20 % 1]
  ,[1 % 1,23 % 1,48 % 1]
  ,[1 % 1,31 % 1,94 % 1]
  ,[1 % 1,39 % 1,158 % 1]
  ]
  *Multivariate> list2pol $ map head denf
  [1 % 1]
  *Multivariate> list2pol $ map (head . tail) denf
  [7 % 1,8 % 1]
  *Multivariate> list2pol $ map last denf
  [10 % 1,1 % 1,9 % 1]
\end{verbatim}
So we get
\begin{eqnarray}
h(1,y,t) = \frac{3 + (2+4y)t + (7+5y+6y^2)t^2}{1 + (7+8y)t + (10+y+9y^2)t^2}
\end{eqnarray}
Finally, we use the homogeneous property for each powers:
\begin{eqnarray}
h(x,y,t) = \frac{3 + (2x+4y)t + (7x^2+5xy+6y^2)t^2}{1 + (7x+8y)t + (10x^2+xy+9y^2)t^2}
\end{eqnarray}
Putting $t=1$, we get
\begin{eqnarray}
f(x,y) &=& h(x,y,1) \\
&=& \frac{3 + (2x+4y) + (7x^2+5xy+6y^2)}{1 + (7x+8y) + (10x^2+xy+9y^2)}
\end{eqnarray}

\subsection{Haskell implementation, 2 variables case}
Assume we have a "table" of data:
\begin{verbatim}
  *Multivariate> let h x y = (3+2*x+4*y+7*x^2+5*x*y+6*y^2) % (1+7*x+8*y+10*x^2+x*y+9*y^2)
  *Multivariate> let auxh x y t = h (t*x) (t*y)
  *Multivariate> let h x y = (3+2*x+4*y+7*x^2+5*x*y+6*y^2)% (1+7*x+8*y+10*x^2+x*y+9*y^2)
  *Multivariate> let auxh x y t = h (t*x) (t*y)

Using the homogenious property, we just take x=1:

  *Multivariate> let auxhs = [map (auxh 1 y) [0..5] | y <- [0..5]]
  *Multivariate> auxhs
  [[3 % 1,2 % 3,7 % 11,9 % 14,41 % 63,94 % 143]
  ,[3 % 1,3 % 4,29 % 37,183 % 226,105 % 127,161 % 192]
  ,[3 % 1,3 % 4,187 % 239,201 % 251,233 % 287,77 % 94]
  ,[3 % 1,31 % 42,335 % 439,729 % 940,425 % 543,1973 % 2506]
  ,[3 % 1,8 % 11,59 % 79,291 % 385,681 % 895,528 % 691]
  ,[3 % 1,23 % 32,155 % 211,1707 % 2302,1001 % 1343,4663 % 6236]
  ]
\end{verbatim}
Now, each list can be seen as a univariate rational function:  
\begin{verbatim}  
  *Multivariate> map list2rat auxhs
  [([3 % 1,2 % 1,7 % 1],[1 % 1,7 % 1,10 % 1])
  ,([3 % 1,6 % 1,18 % 1],[1 % 1,15 % 1,20 % 1])
  ,([3 % 1,10 % 1,41 % 1],[1 % 1,23 % 1,48 % 1])
  ,([3 % 1,14 % 1,76 % 1],[1 % 1,31 % 1,94 % 1])
  ,([3 % 1,18 % 1,123 % 1],[1 % 1,39 % 1,158 % 1])
  ,([3 % 1,22 % 1,182 % 1],[1 % 1,47 % 1,240 % 1])
  ]
  *Multivariate> map fst it
  [[3 % 1,2 % 1,7 % 1]
  ,[3 % 1,6 % 1,18 % 1]
  ,[3 % 1,10 % 1,41 % 1]
  ,[3 % 1,14 % 1,76 % 1]
  ,[3 % 1,18 % 1,123 % 1]
  ,[3 % 1,22 % 1,182 % 1]
  ]
\end{verbatim}
We need to see the behavior of each coefficients:
\begin{verbatim}  
  *Multivariate> wellOrd it
  [[3 % 1,3 % 1,3 % 1,3 % 1,3 % 1,3 % 1]
  ,[2 % 1,6 % 1,10 % 1,14 % 1,18 % 1,22 % 1]
  ,[7 % 1,18 % 1,41 % 1,76 % 1,123 % 1,182 % 1]
  ]
  *Multivariate> map list2pol it
  [[3 % 1],[2 % 1,4 % 1],[7 % 1,5 % 1,6 % 1]]
\end{verbatim}  
So, the numerator is given by
\begin{verbatim}  
  *Multivariate> map list2pol . wellOrd . map (fst . list2rat) $ auxhs
  [[3 % 1],[2 % 1,4 % 1],[7 % 1,5 % 1,6 % 1]]
\end{verbatim}    
and the denominator is
\begin{verbatim}  
  *Multivariate> map list2pol . wellOrd . map (snd . list2rat) $ auxhs
  [[1 % 1],[7 % 1,8 % 1],[10 % 1,1 % 1,9 % 1]]
\end{verbatim}
Thus, we finally get the following function
\begin{verbatim}
> table2ratf table = (t2r fst table, t2r snd table)
>   where
>     t2r third = map list2pol . wellOrd . map (third . list2rat)
  
  *Multivariate> table2ratf auxhs
  ([[3 % 1],[2 % 1,4 % 1],[7 % 1,5 % 1,6 % 1]],[[1 % 1],[7 % 1,8 % 1],[10 % 1,1 % 1,9 % 1]])
\end{verbatim}




\chapter{Functional reconstruction over finite fields}
\section{Univariate polynomials}
We choose our new target the first differences, since once we get it, to reconstruct polynomial is an easy task.
Once we get the first differences of a polynomial, we get the coefficient list by applying \texttt{npol2pol . newtonC} on it.

\subsection{Pre-cook}
We need a convertor, or function-modular which takes function and prime, and returns a function on $\mathbb{Z}_p$.
\begin{verbatim}
> -- Function-modular.
> fmodp :: Integral c => (a -> Ratio c) -> c -> a -> c
> f `fmodp` p = (`modp` p) . f

  *FROverZp> let f x = (1%3) + (3%5)*x + (7%6)*x^2
  *FROverZp> let fs = map f [0..]
  *FROverZp> take 5 $ map (f `fmodp` 101) [0..]
  [34,93,87,16,82]
  *FROverZp> take 5 $ map (`modp` 101) fs
  [34,93,87,16,82]
\end{verbatim}

What we can access is the output list of our target polynomial.
On $\mathbb{Z}_p$, our input is a finite list
\begin{eqnarray}
\texttt{[0,1,2 .. (p-1)]}
\end{eqnarray}
so as the output list.
\begin{verbatim}
> accessibleData :: (Ratio Int -> Ratio Int) -> Int -> [Int]
> accessibleData f p = take p $ map (f `fmodp` p) [0..]
> 
> accessibleData' :: [Ratio Int] -> Int -> [Int]
> accessibleData' fs p = take p $ map (`modp` p) fs
\end{verbatim}

\subsection{Difference analysis on $\mathbb{Z}_p$}
Play the same game over prime field $\mathbb{Z}_p$, i.e., every arithmetic in under $\mod p$.

\begin{verbatim}
Difference analysis over Z_p
Every arithmetic should be on Z_p, i.e., (`mod` p).

> difsp :: Integral b => b -> [b] -> [b]
> difsp p xs = map (`mod` p) (zipWith (-) (tail xs) xs)

  *FROverZp> let f x = (1%3) + (3%5)*x + (7%6)*x^2
  *FROverZp> take 5 $ accessibleData f 101
  [34,93,87,16,82]
  *FROverZp> difsp 101 it
  [59,95,30,66]
  *FROverZp> difsp 101 it
  [36,36,36]
  *FROverZp> difsp 101 it
  [0,0]
\end{verbatim}
Here what we do is, first to take the differences (\texttt{zipWith (-) (tail xs) xs}) and take modular $p$ for all element (\texttt{map (`mod` p)}).
Now we can recursively apply this \texttt{difsp} over our data.
\begin{verbatim}
> difListsp :: Integral b => b -> [[b]] -> [[b]]
> difListsp _ [] = []
> difListsp p xx@(xs:xxs) =
>   if isConst xs then xx
>                 else difListsp p $ difsp p xs : xx
>   where
>     isConst (i:jj@(j:js)) = all (==i) jj
>     isConst _ = error "difListsp: "

  *FROverZp> let f x = (1%3) + (3%5)*x + (7%6)*x^2
  *FROverZp> map head $ difListsp 101 [accessibleData f 101]
  [36,59,34]
\end{verbatim}

\subsection{Eager and lazy degree}
From the above difference analysis on $\mathbb{Z}_p$, we get degree of the polynomial.
Here we have a combination of two degree functions, one is eager and the other lazy:
\begin{verbatim}
Degree, eager and lazy versions

> degreep' p xs = length (difListsp p [xs]) -1
> degreep'Lazy p xs = helper xs 0
>   where
>     helper as@(a:b:c:_) n
>       | a==b && b==c = n -- two times matching
>       | otherwise    = helper (difsp p as) (n+1)
>
> degreep :: Integral b => b -> [b] -> Int
> degreep p xs = let l = degreep'Lazy p xs in
>   degreep' p $ take (l+2) xs

  *FROverZp> let f x = (1%3) + (3%5)*x + (7%6)*x^2
  *FROverZp> let myDeg p = degreep p $ accessibleData f p
  *FROverZp> myDeg 101
  2
  *FROverZp> myDeg 103
  2
  *FROverZp> myDeg 107
  2
  *FROverZp> degreep 101 $ accessibleData 
    (\n -> (1%2)+(2%3)*n+(3%4)*n^2+(6%7)*n^7) 101
  7
\end{verbatim}
Now we can take first differences.
\begin{verbatim}
> firstDifsp :: Integral a => a -> [a] -> [a]
> firstDifsp p xs = reverse $ map head $ difListsp p [xs']
>   where
>     xs' = take n xs
>     n   = 2+ degreep p xs

  *FROverZp> let f x = (1%3) + (3%5)*x + (7%6)*x^2
  *FROverZp> firstDifsp 101 $ accessibleData f 101
  [34,59,36]
  *FROverZp> firstDifsp 101 $ accessibleData 
    (\n -> (1%2)+(2%3)*n+(3%4)*n^2+(6%7)*n^7) 101
  [51,66,59,33,29,58,32,78]
\end{verbatim}

\subsection{Term by term reconstruction}
The output list of \texttt{firstDifsp} are basically the coefficients of Newton representation on $\mathbb{Z}_p$.
So we zip it with our base prime $p$ and map these pair over several primes.
\begin{verbatim}
> wellOrd :: [[a]] -> [[a]]
> wellOrd xss 
>   | null (head xss) = [] 
>   | otherwise       = map head xss : wellOrd (map tail xss)

  *FROverZp> let f x = (1%3) + (3%5)*x + (7%6)*x^2
  *FROverZp> let fps p = accessibleData f p
  *FROverZp> let ourData p = firstDifsp p (fps p)
  *FROverZp> let fivePrimes = take 5 bigPrimes 
  *FROverZp> map (\p -> zip (ourData p) (repeat p)) fivePrimes 
  [[(299158,897473),(867559,897473),(299160,897473)]
  ,[(299166,897497),(329084,897497),(299168,897497)]
  ,[(598333,897499),(388918,897499),(598335,897499)]
  ,[(598345,897517),(29919,897517),(598347,897517)]
  ,[(299176,897527),(329095,897527),(299178,897527)]
  ]
  *FROverZp> wellOrd it
  [[(299158,897473),(299166,897497),(598333,897499)
   ,(598345,897517),(299176,897527)]
  ,[(867559,897473),(329084,897497),(388918,897499)
   ,(29919,897517),(329095,897527)]
  ,[(299160,897473),(299168,897497),(598335,897499)
   ,(598347,897517),(299178,897527)]
  ]
  *FROverZp> :t it
  it :: [[(Int, Int)]]
\end{verbatim}
Finally we get the images of first differences over prime fields.

One minor issue is to change the data type, since our tools (say the functions of Chinese Remainder Theorem) use limit-less integer \texttt{Integer}.
\begin{verbatim}
> toInteger2 :: (Integral a1, Integral a) => (a, a1) -> (Integer, Integer)
> toInteger2 (a,b) = (toInteger a, toInteger b)
\end{verbatim}

Let us take an example:
\begin{verbatim}
  *FROverZp> let f x = (895 % 922) + (1080 % 6931)*x + (2323 % 1248)*x^2
  *FROverZp> let fps p = accessibleData f p
  *FROverZp> let longList = map (map toInteger2) $ wellOrd $ 
    map (\p -> zip (firstDifsp p (fps p)) (repeat p)) bigPrimes 
  *FROverZp> map recCRT' longList 
  [(895 % 922,805479325081)
  ,(17448553 % 8649888,722916888780872419)
  ,(2323 % 624,805479325081)
  ]

This result is consistent to that of on Q:

  *FROverZp> :l Univariate
  [1 of 2] Compiling Polynomials      ( Polynomials.hs, interpreted )
  [2 of 2] Compiling Univariate       ( Univariate.lhs, interpreted )
  Ok, modules loaded: Univariate, Polynomials.
  *Univariate> let f x = (895 % 922) + (1080 % 6931)*x + (2323 % 1248)*x^2
  *Univariate> firstDifs (map f [0..20])
  [895 % 922,17448553 % 8649888,2323 % 624]
\end{verbatim}

\subsection{\texttt{list2polZp}: from the output list to coefficient lists}
Finally we get the function which takes an output list of our unknown univariate polynomial and returns the coefficient.
\begin{verbatim}
> list2firstDifZp' fs = 
>   map recCRT' $ map (map toInteger2) $ wellOrd $ map helper bigPrimes
>   where helper p = zip (firstDifsp p (accessibleData' fs p)) (repeat p)

  *FROverZp> let f x = (895 % 922) + (1080 % 6931)*x + (2323 % 1248)*x^2
  *FROverZp> let fs = map f [0..]
  *FROverZp> list2firstDifZp' fs
  [(895 % 922,805479325081)
  ,(17448553 % 8649888,722916888780872419)
  ,(2323 % 624,805479325081)
  ]
  *FROverZp> map fst it
  [895 % 922,17448553 % 8649888,2323 % 624]
  *FROverZp> newtonC it
  [895 % 922,17448553 % 8649888,2323 % 1248]
  *FROverZp> npol2pol it
  [895 % 922,1080 % 6931,2323 % 1248]

> list2polZp :: [Ratio Int] -> [Ratio Integer]
> list2polZp = npol2pol . newtonC . (map fst) . list2firstDifZp'
\end{verbatim}

\section{TBA Univariate rational functions}


















%%%%%%%%%%

\chapter{Codes}
\section{\texttt{Ffield.lhs}}
\lstinputlisting[caption=Ffield.lhs,label=Ffield]{Ffield.lhs}

\section{\texttt{Polynomials.hs}}
\lstinputlisting[caption=Polynomials.hs,label=Polynomials]{Polynomials.hs}

\section{\texttt{Univariate.lhs}}
\lstinputlisting[caption=Univariate.lhs,label=Univariate]{Univariate.lhs}

\section{\texttt{Multivariate.lhs}}
\lstinputlisting[caption=Multivariate.lhs,label=Multivariate]{Multivariate.lhs}

\section{\texttt{FROverZp.lhs}}
\lstinputlisting[caption=FROverZp.lhs,label=FROverZp]{FROverZp.lhs}


\end{document}