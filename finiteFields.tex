\documentclass[11pt]{book}
\usepackage{amsmath,amssymb}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage[all]{xy}
\usepackage[yyyymmdd]{datetime}
\usepackage{listings}

\usepackage{hyperref}

\DeclareMathOperator*{\colim}{colim}
\DeclareMathOperator*{\coker}{coker}

\begin{document}

\lstset{ language = Haskell
         , numbers = left
         , breaklines = true
         , basicstyle = \small\ttfamily
         }

\newcommand{\Slash}[1]{{\ooalign{\hfil/\crcr$#1$}}}

\title{Finite fields and functional reconstructions}
\author{Ray D. Sameshima}
\date{2016/09/23 $\sim$ \today \, \currenttime}
\maketitle

\tableofcontents

%%%%%%body
\setcounter{chapter}{-1}
\chapter{Preface}
\section{References}
\begin{enumerate}
\item \label{Tiziano}
Scattering amplitudes over finite fields and multivariate functional reconstruction\\
(Tiziano Peraro)\\
\url{https://arxiv.org/pdf/1608.01902.pdf}

\item Haskell Language \\
\url{www.haskell.org}

%\item \url{http://qiita.com/bra_cat_ket/items/205c19611e21f3d422b7}\\
% (Japanese tech support sns)

\item \label{Haskellroad}
The Haskell Road to Logic, Maths and Programming\\ 
(Kees Doets, Jan van Eijck)\\
\url{http://homepages.cwi.nl/~jve/HR/}

\item \label{Numerical}
Introduction to numerical analysis\\ 
(Stoer Josef, Bulirsch Roland)

\end{enumerate}

\section{Set theoretical gadgets}
\subsection{Numbers}
Here is a list of what we assumed that the readers are familiar with:
\begin{enumerate}
\item $\mathbb{N}$ (Peano axiom: $\emptyset, \text{suc}$)
\item $\mathbb{Z}$
\item $\mathbb{Q}$
\item $\mathbb{R}$ (Dedekind cut)
\item $\mathbb{C}$ 
\end{enumerate}

\subsection{Algebraic structures}
\begin{enumerate}
\item Monoid: $(\mathbb{N},+), (\mathbb{N},\times)$
\item Group: $(\mathbb{Z},+), (\mathbb{Z},\times)$
\item Ring: $\mathbb{Z}$
\item Field: $\mathbb{Q}$, $\mathbb{R}$ (continuous), $\mathbb{C}$ (algebraic closed)
\end{enumerate}

\section{Haskell language}
From "A Brief, Incomplete and Mostly Wrong History of Programming Languages":\footnote{
\url{http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html}
}
\begin{quotation}
1990 - A committee formed by Simon Peyton-Jones, Paul Hudak, Philip Wadler, Ashton Kutcher, and People for the Ethical Treatment of Animals creates Haskell, a pure, non-strict, functional language. Haskell gets some resistance due to the complexity of using monads to control side effects. Wadler tries to appease critics by explaining that "a monad is a monoid in the category of endofunctors, what's the problem?" 
\end{quotation}

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=3cm, bb= 0 0 1280 904]{Haskell-Logo.png}
\caption{Haskell's logo, the combinations of $\lambda$ and monad's bind \texttt{>>=}.}
\label{Haskell-Logo}
\end{center}
\end{figure}

Haskell language is a standardized purely functional declarative statically typed programming language.

In declarative languages, we describe "what" or "definition" in its codes, however imperative languages, like C/C++, "how" or "procedure".
\begin{quotation}
Functional languages can be seen as 'executable mathematics'; the notation was designed to be as close as possible to the mathematical way of writing.\footnote{
Algorithms: A Functional Programming Approach (Fethi A. Rabhi, Guy Lapalme)
}
\end{quotation}
Instead of loops, we use (implicit) recursions in functional language.\footnote{Of course, as a best practice, we should use higher order function (in this case \texttt{foldr} or \texttt{foldl}) rather than explicit recursions.
}
\begin{verbatim}
> sum :: [Int] -> Int
> sum []     = 0
> sum (i:is) = i + sum is
\end{verbatim}



%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Basics}
We have assumed living knowledge on (axiomatic, i.e., ZFC) set theory, algebraic structures.

\section{Finite field}
\begin{verbatim}
Ffield.lhs

https://arxiv.org/pdf/1608.01902.pdf

> module Ffield where

> import Data.Ratio 
> import Data.Maybe
> import Data.Numbers.Primes
\end{verbatim}

\subsection{Rings}
A ring $(R,+,*)$ is a structured set $R$ with two binary operations
\begin{eqnarray}
\verb|(+) :: R -> R -> R|\\
\verb|(*) :: R -> R -> R|
\end{eqnarray}
satisfying the following 3 (ring) axioms:
\begin{enumerate}
\item $(R,+)$ is an abelian, i.e., commutative group,
i.e.,
\begin{eqnarray}
\forall a,b,c \in R, (a+b) + c = a + (b + c) & \text{ (associativity for $+$)} \\
\forall a, b, \in R, a+b = b+a & \text{ (commutativity)} \\
\exists 0 \in R, \text{ s.t. } \forall a \in R, a + 0 = a & \text{ (additive identity) } \\
\forall a \in R, \exists (-a) \in R \text{ s.t. } a + (-a) = 0 & \text{ (additive inverse)}
\end{eqnarray}

\item $(R,*)$ is a monoid, i.e.,
\begin{eqnarray}
\forall a,b,c \in R, (a*b) * c = a * (b * c) & \text{ (associativity for $*$)} \\
\exists 1 \in R, \text{ s.t. } \forall a \in R, a * 1 = a = 1*a & \text{ (multiplicative identity) } 
\end{eqnarray}

\item Multiplication is distributive w.r.t addition, i.e., $\forall a,b,c \in R$, 
\begin{eqnarray}
a*(b+c) = (a*b) + (a*c) & \text{ (left distributivity)} \\
(a+b)*c = (a*c) + (b*c) & \text{ (right distributivity)} 
\end{eqnarray}

\end{enumerate}

\subsection{Fields}
A field is a ring $(\mathbb{K},+,*)$ whose non-zero elements form an abelian group under multiplication, i.e., $\forall r \in \mathbb{K}$,
\begin{eqnarray}
r \neq 0 \Rightarrow \exists r^{-1} \in \mathbb{K} \text{ s.t. } r*r^{-1} = 1 = r^{-1}*r.
\end{eqnarray}
A field $\mathbb{K}$ is a finite field iff the underlying set $\mathbb{K}$ is finite.
A field $\mathbb{K}$ is called infinite field iff the underlying set is infinite.

\subsection{An example of finite rings $\mathbb{Z}_n$}
Let $n (>0) \in \mathbb{N}$ be a non-zero natural number.
Then the quotient set
\begin{eqnarray}
\mathbb{Z}_n &:=& \mathbb{Z} / n\mathbb{Z} \\
&\cong& \{0, \cdots, (n-1)\}
\end{eqnarray}
with addition, subtraction and multiplication under modulo $n$ is a ring.\footnote{
Here we have taken an equivalence class, 
\begin{eqnarray}
0 \leq \forall k \leq (n-1), [k] := \{k + n*z | z \in \mathbb{Z} \}
\end{eqnarray}
with the following operations:
\begin{eqnarray}
\left[k \right] + \left[l \right] &:=& \left[k+l\right] \\
\left[k \right] * \left[l \right] &:=& \left[k * l\right]
\end{eqnarray}
This is equivalent to take modular $n$:
\begin{eqnarray}
(k \mod n) + (l \mod n) &:=& (k+l \mod n) \\
(k \mod n) * (l \mod n) &:=& (k*l \mod n).
\end{eqnarray}

}

\subsection{B\'ezout's lemma}
Consider $a,b \in \mathbb{Z}$ be nonzero integers.
Then there exist $x,y \in \mathbb{Z}$ s.t.
\begin{eqnarray}
a*x + b*y = \gcd(a,b),
\end{eqnarray}
where $\gcd$ is the greatest common divisor (function), see \S\ref{gcdDefinition}.
We will prove this statement in \S\ref{exGCD}.

\subsection{Greatest common divisor}
\label{gcdDefinition}
Before the proof, here is an implementation of $\gcd$ using Euclidean algorithm with Haskell language:

\begin{verbatim}
> -- Eucledian algorithm.
> myGCD :: Integral a => a -> a -> a
> myGCD a b
>   | b < 0 = myGCD a (-b)
> myGCD a b
>   | a == b = a
>   | b >  a = myGCD b a
>   | b <  a = myGCD (a-b) b
\end{verbatim}

\subsubsection{Example, by hands}
Let us consider the gcd of 7 and 13.
Since they are primes, the gcd should be 1.
First it binds \texttt{a} with 7 and \texttt{b} with 13, and hit \texttt{b > a}.
\begin{eqnarray}
\texttt{myGCD 7 13 == myGCD 13 7}
\end{eqnarray}
Then it hits main line:
\begin{eqnarray}
\texttt{myGCD 13 7 == myGCD (13-7) 7}
\end{eqnarray}
In order to go to next step, Haskell evaluate $(13-7)$,\footnote{
Since Haskell language adopts lazy evaluation, i.e., call by need, not call by name.
}
and
\begin{eqnarray}
\texttt{myGCD (13-7) 7} &\texttt{==}& \texttt{myGCD 6 7} \\
&\texttt{==}& \texttt{myGCD 7 6} \\
&\texttt{==}& \texttt{myGCD (7-6) 6} \\
&\texttt{==}& \texttt{myGCD 1 6} \\
&\texttt{==}& \texttt{myGCD 6 1}
\end{eqnarray}
Finally it ends with 1:
\begin{eqnarray}
\texttt{myGCD 1 1 == 1} 
\end{eqnarray}

As another example, consider $15$ and $25$:
\begin{eqnarray}
\texttt{myGCD 15 25} &\texttt{==}& \texttt{myGCD 25 15}\\
&\texttt{==}& \texttt{myGCD (25-15) 15}\\
&\texttt{==}& \texttt{myGCD 10 15}\\
&\texttt{==}& \texttt{myGCD 15 10}\\
&\texttt{==}& \texttt{myGCD (15-10) 10}\\
&\texttt{==}& \texttt{myGCD 5 10}\\
&\texttt{==}& \texttt{myGCD 10 5}\\
&\texttt{==}& \texttt{myGCD (10-5) 5}\\
&\texttt{==}& \texttt{myGCD 5 5}\\
&\texttt{==}& \texttt{5}
\end{eqnarray}

\subsubsection{Example, with Haskell}
Let us check simple example using Haskell:
\begin{verbatim}
  *Ffield> myGCD 7 13
  1
  *Ffield> myGCD 7 14
  7
  *Ffield> myGCD (-15) (20)
  5
  *Ffield> myGCD (-299) (-13)
  13
\end{verbatim}
The final result is from
\begin{verbatim}
  *Ffield> 13*23
  299
\end{verbatim}

\subsection{Extended Euclidean algorithm}
\label{exGCD}
Here we treat the extended Euclidean algorithm, this is a constructive solution for B\'ezout's lemma.

As intermediate steps, this algorithm makes sequences of integers $\{r_i\}_i$, $\{s_i\}_i$, $\{t_i\}_i$ and quotients $\{q_i\}_i$ as follows.
The base cases are
\begin{eqnarray}
\left(r_0, s_0, t_0 \right) &:=& (a,1,0) \\
\left(r_1, s_1, t_1 \right) &:=& (b,0,1) 
\end{eqnarray}
and inductively, for $i \geq 2$,
\begin{eqnarray}
q_i &:=& \text{quot}(r_{i-2}, r_{i-1}) \\
r_i &:=& r_{i-2} - q_i * r_{i-1} \\
s_i &:=& s_{i-2} - q_i * s_{i-1} \\
t_i &:=& t_{i-2} - q_i * t_{i-1}.
\end{eqnarray}
The termination condition\footnote{
This algorithm will terminate eventually, since the sequence $\{r_i\}_i$ is non-negative by definition of $q_i$, but strictly decreasing.
Therefore, $\{r_i\}_i$ will meet $0$ in finite step $k$.
} is
\begin{eqnarray}
r_k = 0
\end{eqnarray}
for some $k \in \mathbb{N}$ and
\begin{eqnarray}
\gcd(a,b) &=& r_{k-1} \\
x &=& s_{k-1} \\
y &=& t_{k-1}.
\end{eqnarray}

\subsubsection{Proof}
By definition,
\begin{eqnarray}
\gcd(r_{i-1}, r_i) &=& \gcd(r_{i-1}, r_{i-2} - q_i * r_{i-1}) \\
&=& \gcd(r_{i-1}, r_{i-2})
\end{eqnarray}
and this implies 
\begin{eqnarray}
\gcd(a,b) =: \gcd(r_0, r_1) = \cdots = \gcd(r_{k-1}, 0),
\end{eqnarray}
i.e., 
\begin{eqnarray}
r_{k-1} = \gcd(a,b).
\end{eqnarray}

Next, for $i=0,1$ observe
\begin{eqnarray}
\label{guessOfRational}
a*s_i + b*t_i = r_i.
\end{eqnarray}
Let $i\geq 2$, then
\begin{eqnarray}
r_i &=& r_{i-2}  - q_i * r_{i-1} \\
&=& a*s_{i-2} + b*t_{i-2} - q_i *(a*s_{i-1} + b*t_{i-1} ) \\
&=& a*(s_{i-2} - q_i *s_{i-1}) + b* (t_{i-2} - q_i *t_{i-1} ) \\
&=:& a*s_i + b*t_i.
\end{eqnarray}
Therefore, inductively we get
\begin{eqnarray}
\gcd(a,b) = r_{k-1} = a*s_{k-1} + b*t_{k-1}. =: a*s + b*t.
\end{eqnarray}
This prove B\'ezout's lemma. \\
$\blacksquare$

\subsubsection{Haskell implementation}
\label{exGCDHaskell}
Here I use lazy lists for intermediate lists of $qs,rs,ss,ts$, and pick up (second) last elements for the results.

\label{extendedEuclideanAlgorithm}
\begin{verbatim}
Here we would like to implement the extended Euclidean algorithm.
See the algorithm, examples, and pseudo code at:

  https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm

> exGCD' :: (Integral n) => n -> n -> ([n], [n], [n], [n])
> exGCD' a b = (qs, rs, ss, ts)
>   where
>     qs = zipWith quot rs (tail rs)
>     rs = takeUntil (==0) r'
>     r' = steps a b
>     ss = steps 1 0
>     ts = steps 0 1
>     steps a b = rr
>       where 
>         rr@(_:rs) = a:b: zipWith (-) rr (zipWith (*) qs rs)
>
> takeUntil :: (a -> Bool) -> [a] -> [a]
> takeUntil p = foldr func []
>   where
>     func x xs 
>       | p x = []
>       | otherwise = x : xs
\end{verbatim}
Here we have used so called lazy lists, and higher order function\footnote{
Naively speaking, the function whose inputs and/or outputs are functions is called a higher order function.
}.
The gcd of $a$ and $b$ should be the last element of second list \verb+rs+, and our targets $(s,t)$ are second last elements of last two lists \verb+ss+ and \verb+ts+.
The following example is from wikipedia:
\begin{verbatim}
  *Ffield> exGCD' 240 46
  ([5,4,1,1,2],[240,46,10,6,4,2],[1,0,1,-4,5,-9,23],[0,1,-5,21,-26,47,-120])
\end{verbatim}  
Look at the second lasts of \verb+[1,0,1,-4,5,-9,23],[0,1,-5,21,-26,47,-120]+, i.e., -9 and 47:
\begin{verbatim}  
  *Ffield> gcd 240 46
  2
  *Ffield> 240*(-9) + 46*(47)
  2
\end{verbatim}
It works, and we have other simpler examples:
\begin{verbatim}
  *Ffield> exGCD' 15 25
  ([0,1,1,2],[15,25,15,10,5],[1,0,1,-1,2,-5],[0,1,0,1,-1,3])
  *Ffield> 15 * 2 + 25*(-1)
  5
  *Ffield> exGCD' 15 26
  ([0,1,1,2,1,3],[15,26,15,11,4,3,1],[1,0,1,-1,2,-5,7,-26],[0,1,0,1,-1,3,-4,15])
  *Ffield> 15*7 + (-4)*26
  1
\end{verbatim}
Now what we should do is extract gcd of $a$ and $b$, and $(s,t)$ from the tuple of lists:
\begin{verbatim}
> -- a*x + b*y = gcd a b
> exGcd :: Integral t => t -> t -> (t, t, t)
> exGcd a b = (g, x, y)
>   where
>     (_,r,s,t) = exGCD' a b
>     g = last r
>     x = last . init $ s
>     y = last . init $ t
\end{verbatim}
where the underscore \verb+_+ is a special symbol in Haskell that hits every pattern, since we do not need the quotient list.
So, in order to get gcd and $(s,t)$ we don't need quotients list.
\begin{verbatim}
  *Ffield> exGcd 46 240
  (2,47,-9)
  *Ffield> 46*47 + 240*(-9)
  2
  *Ffield> gcd 46 240
  2
\end{verbatim}

\subsection{Coprime}
Let us define a binary relation as follows:
\begin{verbatim}
  coprime :: Integral a => a -> a -> Bool
  coprime a b = (gcd a b) == 1
\end{verbatim}

\subsection{Corollary (Inverses in $\mathbb{Z}_n$)}
For a non-zero element
\begin{eqnarray}
a \in \mathbb{Z}_n,
\end{eqnarray}
there is a unique number 
\begin{eqnarray}
b \in \mathbb{Z}_n \text{ s.t. } ((a*b) \mod n) = 1
\end{eqnarray}
iff $a$ and $n$ are coprime.

\subsubsection{Proof}
From B\'ezout's lemma, $a$ and $n$ are coprime iff
\begin{eqnarray}
\exists s,t \in \mathbb{Z}, a*s + n*t = 1.
\end{eqnarray}
Therefore
\begin{eqnarray}
\text{$a$ and $n$ are coprime} &\Leftrightarrow& \exists s,t \in \mathbb{Z}, a*s + n*t = 1 \\
&\Leftrightarrow &\exists s,t' \in \mathbb{Z}, a*s = 1 + n*t'.
\end{eqnarray}
This $s$, by taking its modulo $n$ is our $b = a^{-1}$:
\begin{eqnarray}
a*s = 1 \mod n.
\end{eqnarray}
$\blacksquare$

\subsection{Corollary (Finite field $\mathbb{Z}_p$)}
If $p$ is prime, then 
\begin{eqnarray}
\mathbb{Z}_p := \{0, \cdots, (p-1)\}
\end{eqnarray}
with addition, subtraction and multiplication under modulo $n$ is a field.

\subsubsection{Proof}
It suffices to show that 
\begin{eqnarray}
\forall a \in \mathbb{Z}_p, a \neq 0 \Rightarrow \exists a^{-1} \in \mathbb{K} \text{ s.t. } a*a^{-1} = 1 = a^{-1}*a,
\end{eqnarray}
but since $p$ is prime, and
\begin{eqnarray}
\forall a \in \mathbb{Z}_p, a \neq 0 \Rightarrow \texttt{gcd a p == 1}
\end{eqnarray}
so all non-zero element has its inverse in $ \mathbb{Z}_p$.\\
$\blacksquare$

\subsubsection{Example and implementation}
Let us pick 11 as a prime and consider $\mathbb{Z}_{11}$:
\begin{verbatim}
Example Z_{11}

  *Ffield> isField 11
  True
  *Ffield> map (exGcd 11) [0..10]
  [(11,1,0),(1,0,1),(1,1,-5),(1,-1,4),(1,-1,3)
  ,(1,1,-2),(1,-1,2),(1,2,-3),(1,3,-4),(1,-4,5)
  ,(1,1,-1)
  ]
\end{verbatim}
This list of three-tuple let us know the candidate of inverse.
Take the last one, \verb+(1,1,-1)+.
This is the image of \verb+exGcd 11 10+, and 
\begin{eqnarray}
1 = 10*1 + 11*(-1)
\end{eqnarray}
holds.
This suggests -1 is a candidate of the inverse of 10 in $\mathbb{Z}_{11}$:
\begin{eqnarray}
10^{-1} &=& -1 \mod 11 \\
&=& 10 \mod 11
\end{eqnarray}
In fact,
\begin{eqnarray}
10*10 = 11*9+1.
\end{eqnarray}
So, picking up the third elements in tuple and zipping with nonzero elements, we have a list of inverses:
\begin{verbatim}
  *Ffield> map ((`mod` 11) . (\(_,_,x)->x) . exGcd 11) [1..10] 
  [1,6,4,3,9,2,8,7,5,10]
  *Ffield> zip [1..10] it
  [(1,1),(2,6),(3,4),(4,3),(5,9),(6,2),(7,8),(8,7),(9,5),(10,10)]
\end{verbatim}

Let us generalize these flow into a function\footnote{
From \url{https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Maybe.html}:
\begin{quotation}
The Maybe type encapsulates an optional value. 
A value of type Maybe a either contains a value of type a (represented as Just a), or it is empty (represented as Nothing). 
Using Maybe is a good way to deal with errors or exceptional cases without resorting to drastic measures such as error.
\end{quotation}
}:
\begin{verbatim}
> inverses :: Integral a => a -> Maybe [(a,a)]
> inverses n
>   | isPrime n = Just lst -- isPrime n
>   | otherwise = Nothing
>   where
>     lst' = map ((`mod` n) . (\(_,_,c)->c) . exGcd n) [1..(n-1)]
>     lst = zip [1..] lst'
\end{verbatim}
The function \texttt{inverses} returns a list of nonzero number with their inverses if $p$ is prime.

Now we define \texttt{inversep'}\footnote{
Here we have used do-notation, a syntactic sugar for use with monadic expressions.
From \url{https://wiki.haskell.org/Monad}:
\begin{quotation}
Monads in Haskell can be thought of as composable computation descriptions.
\end{quotation}
} whose 1st input is the base $p$ of our ring(field) and 2nd input is an element in $\mathbb{Z}_p$.
\begin{verbatim}
> inversep' :: Int -> Int -> Maybe Int
> inversep' p a = do
>   l <- inverses p
>   let a' = (a `mod` p)
>   return (snd $ l !! (a'-1)) 
   
  *Ffield> inverses' 11
  Just [(1,1),(2,6),(3,4),(4,3),(5,9),(6,2),(7,8),(8,7),(9,5),(10,10)]
\end{verbatim}
However, this is not efficient, and we refactor it as follows:\footnote{
Note that, here we use our Haskell code as a script, and we have not compile it.
Hopefully after compile our code, it become much faster.
}
\begin{verbatim}
> inversep :: Integral a => a -> a -> Maybe a
> inversep p a = let (_,x,y) = exGcd p a in
>   if isPrime p then Just (y `mod` p)
>                else Nothing


  map (inversep' 10007) [1..10006]
  (12.99 secs, 17,194,752,504 bytes)
  map (inversep 10007) [1..10006]
  (1.74 secs, 771,586,416 bytes)
\end{verbatim}


\subsection{A map from $\mathbb{Q}$ to $\mathbb{Z}_p$}
Let $p$ be a prime.
Now we have a map
\begin{eqnarray}
- \mod p : \mathbb{Z} \to \mathbb{Z}_p; a \mapsto (a \mod p),
\end{eqnarray}
and a natural inclusion (or a forgetful map)\footnote{
By introducing this forgetful map, we can use 
\begin{eqnarray}
\times : (\mathbb{Z}, \mathbb{Z}) \to \mathbb{Z} 
\end{eqnarray}
of normal product on $\mathbb{Z}$.
}
\begin{eqnarray}
\text{\textquestiondown} : \mathbb{Z}_p \hookrightarrow \mathbb{Z}.
\end{eqnarray}
Then we can define a map
\begin{eqnarray}
- \mod p : \mathbb{Q} \to \mathbb{Z}_p
\end{eqnarray}
by\footnote{
This is an example of operator overloadings.
}
\begin{eqnarray}
q = \frac{a}{b} \mapsto (q \mod p) := \left( \left( a \times \text{\textquestiondown} \left( b^{-1} \mod p\right) \right) \mod p \right).
\end{eqnarray}

\subsubsection{Example and implementation}
An easy implementation is the followings:\footnote{
The backquotes makes any binary function infix operator.
For example,
\begin{eqnarray}
\texttt{add 1 2 == 1 `add` 2}
\end{eqnarray}
Similarly, use parenthesis we can use an infix binary operator to a function:
\begin{eqnarray}
\texttt{(+) 1 2 == 1 + 2}
\end{eqnarray}
}
\begin{verbatim}
A map from Q to Z_p.

> -- p should be prime.
> modp :: Integral a => Ratio a -> a -> a
> q `modp` p = (a * (bi `mod` p)) `mod` p
>   where
>     (a,b) = (numerator q, denominator q)
>     bi = fromJust $ inversep p b
\end{verbatim}
Let us consider a rational number $\frac{3}{7}$ on a finite field $\mathbb{Z}_{11}$:
\begin{verbatim}
Example: on Z_{11}
Consider (3 % 7).

  *Ffield Data.Ratio> let q = 3 % 7
  *Ffield Data.Ratio> 3 `mod` 11
  3
  *Ffield Data.Ratio> 7 `mod` 11
  7
  *Ffield Data.Ratio> inverses 11
  Just [(1,1),(2,6),(3,4),(4,3),(5,9),(6,2),(7,8),(8,7),(9,5),(10,10)]
\end{verbatim}
For example, pick 7:
\begin{verbatim}  
  *Ffield Data.Ratio> 7*8 == 11*5+1
  True
\end{verbatim}
Therefore, on $\mathbb{Z}_{11}$, $(7^{-1} \mod 11)$ is equal to $(8 \mod 11)$ and
\begin{eqnarray}
\frac{3}{7} \in \mathbb{Q} &\mapsto& (3 \times \text{\textquestiondown}(7^{-1} \mod 11) \mod 11) \\
&&= (3 \times 8) \mod 11 \\
&&= 24 \mod 11 \\
&&= 2 \mod 11.
\end{eqnarray}
Haskell returns the same result
\begin{verbatim}  
  *Ffield Data.Ratio> q `modp` 11
  2
\end{verbatim}
and consistent.

\subsection{Reconstruction from $\mathbb{Z}_p$ to $\mathbb{Q}$}
Consider a rational number $q$ and its image $a \in \mathbb{Z}_p$.
\begin{eqnarray}
a := q \mod p
\end{eqnarray}
The extended Euclidean algorithm can be used for guessing a rational number $q$ from the images $a := q \mod p$ of several primes $p$'s.

At each step, the extended Euclidean algorithm satisfies eq.(\ref{guessOfRational}).
\begin{eqnarray}
a*s_i + p*t_i = r_i
\end{eqnarray}
Therefore
\begin{eqnarray}
r_i = a*s_i \mod p \Leftrightarrow \frac{r_i}{s_i} \mod p = a.
\end{eqnarray}
Hence $\frac{r_i}{s_i}$ is a possible guess for $q$.
We take
\begin{eqnarray}
\label{terminationOfRec}
r_i^2 , s_i^2 < p
\end{eqnarray}
as the termination condition for this reconstruction.

\subsubsection{Haskell implementation}
Let us first try to reconstruct from the image $(\frac{1}{3} \mod p)$ of some prime $p$.
Here we have chosen three primes
\begin{verbatim}
Reconstruction Z_p -> Q
  *Ffield> let q = (1%3)
  *Ffield> take 3 $ dropWhile (<100) primes
  [101,103,107]
\end{verbatim}
The images are basically given by the first elements of second lists ($s_0$'s):
\begin{verbatim}  
  *Ffield> q `modp` 101
  34
  *Ffield> let try x = exGCD' (q `modp` x) x
  *Ffield> try 101
  ([0,2,1,33],[34,101,34,33,1],[1,0,1,-2,3,-101],[0,1,0,1,-1,34])
  *Ffield> try 103
  ([0,1,2,34],[69,103,69,34,1],[1,0,1,-1,3,-103],[0,1,0,1,-2,69])
  *Ffield> try 107
  ([0,2,1,35],[36,107,36,35,1],[1,0,1,-2,3,-107],[0,1,0,1,-1,36])  
\end{verbatim}
Look at the first hit of termination condition eq.(\ref{terminationOfRec}), $r_4=1$ and $s_4=3$.
They give us the same guess $\frac{1}{3}$, and that the reconstructed number.

From the above observations we can make a simple "guess" function:
\begin{verbatim}
> guess :: Integral t =>
>          (t, t)       -- (q `modp` p, p)
>       -> (Ratio t, t)
> guess (a, p) = let (_,rs,ss,_) = exGCD' a p in
>   (select rs ss p, p)
>     where
>       select :: Integral t => [t] -> [t] -> t -> Ratio t
>       select [] _ _ = 0%1
>       select (r:rs) (s:ss) p
>         | s /= 0 && r^2 <= p && s^2 <= p = r%s
>         | otherwise = select rs ss p
\end{verbatim}
We have put a list of big primes as follows.
\begin{verbatim}
> -- Hard code of big primes.
> bigPrimes :: [Int]
> bigPrimes = dropWhile (< 897473) $ takeWhile (<978948) primes  
\end{verbatim}
We choose 3 times match as the termination condition.
\begin{verbatim}
> matches3 :: Eq a => [a] -> a
> matches3 (a:bb@(b:c:cs))
>   | a == b && b == c = a
>   | otherwise        = matches3 bb
\end{verbatim}
Finally, we can check our gadgets.

What we know is a list of (q `modp` p) and prime p for several (big) primes.
\begin{verbatim}
  *Ffield> let q = 10%19
  *Ffield> let knownData = zip (map (modp q) bigPrimes) bigPrimes  
  *Ffield> matches3 $  map (fst . guess) knownData 
  10 % 19
\end{verbatim}
The following is the function we need, its input is the list of tuple which first element is the image in $\mathbb{Z}_p$ and second element is that prime $p$.
\begin{verbatim}
> reconstruct :: Integral a =>
>                [(a, a)]  -- :: [(Z_p, primes)]
>             -> Ratio a
> reconstruct aps = matches3 $ map (fst . guess) aps

Here is a naive test:
  > let qs = [1 % 3,10 % 19,41 % 17,30 % 311,311 % 32
             ,869 % 232,778 % 123,331 % 739]
  > let modmap q = zip (map (modp q) bigPrimes) bigPrimes 
  > let longList = map modmap qs
  > map reconstruct longList 
  [1 % 3,10 % 19,41 % 17,30 % 311,311 % 32
  ,869 % 232,778 % 123,331 % 739]
  > it == qs
  True
\end{verbatim}

As another example, we have slightly involved function:
\begin{verbatim}
> matches3' :: Eq a => [(a, t)] -> (a, t)
> matches3' (a0@(a,_):bb@((b,_):(c,_):cs))
>   | a == b && b == c = a0
>   | otherwise        = matches3' bb
\end{verbatim}
Let us see the first good guess, Haskell tells us that in order to reconstruct, say $\frac{331}{739}$, we should take three primes start from 614693:
\begin{verbatim}
  *Ffield> let knowData q = zip (map (modp q) primes) primes
  *Ffield> matches3' $ map guess $ knowData (331%739)
  (331 % 739,614693)
  (18.31 secs, 12,393,394,032 bytes)
  
  *Ffield> matches3' $ map guess $ knowData (11%13)
  (11 % 13,311)
  (0.02 secs, 2,319,136 bytes)
  *Ffield> matches3' $ map guess $ knowData (1%13)
  (1 % 13,191)
  (0.01 secs, 1,443,704 bytes)
  *Ffield> matches3' $ map guess $ knowData (1%3)
  (1 % 3,13)
  (0.01 secs, 268,592 bytes)
  *Ffield> matches3' $ map guess $ knowData (11%31)
  (11 % 31,1129)
  (0.03 secs, 8,516,568 bytes)
  *Ffield> matches3' $ map guess $ knowData (12%312)
  (1 % 26,709)
\end{verbatim}

\subsection{Chinese remainder theorem}
From wikipedia\footnote{
\url{https://en.wikipedia.org/wiki/Chinese_remainder_theorem}
}
\begin{quotation}
There are certain things whose number is unknown. If we count them by threes, we have two left over; by fives, we have three left over; and by sevens, two are left over. How many things are there? 
\end{quotation}
Here is a solution with Haskell:
\begin{verbatim}
*Ffield> let lst = [n|n<-[0..], mod n 3==2, mod n 5==3, mod n 7==2]
*Ffield> head lst
23
\end{verbatim}
We define an infinite list of natural numbers that satisfy
\begin{eqnarray}
n \mod 3 = 2, n \mod 5 = 3, n \mod 7 = 2.
\end{eqnarray}
Then take the first element, and this is the answer.

\subsubsection{Claim}
The statement for binary case is the following.
Let $n_1, n_2 \in \mathbb{Z}$ be coprime, then for arbitrary $a_1,a_2 \in \mathbb{Z}$, the following a system of equations
\begin{eqnarray}
x &=& a_1 \mod n_1\\
x &=& a_2 \mod n_2
\end{eqnarray}
have a unique solution modular $n_1*n_2$\footnote{
Note that, this is equivalent that there is a unique solution $a$ in
\begin{eqnarray}
0 \leq a < n_1\times n_2.
\end{eqnarray}
}.

\subsubsection{Proof}
(existence) With \S\ref{exGCD}, there are $m_1,m_2 \in \mathbb{Z}$ s.t.
\begin{eqnarray}
n_1 * m_1 + n_2 * m_2 = 1.
\end{eqnarray}
Now we have
\begin{eqnarray}
n_1 * m_1 &=& 1 \mod n_2 \\
n_2 * m_2 &=& 1 \mod n_1
\end{eqnarray}
that is
\begin{eqnarray}
m_1 &=& n_1^{-1} \mod n_2 \\
m_2 &=& n_2^{-1} \mod n_1.
\end{eqnarray}
Then
\begin{eqnarray}
a := a_1 * n_2 * m_2 + a_2 * n_1 * m_1 \mod (n_1*n_2)
\end{eqnarray}
is a solution.

(uniqueness)
If $a'$ is also a solution, then
\begin{eqnarray}
a - a' &=& 0 \mod n_1 \\
a - a' &=& 0 \mod n_2.
\end{eqnarray}
Since $n_1$ and $n_2$ are coprime, i.e., no common divisors, this difference is divisible by $n_1*n_2$, and
\begin{eqnarray}
a - a' = 0 \mod (n_1 * n_2).
\end{eqnarray}
Therefore, the solution is unique modular $n_1*n_2$. \\
$\blacksquare$

\subsubsection{Generalization}
Given $a \in Z_n$ of pairwise coprime numbers
\begin{eqnarray}
n := n_1 * \cdots * n_k,
\end{eqnarray}
a system of equations
\begin{eqnarray}
\left. a_i = a \mod n_i \right|_{i=1}^k
\end{eqnarray}
have a unique solution
\begin{eqnarray}
a = \sum_i m_i a_i \mod n,
\end{eqnarray}
where
\begin{eqnarray}
\left. m_i = \left( \frac{n_i}{n} \mod n_i \right) \frac{n}{n_i} \right|_{i=1}^k.
\end{eqnarray}

\subsubsection{TBA: IMPLEMENTATION}

\section{Polynomials and rational functions}
The following discussion on an arbitrary field $\mathbb{K}$.

\subsection{Notations}
Let $n \in \mathbb{N}$ be positive. 
We use multi-index notation:
\begin{eqnarray}
\alpha = (\alpha_1, \cdots, \alpha_n) \in \mathbb{N}^n.
\end{eqnarray}
A monomial is defined as
\begin{eqnarray}
z^\alpha := \prod_i z_i^{\alpha_i}.
\end{eqnarray}
The total degree of this monomial is given by
\begin{eqnarray}
|\alpha| := \sum_i \alpha_i.
\end{eqnarray}

\subsection{Polynomials and rational functions}
Let $\mathbb{K}$ be a field.
Consider a map
\begin{eqnarray}
f : \mathbb{K}^n \to \mathbb{K}; z \mapsto f(z) := \sum_\alpha c_\alpha z^\alpha,
\end{eqnarray}
where
\begin{eqnarray}
c_\alpha \in \mathbb{K}.
\end{eqnarray}
We call the value $f(z)$ at the dummy $z \in \mathbb{K}^n$ a polynomial:
\begin{eqnarray}
f(z) := \sum_\alpha c_\alpha z^\alpha.
\end{eqnarray}
We denote
\begin{eqnarray}
\mathbb{K}[z] := \left\{ \sum_\alpha c_\alpha z^\alpha \right\}
\end{eqnarray}
as the ring of all polynomial functions in the variable $z$ with $\mathbb{K}$-coefficients.

Similarly, a rational function can be expressed as a ratio of two polynomials $p(z),q(z) \in \mathbb{K}[z]$:
\begin{eqnarray}
\frac{p(z)}{q(z)} = \frac{\sum_\alpha n_\alpha z^\alpha}{\sum_\beta d_\beta z^\beta}.
\end{eqnarray}
We denote
\begin{eqnarray}
\mathbb{K}(z) := \left\{ \frac{\sum_\alpha n_\alpha z^\alpha}{\sum_\beta d_\beta z^\beta} \right\}
\end{eqnarray}
as the field of rational functions in the variable $z$ with $\mathbb{F}$-coefficients.
Similar to fractional numbers, there are several equivalent representation of a rational function, even if we simplify with gcd.
However there still is an overall constant ambiguity.
To have a unique representation, usually we put the lowest degree of term of the denominator to be 1.

\subsection{As data, coefficients list}
We can identify a polynomial
\begin{eqnarray}
\sum_\alpha c_\alpha z^\alpha
\end{eqnarray}
as a set of coefficients
\begin{eqnarray}
\{ c_\alpha\}_{\alpha}.
\end{eqnarray}

Similarly, for a rational function, we can identify
\begin{eqnarray}
\frac{\sum_\alpha n_\alpha z^\alpha}{\sum_\beta d_\beta z^\beta}
\end{eqnarray}
as an ordered pair of coefficients
\begin{eqnarray}
(\{ n_\alpha\}_\alpha, \{ d_\beta\}_\beta).
\end{eqnarray}
However, there still is an overall factor ambiguity even after gcd simplifications.

\section{Haskell implementation of univariate polynomials}
Here we basically follows some part of \S9 of ref.\ref{Haskellroad}, and its addendum\footnote{
See \url{http://homepages.cwi.nl/~jve/HR/PolAddendum.pdf}
}.

\begin{verbatim}
Univariate.lhs

> module Univariate where
> import Data.Ratio
> import Polynomials 
\end{verbatim}

\subsection{A polynomial as a list of coefficients}
Let us start \texttt{instance} declaration, which enable us to use basic arithmetics, e.g., addition and multiplication.
\begin{verbatim}
-- Polynomials.hs
-- http://homepages.cwi.nl/~jve/rcrh/Polynomials.hs

module Polynomials where

default (Integer, Rational, Double) 

-- polynomials, as coefficients lists
instance (Num a, Ord a) => Num [a] where
  fromInteger c = [fromInteger c] 
  -- operator overloading
  negate []     = []
  negate (f:fs) = (negate f) : (negate fs)

  signum [] = []
  signum gs 
    | signum (last gs) < (fromInteger 0) = negate z
    | otherwise = z

  abs [] = []
  abs gs 
    | signum gs == z = gs
    | otherwise      = negate gs

  fs     + []     = fs
  []     + gs     = gs
  (f:fs) + (g:gs) = f+g : fs+gs

  fs     * []     = []
  []     * gs     = []
  (f:fs) * gg@(g:gs) = f*g : (f .* gs + fs * gg)

delta :: (Num a, Ord a) => [a] -> [a]
delta = ([1,-1] *)

shift :: [a] -> [a]
shift = tail 

p2fct :: Num a => [a] -> a -> a
p2fct [] x = 0
p2fct (a:as) x = a + (x * p2fct as x)

comp :: (Eq a, Num a, Ord a) => [a] -> [a] -> [a]
comp _     []      = error ".."
comp []     _      = []
comp (f:fs) g0@(0:gs) = f : gs * (comp fs g0)
comp (f:fs) gg@(g:gs) = ([f] + [g] * (comp fs gg))
                      + (0 : gs * (comp fs gg))

deriv :: Num a => [a] -> [a]
deriv []     = []
deriv (f:fs) = deriv1 fs 1 
  where 
    deriv1 []     _ = []
    deriv1 (g:gs) n = n*g : deriv1 gs (n+1)

\end{verbatim}
Note that the above operators are overloaded, say \texttt{(*)}, \texttt{f*g} is a multiplication of two numbers but \texttt{fs*gg} is a multiplication of two list of coefficients.
We can not extend this overloading to scalar multiplication, since Haskell type system takes the operands of \texttt{(*)} the same type
\begin{eqnarray}
\verb+(*) :: Num a => a -> a -> a+
\end{eqnarray}

\begin{verbatim}
> -- scalar multiplication
> infixl 7 .*
> (.*) :: Num a => a -> [a] -> [a]
> c .* []     = []
> c .* (f:fs) = c*f : c .* fs
\end{verbatim}
Let us see few examples.
If we take a scalar multiplication, say
\begin{eqnarray}
3 * \left( 1+2z+3z^2+4z^3\right)
\end{eqnarray}
the result should be
\begin{eqnarray}
3 * \left( 1+2z+3z^2+4z^3\right)
=
3+6z+9z^2+12z^3
\end{eqnarray}
In Haskell 
\begin{verbatim}
  *Univariate> 3 .* [1,2,3,4]
  [3,6,9,12]
\end{verbatim}
and this is exactly same as map with section:
\begin{verbatim}
  *Univariate> map (3*) [1,2,3,4]
  [3,6,9,12]
\end{verbatim}
When we multiply two polynomials, say
\begin{eqnarray}
(1+2z) * (3+4z+5z^2+6z^3)
\end{eqnarray}
the result should be
\begin{eqnarray}
\nonumber
(1+2z) * (3+4z+5z^2+6z^3)
&=& 1*(3+4z+5z^2+6z^3) + 2z*(3+4z+5z^2+6z^3) \\
\nonumber
&=& 3+(4+2*3)z+(5+2*4)z^2+(6+2*5)z^3 + 2*6 z^4 \\
&=& 3+ 10z + 13z^2 + 16 z^3 + 12 z^4 
\end{eqnarray}
In Haskell,
\begin{verbatim}
  *Univariate> [1,2] * [3,4,5,6]
  [3,10,13,16,12]
\end{verbatim}

Now the (dummy) variable is given as 
\begin{verbatim}
> -- z of f(z), variable
> z :: Num a => [a]
> z = [0,1]
\end{verbatim}

A polynomial of degree $R$ is given by a finite sum of the following form:
\begin{eqnarray}
f(z) := \sum_{i=0}^R c_i z^i.
\end{eqnarray}
Therefore, it is natural to represent $f(z)$ by a list of coefficient $\{c_i\}_i$.
Here is the translator from the coefficient list to a polynomial function:
\begin{verbatim}
> p2fct :: Num a => [a] -> a -> a
> p2fct [] x = 0
> p2fct (a:as) x = a + (x * p2fct as x)
\end{verbatim}
This gives us\footnote{
Here we have used lambda, or so called anonymous function.
From\\
\url{http://learnyouahaskell.com/higher-order-functions}
\begin{quote}
To make a lambda, we write a \textbackslash (because it kind of looks like the greek letter lambda if you squint hard enough) and then we write the parameters, separated by spaces. 
\end{quote}
For example,
\begin{eqnarray}
f(x) &:=& x^2 + 1 \\
f &:=& \lambda x. x^2+1
\end{eqnarray}
are the same definition.
}
\begin{verbatim}
*Univariate> take 10 $ map (p2fct [1,2,3]) [0..]
[1,6,17,34,57,86,121,162,209,262]
*Univariate> take 10 $ map (\n -> 1+2*n+3*n^2) [0..]
[1,6,17,34,57,86,121,162,209,262]
\end{verbatim}

\subsection{Difference analysis}
We do not know in general this canonical form of the polynomial, nor the degree.
That means, what we can access is the graph of $f$, i.e., the list of inputs and outputs.
Without loss of generality, we can take
\begin{eqnarray}
\texttt{[0..]}
\end{eqnarray}
as the input data.
Usually we take a finite sublist of this, but we assume it is sufficiently long.
The outputs should be
\begin{eqnarray}
\texttt{map f [0..] = [f 0, f 1 ..]}
\end{eqnarray}
For example
\begin{verbatim}
*Univariate> take 10 $ map (\n -> n^2+2*n+1) [0..]
[1,4,9,16,25,36,49,64,81,100]
\end{verbatim}

Let us consider the difference sequence
\begin{eqnarray}
\label{difference}
\Delta(f) (n) := f(n+1) - f(n).
\end{eqnarray}
Its Haskell version is
\begin{verbatim}
> -- difference analysis
> difs :: (Num a) => [a] -> [a]
> difs [] = []
> difs [_] = []
> difs (i:jj@(j:js)) = j-i : difs jj
\end{verbatim}
This gives
\begin{verbatim}
*Univariate> difs [1,4,9,16,25,36,49,64,81,100]
[3,5,7,9,11,13,15,17,19]
*Univariate> difs [3,5,7,9,11,13,15,17,19]
[2,2,2,2,2,2,2,2]
\end{verbatim}

We claim that if $f(z)$ is a polynomial of degree $R$, then $\Delta(f)(z)$ is a polynomial of degree $R-1$.
Since the degree is given, we can write $f(z)$ in canonical form
\begin{eqnarray}
f(n) = \sum_{i=0}^R c_i n^i
\end{eqnarray}
and
\begin{eqnarray}
\Delta(f)(n) &:=& f(n+1) - f(n) \\
&=& \sum_{i=0}^R c_i \left\{ (n+1)^i - n^i\right\} \\
&=& \sum_{i=1}^R c_i \left\{ (n+1)^i - n^i\right\} \\
&=& \sum_{i=1}^R c_i \left\{ i*n^{i-1} + O(n^{i-2}) \right\} \\
&=& c_R*R*n^{R-1} + O(n^{R-2})
\end{eqnarray}
where $O(n^{i-2})$ is some polynomial(s) of degree $i-2$.

This guarantees the following function will terminate in finite steps\footnote{
If a given lists is generated by a polynomial.
}; \texttt{difLists} keeps generating difference lists until the difference get constant.
\begin{verbatim}
> difLists :: (Eq a, Num a) => [[a]] -> [[a]]
> difLists [] = []
> difLists xx@(xs:xss) =
>   if isConst xs then xx
>                 else difLists $ difs xs : xx
>   where
>     isConst (i:jj@(j:js)) = all (==i) jj
>     isConst _ = error "difLists: lack of data, or not a polynomial"
\end{verbatim}
Let us try:
\begin{verbatim}
  *Univariate> difLists [[-12,-11,6,45,112,213,354,541,780,1077]]
  [[6,6,6,6,6,6,6]
  ,[16,22,28,34,40,46,52,58]
  ,[1,17,39,67,101,141,187,239,297]
  ,[-12,-11,6,45,112,213,354,541,780,1077]
  ]
\end{verbatim}

The degree of the polynomial can be computed by difference analysis:
\begin{verbatim}
> degree' :: (Eq a, Num a) => [a] -> Int
> degree' xs = length (difLists [xs]) -1
\end{verbatim}
For example,
\begin{verbatim}
*Univariate> degree [1,4,9,16,25,36,49,64,81,100]
2
*Univariate> take 10 $ map (\n -> n^2+2*n+1) [0..]
[1,4,9,16,25,36,49,64,81,100]
*Univariate> degree $ take 10 $ map (\n -> n^5+4*n^3+1) [0..]
5
\end{verbatim}

Above \verb+degree'+ function can only treat finite list, however, the following function can compute the degree of infinite list.
\begin{verbatim} 
> degreeLazy :: (Eq a, Num a) => [a] -> Int
> degreeLazy xs = helper xs 0
>   where
>     helper as@(a:b:c:_) n
>       | a==b && b==c = n
>       | otherwise    = helper (difs as) (n+1)
\end{verbatim}
Note that this lazy function only sees the first two elements of the list (of difference).
So first take the lazy \verb+degreeLazy+ and guess the degree, take sufficient finite sublist of output and apply \verb+degree'+.
Here is the hybrid version:
\begin{verbatim}
> degree :: (Num a, Eq a) => [a] -> Int
> degree xs = let l = degreeLazy xs in
>   degree' $ take (l+2) xs
\end{verbatim}

\chapter{Functional reconstruction over $\mathbb{Q}$}
The goal of a functional reconstruction algorithm is to identify the monomials appearing in their definition and the corresponding coefficients.

From here, we use $\mathbb{Q}$ as our base field, but every algorithm can be computed on any field, e.g., finite field $\mathbb{Z}_p$.

\section{Univariate polynomials}
\subsection{Newtons' polynomial representation}
Consider a univariate polynomial $f(z)$.
Given a sequence of distinct values $\left. y_n \right|_{n \in \mathbb{N}}$, we evaluate the polynomial form $f(z)$ sequentially:
\begin{eqnarray}
f_0(z) &=& a_0 \\
f_1(z) &=& a_0 + (z-y_0)a_1 \\
\nonumber
&\vdots& \\
f_r(z) &=& a_0 + (z-y_0) \left(a_1 + (z-y_1)(\cdots + (z - y_{r-1})a_r \right) \\
&=& f_{r-1}(z) + (z-y_0) (z-y_1) \cdots (z - y_{r-1})a_r,
\end{eqnarray}
where
\begin{eqnarray}
a_0 &=& f(y_0) \\
a_1 &=& \frac{f(y_1) - a_0}{y_1 - y_0} \\
\nonumber
&\vdots& \\
a_r &=& \left( \left( \left( f(y_r)-a_0 \right)\frac{1}{y_r - y_0} - a_1 \right)\frac{1}{y_r - y_1} - \cdots - a_{r-1} \right) \frac{1}{y_r - y_{r-1}} \qquad
\end{eqnarray}
It is easy to see that, $f_r(z)$ and the original $f(z)$ match on the given data points, i.e.,
\begin{eqnarray}
f_r(n) = f(n), 0 \leq n \leq r.
\end{eqnarray}

When we have already known the total degree of $f(z)$, say $R$, then we can terminate this sequential trial:
\begin{eqnarray}
f(z) &=& f_R(z) \\
&=& \sum_{r=0}^R a_r \prod_{i=0}^{r-1}(z - y_i).
\end{eqnarray}

In practice, a consecutive zero on the sequence $a_r$ can be taken as the termination condition for this algorithm.\footnote{
We have not proved, but higher power will be dominant when we take sufficiently big input, so we terminate this sequence when we get a consecutive zero in $a_r$.
}

\subsection{Towards canonical representations}
Once we get the Newton's representation
\begin{eqnarray}
\sum_{r=0}^R a_r \prod_{i=0}^{r-1}(z - y_i) = a_0 + (z-y_0) \left(a_1 + (z-y_1)(\cdots + (z - y_{R-1})a_R \right) \quad
\end{eqnarray}
as the reconstructed polynomial, it is convenient to convert it into the canonical form:
\begin{eqnarray}
\sum_{r=0}^R c_r z^r.
\end{eqnarray}
This conversion only requires addition and multiplication of univariate polynomials.
These operations are reasonably cheap, especially on $\mathbb{Z}_p$. 

\subsection{Simplification of our problem}
Without loss of generality, we can put 
\begin{eqnarray}
\texttt{[0..]}
\end{eqnarray}
as our input list. 
We usually take its finite part but we assume it has enough length.
Corresponding to above input,
\begin{eqnarray}
\texttt{map f [0..] = [f 0, f 1, ..]}
\end{eqnarray}
of \texttt{f :: Ratio Int -> Ratio Int} is our output list.

Then we have slightly simpler forms of coefficients:
\begin{eqnarray}
f_r(z) &:=& a_0 + z*\left( a_1 +(z-1)\left(a_2 + (z-2)\left(a_3 + \cdots + (z-r+1)a_r \right) \right) \right) \qquad\qquad \\
a_0 &=& f(0) \\
a_1 &=& f(y_1) - a_0 \\
&=& f(1) - f(0) =: \Delta(f)(0) \\
a_2 &=& \frac{f(2)-a_0}{2}-a_1 \\
&=& \frac{f(2) - f(0)}{2} - \left( f(1) - f(0) \right) \\
&=& \frac{f(2)-2f(1)-f(0)}{2} \\
&=& \frac{\left( f(2)-f(1) \right) -\left(f(1)-f(0) \right)}{2} =: \frac{\Delta^2(f)(0)}{2} \\
\nonumber
&\vdots&\\
a_r &=& \frac{\Delta^r(f)(0)}{r!},
\end{eqnarray}
where $\Delta$ is the difference operator in eq.(\ref{difference}):
\begin{eqnarray}
\Delta(f)(n) := f(n+1) - f(n).
\end{eqnarray}

In order to simplify our expression, we introduce a falling power:
\begin{eqnarray}
(x)_0 &:=& 1 \\
(x)_n &:=& x(x-1) \cdots (x-n+1) \\
&=& \prod_{i=0}^{n-1} (x-i).
\end{eqnarray}

Under these settings, we have
\begin{eqnarray}
f(z) &=& f_R(z) \\
&=& \sum_{r=0}^R \frac{\Delta^r(f)(0)}{r!} (x)_r,
\end{eqnarray}
where we have assume
\begin{eqnarray}
\Delta^{R+1}(f) = [0,0,\cdots].
\end{eqnarray}


\subsubsection{Example}
Consider a polynomial
\begin{eqnarray}
f(z) := 2*z^3+3*z,
\end{eqnarray}
and its out put list
\begin{eqnarray}
\left[ f(0), f(1), f(3), \cdots\right] = \left[0,5,22,63,140,265, \cdots \right]
\end{eqnarray}
This polynomial is 3rd degree, so we compute up to $\Delta^3(f)(0)$:
\begin{eqnarray}
f(0) &=& 0 \\
\Delta(f)(0) &=& f(1) - f(0) = 5\\
\nonumber
\Delta^2(f)(0) &=& \Delta(f)(1) - \Delta(f)(0) \\
&=& f(2) - f(1) - 5 = 22 -5 -5= 12 \\
\nonumber
\Delta^3(f)(0) &=& \Delta^2(f)(1) - \Delta^2(f)(0) \\
&=& f(3)-f(2) - \left\{ f(2) - f(1)\right\} - 12 = 12
\end{eqnarray}
so we get
\begin{eqnarray}
\label{exOfDiff}
\left[0,5,12,12\right]
\end{eqnarray}
as the difference list.
Therefore, we get the falling power representation of $f$:
\begin{eqnarray}
f(z) &=& 5(x)_1 + \frac{12}{2}(x)_2 + \frac{12}{3!}(x)_3 \\
\label{exOfNewton} &=&  5(x)_1 + 6(x)_2 + 2(x)_3.
\end{eqnarray}

\section{Univariate polynomial reconstruction with Haskell}
\subsection{Newton interpolation formula with Haskell}
First, the falling power is naturally given by recursively:
\begin{verbatim}
> infixr 8 ^- -- falling power
> (^-) :: (Integral a) => a -> a -> a
> x ^- 0 = 1
> x ^- n = (x ^- (n-1)) * (x - n + 1)
\end{verbatim}

Assume the differences are given in a list
\begin{eqnarray}
\texttt{xs} = \left[f(0), \Delta(f)(0), \Delta^2(f)(0), \cdots \right].
\end{eqnarray}
Then the implementation of the Newton interpolation formula is as follows:
\begin{verbatim}
> newtonC :: (Fractional t, Enum t) => [t] -> [t]
> newtonC xs = [x / factorial k | (x,k) <- zip xs [0..]]
>   where
>     factorial k = product [1..fromInteger k]
\end{verbatim}
Consider a polynomial
\begin{eqnarray}
\verb|f x = 2*x^3+3*x|
\end{eqnarray}
Let us try to reconstruct this polynomial from output list.
In order to get the list \verb+[x_0, x_1 ..]+, take \texttt{difLists} and pick the first elements:
\begin{verbatim}
  > let f x = 2*x^3+3*x
  > take 10 $ map f [0..]
  [0,5,22,63,140,265,450,707,1048,1485]
  > difLists [it]
  [[12,12,12,12,12,12,12]
  ,[12,24,36,48,60,72,84,96]
  ,[5,17,41,77,125,185,257,341,437]
  ,[0,5,22,63,140,265,450,707,1048,1485]
  ]
  > reverse $ map head it
  [0,5,12,12]
\end{verbatim}
This list is the same as eq.(\ref{exOfDiff}) and we get the same expression as eq.(\ref{exOfNewton}) $5(x)_1 + 6(x)_2 + 2(x)_3$:
\begin{verbatim}  
  > newtonC it
  [0 % 1,5 % 1,6 % 1,2 % 1]
\end{verbatim}

The list of first differences, i.e.,
\begin{eqnarray}
\left[ f(0), \Delta(f)(0), \Delta^2(f)(0), \cdots \right]
\end{eqnarray}
can be computed as follows:
\begin{verbatim}
> firstDifs :: (Eq a, Num a) => [a] -> [a]
> firstDifs xs = reverse $ map head $ difLists [xs]
\end{verbatim}
Mapping a list of integers to a Newton representation:
\begin{verbatim}
> list2npol :: (Integral a) => [Ratio a] -> [Ratio a]
> list2npol = newtonC . firstDifs

  *NewtonInterpolation> take 10 $ map f [0..]
  [0,5,22,63,140,265,450,707,1048,1485]
  *NewtonInterpolation> list2npol it
  [0 % 1,5 % 1,6 % 1,2 % 1]
\end{verbatim}
Therefore, we get the Newton coefficients from the output list.

\subsection{Stirling numbers of the first kind}
We need to map Newton falling powers to standard powers to get the canonical representation.  
This is a matter of applying combinatorics, by means of a convention formula that uses the so-called Stirling cyclic numbers 
\begin{eqnarray}
\left[\begin{array}{c}n \\k \end{array}\right]
\end{eqnarray}
Its defining relation is, $\forall n > 0$,
\begin{eqnarray}
(x)_n = \sum_{k=1}^n (-)^{n-k} \left[\begin{array}{c}n \\k \end{array}\right] x^k, 
\end{eqnarray}
and
\begin{eqnarray}
\left[\begin{array}{c}0 \\0 \end{array}\right] := 1.
\end{eqnarray}
From the highest order, $x^n$, we get
\begin{eqnarray}
\left[\begin{array}{c}n \\n \end{array}\right] = 1, \forall n > 0.
\end{eqnarray}
We also put
\begin{eqnarray}
\left[\begin{array}{c}0 \\1 \end{array}\right] = \left[\begin{array}{c}0 \\2 \end{array}\right] = \left[\begin{array}{c}0 \\3 \end{array}\right] = \cdots = 0,
\end{eqnarray}
and
\begin{eqnarray}
\left[\begin{array}{c}1 \\ 0 \end{array}\right] = \left[\begin{array}{c}2  \\ 0 \end{array}\right] =\left[\begin{array}{c}3 \\ 0 \end{array}\right] = \cdots = 0.
\end{eqnarray}

The key equation is
\begin{eqnarray}
(x)_n = (x)_{n-1}*  (x-n+1)
\end{eqnarray}
and we get
\begin{eqnarray}
(x)_n &=& \sum_{k=1}^n (-)^{n-k} \left[\begin{array}{c}n \\k \end{array}\right] x^k\\
&=& x^n + \sum_{k=1}^{n-1} (-)^{n-k} \left[\begin{array}{c}n \\k \end{array}\right] x^k\\
(x)_{n-1}*  (x-n+1) &=&  \sum_{k=1}^{n-1} (-)^{n-1-k} \left\{ \left[\begin{array}{c}n-1 \\k \end{array}\right] x^{k+1} -(n-1) \left[\begin{array}{c}n-1 \\k \end{array}\right] x^k \right\} \qquad \qquad \\
&=& \sum_{l=2}^n (-)^{n-l} \left[\begin{array}{c}n-1 \\l-1 \end{array}\right] x^l + (n-1)\sum_{k=1}^{n-1} (-)^{n-k} \left[\begin{array}{c}n \\k \end{array}\right] x^k \\
\nonumber &=& x^n + (n-1)(-)^{n-1} x \\
&&+ \sum_{k=2}^{n-1} (-)^{n-k} \left\{ \left[\begin{array}{c}n-1 \\k-1 \end{array}\right]  + (n-1)  \left[\begin{array}{c}n-1 \\k \end{array}\right] \right\} x^k \\
&=& x^n + \sum_{k=1}^{n-1} (-)^{n-k} \left\{ \left[\begin{array}{c}n-1 \\k-1 \end{array}\right]  + (n-1)  \left[\begin{array}{c}n-1 \\k \end{array}\right] \right\} x^k 
\end{eqnarray}
Therefore, $\forall n,k > 0$,
\begin{eqnarray}
\left[\begin{array}{c}n \\k \end{array}\right] = \left[\begin{array}{c}n-1 \\k-1 \end{array}\right]  + (n-1)  \left[\begin{array}{c}n-1 \\k \end{array}\right]
\end{eqnarray}

Now we have the following canonical, power representation of reconstructed polynomial
\begin{eqnarray}
f(z) &=& f_R(z) \\
&=& \sum_{r=0}^R \frac{\Delta^r(f)(0)}{r!} (x)_r \\
&=& \sum_{r=0}^R \frac{\Delta^r(f)(0)}{r!} \sum_{k=1}^r (-)^{r-k} \left[\begin{array}{c}r \\k \end{array}\right] x^k, 
\end{eqnarray}
So, what shall we do is to sum up order by order.

Here is an implementation, first the Stirling numbers:
\begin{verbatim}
> stirlingC :: Integer -> Integer -> Integer
> stirlingC 0 0 = 1
> stirlingC 0 _ = 0
> stirlingC n k = (n-1)*(stirlingC (n-1) k) + stirlingC (n-1) (k-1)
\end{verbatim}
This definition can be used to convert from falling powers to standard powers.
\begin{verbatim}
> fall2pol :: (Integral a) => a -> [a]
> fall2pol 0 = [1]
> fall2pol n = 0   -- No constant term. 
>            : [(-1)^(n-k) * stirlingC n k| k<-[1..n]]
\end{verbatim}
We use \texttt{fall2pol} to convert Newton representations to standard polynomials in coefficients list representation.
Here we have uses \verb+sum+ to collect same order terms in list representation.
\begin{verbatim}
> npol2pol :: (Integral a) => [Ratio a] -> [Ratio a]
> npol2pol xs = sum [ [x] * map fromInteger (fall2pol k)
>                   | (x,k) <- zip xs [0..]
>                   ]
\end{verbatim}

\subsection{\texttt{list2pol}: from output list to canonical coefficients}
Finally, here is the function for computing a polynomial from an output sequence:
\begin{verbatim}
> list2pol :: (Integral a) => [Ratio a] -> [Ratio a]
> list2pol = npol2pol . list2npol
\end{verbatim}
Here are some checks on these functions:
\begin{verbatim}
Reconstruction as curve fitting
  *NewtonInterpolation> list2pol $ map (\n -> 7*n^2+3*n-4) [0..100]
  [(-4) % 1,3 % 1,7 % 1]

  *NewtonInterpolation> list2pol [0,1,5,14,30]
  [0 % 1,1 % 6,1 % 2,1 % 3]
  *NewtonInterpolation> map (\n -> n%6 + n^2%2 + n^3%3) [0..4]
  [0 % 1,1 % 1,5 % 1,14 % 1,30 % 1]

  *NewtonInterpolation> map (p2fct $ list2pol [0,1,5,14,30]) [0..8]
  [0 % 1,1 % 1,5 % 1,14 % 1,30 % 1,55 % 1,91 % 1,140 % 1,204 % 1]

\end{verbatim}
First example shows that from the sufficiently long output list, we can reconstruct the list of coefficients.
Second example shows that from a given outputs, we have a list coefficients.
Then use these coefficients, we define the output list of the function, and they match.
The last example shows that from a limited (but sufficient) output information, we reconstruct a function and get extra outputs outside from the given data.

\section{Univariate rational functions}
We use the same notion, i.e., what we can know is the output-list of a univariate rational function, say \texttt{f::Int -> Ratio Int}:
\begin{eqnarray}
\texttt{map f [0..] == [f 0, f 1 ..]}
\end{eqnarray}

\subsection{Thiele's interpolation formula}
We evaluate the polynomial form $f(z)$ as a continued fraction:
\begin{eqnarray}
f_0(z) &=& a_0 \\
f_1(z) &=& a_0 + \frac{z}{a_1} \\
\nonumber
&\vdots& \\
f_r(z) &=& a_0 + \cfrac{z}{a_1 + \cfrac{z-1}{a_2 + \cfrac{z- 2}{a_{r-2} + \cfrac{\vdots}{a_{r-1} + \cfrac{z-r+1}{a_r}}}}},
\end{eqnarray}
where
\begin{eqnarray}
a_0 &=& f(0) \\
a_1 &=& \frac{1}{f(1) - a_0}\\
a_2 &=& \cfrac{1}{\cfrac{2}{f(2)-a_0} - a_1} \\
\nonumber
&\vdots& \\
a_r &=&\cfrac{1}{\cfrac{2}{\cfrac{3}{\cfrac{\vdots}{\cfrac{r}{f(r)-a_0}-a_1}-a_2} - a_{r-2}} - a_{r-1}} \\
&=& \left( \left( \left( f(r)-a_0 \right)^{-1} r - a_1 \right)^{-1} (r - 1) - \cdots - a_{r-1} \right)^{-1} 1 \qquad\qquad
\end{eqnarray}

\subsection{Towards canonical representations}
In order to get a unique representation of canonical form
\begin{eqnarray}
\frac{\sum_\alpha n_\alpha z^\alpha}{\sum_\beta d_\beta z^\beta}
\end{eqnarray}
we put
\begin{eqnarray}
d_{\min r'} = 1
\end{eqnarray}
as a normalization, instead of $d_0$.
However, if we meet 0 as a singular value, then we can shift s.t. the new $d_0 \neq 0$.
So without loss of generality, we can assume $f(0)$ is not singular, i.e., the denominator of $f$ has a nonzero constant term:
\begin{eqnarray}
d_0 &=& 1\\
f(z) &=& \frac{\sum_i n_i z^i}{1 + \sum_{j >0} d_ z^j}.
\end{eqnarray}

\section{Univariate rational function reconstruction with Haskell}
Here we the same notion of
\begin{quotation}
\url{https://rosettacode.org/wiki/Thiele%27s_interpolation_formula}
\end{quotation}
and especially
\begin{quotation}
\url{https://rosettacode.org/wiki/Thiele%27s_interpolation_formula#C}
\end{quotation}
 
\subsection{Reciprocal difference}
We claim, without proof\footnote{
See the ref.\ref{Numerical}, Theorem (2.2.2.5) in 2nd edition.
}, that the Thiele coefficients are given by
\begin{eqnarray}
a_0 &:=& f(0) \\
a_n &:=& \rho_{n,0} - \rho_{{n-2},0},
\end{eqnarray}
where $\rho$ is so called the reciprocal difference:
\begin{eqnarray}
\rho_{n,i} &:=& 0, n<0 \\
\rho_{0,i} &:=& f(i), i=0,1,2,\cdots \\
\rho_{n,i} &:=& \frac{n}{\rho_{{n-1}, i+1} - \rho_{{n-1},i}} + \rho_{{n-2},i+1}
\end{eqnarray}

These preparation helps us to write the following codes:
\begin{verbatim}
Thiele's interpolation formula

Reciprocal difference rho, using the same notation of 
https://rosettacode.org/wiki/Thiele%27s_interpolation_formula#C

> rho :: [Ratio Int] -- A list of output of f :: Int -> Ratio Int
>     -> Int -> Int -> Ratio Int
> rho fs 0 i = fs !! i
> rho fs n _ 
>   | n < 0 = 0
> rho fs n i = (n*den)%num + rho fs (n-2) (i+1)
>   where
>     num  = numerator next
>     den  = denominator next
>     next = (rho fs (n-1) (i+1)) - (rho fs (n-1) i)

Note that (%) has the following type,
  (%) :: Integral a => a -> a -> Ratio a

> a fs 0 = fs !! 0
> a fs n = rho fs n 0 - rho fs (n-2) 0
\end{verbatim}

\subsection{\texttt{tDegree} for termination}
Now let us consider a simple example which is given by the following Thiele coefficients
\begin{eqnarray}
a_0 = 1, a_1 = 2, a_2 = 3, a_3=4.
\end{eqnarray}
The function is now
\begin{eqnarray}
f(x) &:=& 1 + \cfrac{x}{2+\cfrac{x-1}{3+\cfrac{x-2}{4}}} \\
&=& \frac{x^2+16x+16}{16+6x}
\end{eqnarray}
Using Maxima\footnote{
\url{http://maxima.sourceforge.net}
}, we can verify this:
\begin{verbatim}
  (%i25) f(x) := 1+(x/(2+(x-1)/(3+(x-2)/4)));
  (%o25) f(x):=x/(2+(x-1)/(3+(x-2)/4))+1
  (%i26) ratsimp(f(x));
  (%o26) (x^2+16*x+16)/(16+6*x)
\end{verbatim}
Let us come back Haskell, and try to get the Thiele coefficients of
\begin{verbatim}
  *Univariate> let func x = (x^2 + 16*x + 16)%(6*x + 16)
  *Univariate> let fs = map func [0..]
  *Univariate> map (a fs) [0..]
  [1 % 1,2 % 1,3 % 1,4 % 1,*** Exception: Ratio has zero denominator\end{verbatim}
This is clearly unsafe, so let us think more carefully.
Observe the reciprocal differences
\begin{verbatim}
  *Univariate> let fs = map func [0..]
  *Univariate> take 5 $ map (rho fs 0) [0..]
  [1 % 1,3 % 2,13 % 7,73 % 34,12 % 5]
  *Univariate> take 5 $ map (rho fs 1) [0..]
  [2 % 1,14 % 5,238 % 69,170 % 43,230 % 53]
  *Univariate> take 5 $ map (rho fs 2) [0..]
  [4 % 1,79 % 16,269 % 44,667 % 88,413 % 44]
  *Univariate> take 5 $ map (rho fs 3) [0..]
  [6 % 1,6 % 1,6 % 1,6 % 1,6 % 1]
\end{verbatim}
So, the constancy of the reciprocal differences can be used to get the depth of Thiele series:
\begin{verbatim}
> tDegree :: [Ratio Int] -> Int
> tDegree fs = helper fs 0
>   where
>     helper fs n
>       | isConstants fs' = n
>       | otherwise       = helper fs (n+1)
>       where
>         fs' = map (rho fs n) [0..]
>     isConstants (i:j:_) = i==j -- 2 times match
> --  isConstants (i:j:k:_) = i==j && j==k
\end{verbatim}
Using this \verb+tDegree+ function, we can safely take the (finite) Thiele sequence.

\subsection{\texttt{thieleC}}
From the equation (3.26) of ref.\ref{Tiziano},
\begin{verbatim}
  *Univariate> let h t = (3+6*t+18*t^2)%(1+2*t+20*t^2)
  *Univariate> let hs = map h [0..]
  *Univariate> tDegree hs
  4
\end{verbatim}
So we get the Thiele coefficients
\begin{verbatim}  
  *Univariate> map (a hs) [0..(tDegree hs)]
  [3 % 1,(-23) % 42,(-28) % 13,767 % 14,7 % 130]
\end{verbatim}
Plug these in the continued fraction, and simplify with Maxima
\begin{verbatim}
  (%i35) h(t):=3+t/((-23/42)+(t-1)/((-28/13)+(t-2)/((767/14)+(t-3)/(7/130))));
  (%o35) h(t):=t/((-23)/42+(t-1)/((-28)/13+(t-2)/(767/14+(t-3)/(7/130))))+3
  (%i36) ratsimp(h(t));
  (%o36) (18*t^2+6*t+3)/(1+2*t+20*t^2)
\end{verbatim}

Finally we make a function \verb+thieleC+ that returns the Thiele coefficients:
\begin{verbatim}
> thieleC :: [Ratio Int] -> [Ratio Int]
> thieleC lst = map (a lst) [0..(tDegree lst)]

  *Univariate> thieleC hs
  [3 % 1,(-23) % 42,(-28) % 13,767 % 14,7 % 130]
\end{verbatim}

We need a convertor from this Thiele sequence to continuous form of rational function.
\begin{verbatim}
> nextStep [a0,a1] (v:_)  = a0 + v/a1
> nextStep (a:as)  (v:vs) = a + (v / nextStep as vs)
>
> -- From thiele sequence to (rational) function.
> thiele2ratf :: Integral a => [Ratio a] -> (Ratio a -> Ratio a)
> thiele2ratf as x
>   | x == 0 = head as
>   | otherwise = nextStep as [x,x-1 ..]
\end{verbatim}
The following example shows that, the given output lists \verb+hs+, we can interpolate the value between our discrete data.
\begin{verbatim}
  *Univariate> let h t = (3+6*t+18*t^2)%(1+2*t+20*t^2)
  *Univariate> let hs = map h [0..]
  *Univariate> take 5 hs
  [3 % 1,27 % 23,87 % 85,183 % 187,45 % 47]
  *Univariate> let as = thieleC hs
  *Univariate> as
  [3 % 1,(-23) % 42,(-28) % 13,767 % 14,7 % 130]
  *Univariate> let th x = thiele2ratf as x
  *Univariate> map th [0..5]
  [3 % 1,27 % 23,87 % 85,183 % 187,45 % 47,69 % 73]
  *Univariate> th 0.5
  3 % 2
\end{verbatim}

\subsection{Haskell representation for rational functions}
We represent a rational function by a tuple of coefficient lists, like,
\begin{eqnarray}
\texttt{(ns,ds) :: ([Ratio Int],[Ratio Int])}
\end{eqnarray}

Here is a translator from coefficients lists to rational function.
\begin{verbatim}
> lists2ratf :: (Integral a) => 
>   ([Ratio a],[Ratio a]) -> (Ratio a -> Ratio a)
> lists2ratf (ns,ds) x = (p2fct ns x)/(p2fct ds x)

  *Univariate> let frac x = lists2ratf ([1,1%2,1%3],[2,2%3]) x
  *Univariate> take 10 $ map frac [0..]
  [1 % 2,11 % 16,1 % 1,11 % 8,25 % 14,71 % 32,8 % 3,25 % 8,79 % 22,65 % 16]
  *Univariate> let ffrac x = (1+(1%2)*x+(1%3)*x^2)/(2+(2%3)*x)
  *Univariate> take 10 $ map ffrac [0..]
  [1 % 2,11 % 16,1 % 1,11 % 8,25 % 14,71 % 32,8 % 3,25 % 8,79 % 22,65 % 16]  
\end{verbatim}
Simply taking numerator and denominator polynomials.

The following \texttt{canonicalizer} reduces the tuple-rep of rational function in canonical form, i.e., the coefficient of the lowest degree term of the denominator to be 1\footnote{
Here our data point start from 0, i.e., the output data is given by \texttt{map f [0..]}, 0 is not singular, i.e., the denominator should have constant term and that means non empty.
Therefore, the function firstNonzero is actually \texttt{head}.
}.
\begin{verbatim}
> canonicalize :: (Integral a) => 
>   ([Ratio a],[Ratio a]) -> ([Ratio a],[Ratio a])
> canonicalize rat@(ns,ds)
>   | dMin == 1 = rat
>   | otherwise = (map (/dMin) ns, map (/dMin) ds)
>   where
>     dMin = firstNonzero ds
>     firstNonzero [a] = a -- head
>     firstNonzero (a:as)
>       | a /= 0 = a
>       | otherwise = firstNonzero as

  *Univariate> canonicalize ([1,1%2,1%3],[2,2%3])
  ([1 % 2,1 % 4,1 % 6],[1 % 1,1 % 3])
  *Univariate> canonicalize ([1,1%2,1%3],[0,0,2,2%3])
  ([1 % 2,1 % 4,1 % 6],[0 % 1,0 % 1,1 % 1,1 % 3])
  *Univariate> canonicalize ([1,1%2,1%3],[0,0,0,2%3])
  ([3 % 2,3 % 4,1 % 2],[0 % 1,0 % 1,0 % 1,1 % 1])
\end{verbatim}

What we need is a translator from Thiele coefficients to this tuple-rep.
Since the list of Thiele coefficients is finite, we can naturally think recursively.

Before we go to a general case, consider
\begin{eqnarray}
f(x) := 1 + \cfrac{x}{2+\cfrac{x-1}{3+\cfrac{x-2}{4}}} 
\end{eqnarray}
When we simplify this expression, we should start from the bottom:
\begin{eqnarray}
f(x) &=& 1 + \cfrac{x}{2+\cfrac{x-1}{\cfrac{4*3+x-2}{4}}} \\
&=& 1 + \cfrac{x}{2+\cfrac{x-1}{\cfrac{x+10}{4}}} \\
&=& 1 + \cfrac{x}{\cfrac{2*(x+10) +4*(x-1)}{x+10}} \\
&=& 1 + \cfrac{x}{\cfrac{6x+16}{x+10}} \\
&=& \frac{1*(6x+16) + x*(x+10)}{6x+16} \\
&=& \frac{x^2+16x+16}{6x+16}
\end{eqnarray}
Finally, if we need, we take its canonical form:
\begin{eqnarray}
f(x) = \frac{1+ x+ \frac{1}{16}x^2}{1+ \frac{3}{8} x}
\end{eqnarray}

In general, we have the following Thiele representation:
\begin{eqnarray}
a_0 + \cfrac{z}{a_1 + \cfrac{z-1}{a_2 + \cfrac{z- 2}{ \cfrac{\vdots}{a_{n} + \cfrac{z-n}{a_{n+1}}}}}}
\end{eqnarray}
The base case should be
\begin{eqnarray}
a_{n}+ \frac{z-n}{a_{n+1}} &=& \frac{a_{n+1}* a_{n}-n + z }{a_{n+1}} 
\end{eqnarray}
and induction step $0 \leq r \leq n$ should be
\begin{eqnarray}
a_{r}(z)
&=&a_{r}+ \frac{z-r}{a_{r+1}(z)} \\
&=& \frac{a_{r}a_{r+1}(z)+ z -r}{a_{r+1}(z)} \\
&=& \frac{a_{r}*\texttt{num}\left(a_{r+1}(z) \right)+ \texttt{den}\left(a_{r+1}(z) \right) * \left(z -r\right)}{\texttt{num}\left(a_{r+1}(z) \right)} 
\end{eqnarray}
where
\begin{eqnarray}
a_{r+1}(z) = \frac{\texttt{num}\left(a_{r+1}(z) \right)}{\texttt{den}\left(a_{r+1}(z) \right)}
\end{eqnarray}
is a canonical representation of $a_{n+1}(z)$\footnote{
Not necessary being a canonical representation, it suffices to express $a_{n+1}(z)$ in a polynomial over polynomial form, that is, two lists in Haskell.
}.

Thus, the implementation is the followings.
\begin{verbatim}
> thiele2coef :: (Integral a) => 
>   [Ratio a] -> ([Ratio a],[Ratio a])
> thiele2coef as = canonicalize $ t2r as 0
>   where
>     t2r [an,an'] n = ([an*an'-n,1],[an'])
>     t2r (a:as)   n = ((a .* num) + ([-n,1] * den), num)
>       where
>         (num, den) = t2r as (n+1)\end{verbatim}

From the first example,
\begin{verbatim}
  *Univariate> let func x = (x^2+16*x+16)%(6*x+16)
  *Univariate> let funcList = map func [0..]
  *Univariate> tDegree funcList 
  3
  *Univariate> take 5 funcList 
  [1 % 1,3 % 2,13 % 7,73 % 34,12 % 5]
  *Univariate> let aFunc = thieleC funcList 
  *Univariate> aFunc
  [1 % 1,2 % 1,3 % 1,4 % 1]
  *Univariate> thiele2coef aFunc
  ([1 % 1,1 % 1,1 % 16],[1 % 1,3 % 8])
\end{verbatim}

From the other example, equation (3.26) of ref.\ref{Tiziano},
\begin{verbatim}
  *Univariate> let h t = (3+6*t+18*t^2)%(1+2*t+20*t^2)
  *Univariate> let hs = map h [0..]
  *Univariate> take 5 hs
  [3 % 1,27 % 23,87 % 85,183 % 187,45 % 47]
  *Univariate> let th x = thiele2ratf as x
  *Univariate> map th [0..5]
  [3 % 1,27 % 23,87 % 85,183 % 187,45 % 47,69 % 73]
  *Univariate> as
  [3 % 1,(-23) % 42,(-28) % 13,767 % 14,7 % 130]
  *Univariate> thiele2coef as
  ([3 % 1,6 % 1,18 % 1],[1 % 1,2 % 1,20 % 1])
\end{verbatim}

\subsection{\texttt{lists2rat}: from output lists to canonical coefficients}
Finally, we get
\begin{verbatim}
> lists2rat :: (Integral a) => [Ratio a] -> ([Ratio a], [Ratio a])
> lists2rat = thiele2Coef . thieleC
\end{verbatim}
as the reconstruction function from the output sequence.
\begin{verbatim}
  *Univariate> let h t = (3+6*t+18*t^2)%(1+2*t+20*t^2)
  *Univariate> lists2rat $ map h [0..]
  ([3 % 1,6 % 1,18 % 1],[1 % 1,2 % 1,20 % 1])
\end{verbatim}

\section{Multivariate polynomials}
From now on, we will use only the following functions from univariate cases.
\begin{verbatim}
Multivariate.lhs

> module Multivariate 
>   where

> import Data.Ratio
> import Univariate 
>   ( degree, list2pol
>   , thiele2ratf, lists2ratf, thiele2coef, lists2rat
>   )
\end{verbatim}

\subsection{Foldings as recursive applications}
Consider an arbitrary multivariate polynomial
\begin{eqnarray}
f(z_1,\cdots, z_n) \in \mathbb{K}[z_1,\cdots, z_n].
\end{eqnarray}
First, fix all the variable but 1st and apply the univariate Newton's reconstruction:
\begin{eqnarray}
f(z_1, z_2, \cdots, z_n) = \sum_{r=0}^R a_r (z_2,\cdots, z_n) \prod_{i=0}^{r-1}(z_1 - y_i)
\end{eqnarray}
Recursively, pick up one "coefficient" and apply the univariate Newton's reconstruction on $z_2$:
\begin{eqnarray}
a_r(z_2, \cdots, z_n) = \sum_{s=0}^{S} b_s (z_3,\cdots, z_n) \prod_{j=0}^{s-1}(z_2 - x_j)
\end{eqnarray}
The terminate cotndition should be the univariate case.

\subsection{Experiments, 2 variables case}
Let us take a polynomial from the denominator in eq.(3.23) of ref.\ref{Tiziano}.
\begin{eqnarray}
f(z_1,z_2) = 3 + 2z_1 + 4z_2 + 7z_1^2 + 5z_1z_2 + 6z_2^2
\end{eqnarray}
In Haskell, first, fix $z_2=0,1,2$ and identify $f(z_1, 0), f(z_1,1), f(z_1,2)$ as our univariate polynomials.
\begin{verbatim}
  *Multivariate> let f z1 z2 = 3+2*z1+4*z2+7*z1^2+5*z1*z2+6*z2^2
  *Multivariate> let fs z = map (`f` z) [0..]
  *Multivariate> let llst = map fs [0,1,2]
  *Multivariate> map degree llst
  [2,2,2]
\end{verbatim}
Fine, so the canonical form can be
\begin{eqnarray}
f(z_1, z) = c_0(z) + c_1(z)z_1 + c_2(z) z_1^2.
\end{eqnarray}
Now our new target is three univariate polynomials $c_0(z), c_1(z), c_2(z)$.
\begin{verbatim}
  *Multivariate> list2pol $ take 10 $ fs 0
  [3 % 1,2 % 1,7 % 1]
  *Multivariate> list2pol $ take 10 $ fs 1
  [13 % 1,7 % 1,7 % 1]
  *Multivariate> list2pol $ take 10 $ fs 2
  [35 % 1,12 % 1,7 % 1]
\end{verbatim}
That is
\begin{eqnarray}
f(z,0) &=& 3+ 2z+7z^2 \\
f(z,1) &=& 13 + 7z + 7z^2 \\
f(z,2) &=& 35 + 12z + 7z^2.
\end{eqnarray}
From these observation, we can determine $c_2(z)$, since it already a constant sequence.
\begin{eqnarray}
c_2(z) = 7
\end{eqnarray}
Consider $c_1(z)$, the sequence is now enough to determine $c_1(z)$:
\begin{verbatim}
  *Multivariate> degree [2,7,12]
  1
  *Multivariate> list2pol [2,7,12]
  [2 % 1,5 % 1]
\end{verbatim}
i.e.,
\begin{eqnarray}
c_1(z) = 2 + 5z.
\end{eqnarray}
However, for $c_1(z)$
\begin{verbatim}
  *Multivariate> degree [3, 13, 35]
  *** Exception: difLists: lack of data, or not a polynomial
  CallStack (from HasCallStack):
    error, called at ./Univariate.lhs:61:19 in main:Univariate
\end{verbatim}
so we need more numbers.
Let us try one more:
\begin{verbatim}
  *Multivariate> list2pol $ take 10 $ map (`f` 3) [0..]
  [69 % 1,17 % 1,7 % 1]
  *Multivariate> degree [3, 13, 35, 69]
  2
  *Multivariate> list2pol [3,13,35,69]
  [3 % 1,4 % 1,6 % 1]
\end{verbatim}
Thus we have
\begin{eqnarray}
c_0(z) = 3+4z+6z^2
\end{eqnarray}
and these fully determine our polynomial:
\begin{eqnarray}
f(z_1, z_2) = (3+4z_2+6z_2^2) + (2 + 5z_2)z_1 + 7z_1^2.
\end{eqnarray}

As another experiment, take the denominator.
\begin{verbatim}
  *Multivariate> let g x y = 1+7*x + 8*y + 10*x^2 + x*y+9*y^2
  *Multivariate> let gs x = map (g x) [0..]
  *Multivariate> map degree $ map gs [0..3] 
  [2,2,2,2]
\end{verbatim}
So the canonical form should be
\begin{eqnarray}
g(x,y) = c_0(x) + c_1(x)y + c_2(x)y^2
\end{eqnarray}
Let us look at these coefficient polynomial:
\begin{verbatim}
  *Multivariate> list2pol $ take 10 $ gs 0
  [1 % 1,8 % 1,9 % 1]
  *Multivariate> list2pol $ take 10 $ gs 1
  [18 % 1,9 % 1,9 % 1]
  *Multivariate> list2pol $ take 10 $ gs 2
  [55 % 1,10 % 1,9 % 1]
  *Multivariate> list2pol $ take 10 $ gs 3
  [112 % 1,11 % 1,9 % 1]
\end{verbatim}
So we get
\begin{eqnarray}
c_2(x) = 9
\end{eqnarray}
and 
\begin{verbatim}  
  *Multivariate> map (list2pol . (take 10) . gs) [0..4] 
  [[1 % 1,8 % 1,9 % 1]
  ,[18 % 1,9 % 1,9 % 1]
  ,[55 % 1,10 % 1,9 % 1]
  ,[112 % 1,11 % 1,9 % 1]
  ,[189 % 1,12 % 1,9 % 1]
  ]
  *Multivariate> map head it
  [1 % 1,18 % 1,55 % 1,112 % 1,189 % 1]
  *Multivariate> list2pol it
  [1 % 1,7 % 1,10 % 1]
  *Multivariate> list2pol $ map (head . list2pol . (take 10) . gs) [0..4] 
  [1 % 1,7 % 1,10 % 1]
\end{verbatim}
Using index operator \texttt{(!!)},
\begin{verbatim}
  *Multivariate> list2pol $ map ((!! 0) . list2pol . (take 10) . gs) [0..4] 
  [1 % 1,7 % 1,10 % 1]
  *Multivariate> list2pol $ map ((!! 1) . list2pol . (take 10) . gs) [0..4] 
  [8 % 1,1 % 1]
  *Multivariate> list2pol $ map ((!! 2) . list2pol . (take 10) . gs) [0..4] 
  [9 % 1]
\end{verbatim}
Finally we get
\begin{eqnarray}
c_0(x) = 1 + 7x+10x^2, c_1(x) = 8+x, \left( c_2(x) = 9, \right)
\end{eqnarray}
and
\begin{eqnarray}
g(x,y) = (1+7x+10x^2) + (8+x)y + 9y^2
\end{eqnarray}

% \subsection{Haskell implementation, 2 variables case}

\section{Multivariate rational functions}
\subsection{The canonical normalization}
Our target is a pair of coefficients $(\{ n_\alpha\}_\alpha, \{ d_\beta\}_\beta)$ in
\begin{eqnarray}
\frac{\sum_\alpha n_\alpha z^\alpha}{\sum_\beta d_\beta z^\beta}
\end{eqnarray}
A canonical choice is
\begin{eqnarray}
d_0 = d_{(0,\cdots,0)} = 1.
\end{eqnarray}
Accidentally we might face $d_0 = 0$, but we can shift our function and make
\begin{eqnarray}
d'_0 = d_{s} \neq 0.
\end{eqnarray}

\subsection{An auxiliary $t$}
Introducing an auxiliary variable $t$, let us define
\begin{eqnarray}
h(z,t) := f(tz_1, \cdots, tz_n),
\end{eqnarray}
and reconstruct $h(t,z)$ as a univariate rational function of $t$:
\begin{eqnarray}
h(z, t) = \frac{\sum_{r=0}^R p_r(z) t^r}{1+ \sum_{r'=1}^{R'} q_{r'}(z) t^{r'}}
\end{eqnarray}
where
\begin{eqnarray}
p_r(z) &=& \sum_{|\alpha| = r} n_\alpha z^\alpha \\
q_{r'}(z) &=& \sum_{|\beta| = r'} n_\beta z^\beta
\end{eqnarray}
are homogeneous polynomials.

Thus, what we shall do is the (homogeneous) polynomial reconstructions of $\left. p_r(z) \right|_{0 \leq r \leq R}, \left. q_{r'} \right|_{1 \leq r' \leq R'}$.

\subsubsection{A simplification}
Since our new targets are homogeneous polynomials, we can consider, say,
\begin{eqnarray}
p_r(1, z_2, \cdots, z_n)
\end{eqnarray}
instead of $p_r(z_1, z_2, \cdots, z_n)$, reconstruct it using multivariate Newton's method, and homogenize with $z_1$.

\subsection{Experiments, 2 variables case}
Consider the equation (3.23) in ref.\ref{Tiziano}.
\begin{verbatim}
  *Multivariate> let f x y = (3+2*x+4*y+7*x^2+5*x*y+6*y^2)
                              % (1+7*x+8*y+10*x^2+x*y+9*y^2)
  *Multivariate> :t f
  f :: Integral a => a -> a -> Ratio a
  *Multivariate> let h x y t = f (t*x) (t*y)
  *Multivariate> let hs x y = map (h x y) [0..]
  *Multivariate> take 5 $ hs 0 0
  [3 % 1,3 % 1,3 % 1,3 % 1,3 % 1]
  *Multivariate> take 5 $ hs 0 1
  [3 % 1,13 % 18,35 % 53,69 % 106,115 % 177]
  *Multivariate> take 5 $ hs 1 0
  [3 % 1,2 % 3,7 % 11,9 % 14,41 % 63]
  *Multivariate> take 5 $ hs 1 1
  [3 % 1,3 % 4,29 % 37,183 % 226,105 % 127]
\end{verbatim}
Here we have introduced the auxiliary $t$ as third argument.

We take $(x,y) = (1,0), (1,1), (1,2), (1,3)$ and reconstruct them\footnote{Eq.(3.26) in ref.\ref{Tiziano} is different from our reconstruction.
}.
\begin{verbatim}
  *Multivariate> lists2rat $ hs 1 0
  ([3 % 1,2 % 1,7 % 1],[1 % 1,7 % 1,10 % 1])
  *Multivariate> lists2rat $ hs 1 1
  ([3 % 1,6 % 1,18 % 1],[1 % 1,15 % 1,20 % 1])
  *Multivariate> lists2rat $ hs 1 2
  ([3 % 1,10 % 1,41 % 1],[1 % 1,23 % 1,48 % 1])
  *Multivariate> lists2rat $ hs 1 3
  ([3 % 1,14 % 1,76 % 1],[1 % 1,31 % 1,94 % 1])
\end{verbatim}
So we have
\begin{eqnarray}
\label{tizianoExample1}
h(1,0,t) &=& \frac{3+2t+7t^2}{1+7t+10t^2} \\
\label{tizianoExample2}
h(1,1,t) &=& \frac{3+6t+18t^2}{1+15t+20t^2} \\
\label{tizianoExample3}
h(1,2,t) &=& \frac{3+10t+41t^2}{1+23t+48t^2} \\
\label{tizianoExample4}
h(1,3,t) &=& \frac{3+14t+76t^2}{1+31t+94t^2}
\end{eqnarray}
Our next targets are the coefficients as polynomials in $y$ \footnote{
In our example, we take $x=1$ fixed and reproduce $x$-dependence using homogenization
}.

Let us consider numerator first.
This \texttt{list} is Haskell representation for eq.(\ref{tizianoExample1}), eq.(\ref{tizianoExample2}), eq.(\ref{tizianoExample3}) and eq.(\ref{tizianoExample4}).
\begin{verbatim}
  *Multivariate> let list = map (lists2rat . (hs 1)) [0..4]
  *Multivariate> let numf = map fst list
  *Multivariate> list
  [([3 % 1,2 % 1,7 % 1],[1 % 1,7 % 1,10 % 1])
  ,([3 % 1,6 % 1,18 % 1],[1 % 1,15 % 1,20 % 1])
  ,([3 % 1,10 % 1,41 % 1],[1 % 1,23 % 1,48 % 1])
  ,([3 % 1,14 % 1,76 % 1],[1 % 1,31 % 1,94 % 1])
  ,([3 % 1,18 % 1,123 % 1],[1 % 1,39 % 1,158 % 1])
  ]
  *Multivariate> numf
  [[3 % 1,2 % 1,7 % 1]
  ,[3 % 1,6 % 1,18 % 1]
  ,[3 % 1,10 % 1,41 % 1]
  ,[3 % 1,14 % 1,76 % 1]
  ,[3 % 1,18 % 1,123 % 1]
  ]
\end{verbatim}
From this information, we reconstruct each polynomials
\begin{verbatim}
  *Multivariate> list2pol $ map head numf
  [3 % 1]
  *Multivariate> list2pol $ map (head . tail) numf
  [2 % 1,4 % 1]
  *Multivariate> list2pol $ map last numf
  [7 % 1,5 % 1,6 % 1]
\end{verbatim}
that is we have $3, 2+4y, 7+5y+6y^2$ as results.
Similarly,
\begin{verbatim}
  *Multivariate> let denf = map snd list
  *Multivariate> denf
  [[1 % 1,7 % 1,10 % 1]
  ,[1 % 1,15 % 1,20 % 1]
  ,[1 % 1,23 % 1,48 % 1]
  ,[1 % 1,31 % 1,94 % 1]
  ,[1 % 1,39 % 1,158 % 1]
  ]
  *Multivariate> list2pol $ map head denf
  [1 % 1]
  *Multivariate> list2pol $ map (head . tail) denf
  [7 % 1,8 % 1]
  *Multivariate> list2pol $ map last denf
  [10 % 1,1 % 1,9 % 1]
\end{verbatim}
So we get
\begin{eqnarray}
h(1,y,t) = \frac{3 + (2+4y)t + (7+5y+6y^2)t^2}{1 + (7+8y)t + (10+y+9y^2)t^2}
\end{eqnarray}
Finally, we use the homogeneous property for each powers:
\begin{eqnarray}
h(x,y,t) = \frac{3 + (2x+4y)t + (7x^2+5xy+6y^2)t^2}{1 + (7x+8y)t + (10x^2+xy+9y^2)t^2}
\end{eqnarray}
Putting $t=1$, we get
\begin{eqnarray}
f(x,y) &=& h(x,y,1) \\
&=& \frac{3 + (2x+4y) + (7x^2+5xy+6y^2)}{1 + (7x+8y) + (10x^2+xy+9y^2)}
\end{eqnarray}

\chapter{TBA Functional reconstruction over finite fields}




%%%%%%%%%%

\chapter{Codes}
\section{\texttt{Ffield.lhs}}
\lstinputlisting[caption=Ffield.lhs,label=Ffield]{Ffield.lhs}

\section{\texttt{Polynomials.hs}}
\lstinputlisting[caption=Polynomials.hs,label=Polynomials]{Polynomials.hs}

\section{\texttt{Univariate.lhs}}
\lstinputlisting[caption=Univariate.lhs,label=Univariate]{Univariate.lhs}

\section{\texttt{Multivariate.lhs}}
\lstinputlisting[caption=Multivariate.lhs,label=Multivariate]{Multivariate.lhs}

\section{\texttt{FROverZp.lhs}}
\lstinputlisting[caption=FROverZp.lhs,label=FROverZp]{FROverZp.lhs}


\end{document}