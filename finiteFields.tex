\documentclass[11pt]{book}
\usepackage{amsmath,amssymb}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage[all]{xy}
\usepackage[yyyymmdd]{datetime}

\usepackage{hyperref}

\DeclareMathOperator*{\colim}{colim}
\DeclareMathOperator*{\coker}{coker}

\begin{document}

\newcommand{\Slash}[1]{{\ooalign{\hfil/\crcr$#1$}}}

\title{Finite fields}
\author{Ray D. Sameshima}
\date{2016/09/23 $\sim$ \today \, \currenttime}
\maketitle

\tableofcontents

%%%%%%body
\setcounter{chapter}{-1}
\chapter{Preface}
\section{References}
\begin{enumerate}
\item \label{Tiziano}
Scattering amplitudes over finite fields and multivariate functional reconstruction (Tiziano Peraro)\\
\url{https://arxiv.org/pdf/1608.01902.pdf}

\item Haskell Language \\
\url{www.haskell.org}

\item \url{http://qiita.com/bra_cat_ket/items/205c19611e21f3d422b7}\\
(Japanese tech support sns)

\item \label{Haskellroad}
The Haskell Road to Logic, Maths and Programming (Kees Doets, Jan van Eijck)\\
\url{http://homepages.cwi.nl/~jve/HR/}
\end{enumerate}

\section{Set theoretical gadgets}
\subsection{Numbers}
Here is a list of what we assumed that the readers are familiar with:
\begin{enumerate}
\item $\mathbb{N}$ (Peano axiom: $\emptyset, \text{suc}$)
\item $\mathbb{Z}$
\item $\mathbb{Q}$
\item $\mathbb{R}$ (Dedekind cut)
\item $\mathbb{C}$ 
\end{enumerate}

\subsection{Algebraic structures}
\begin{enumerate}
\item Monoid: $(\mathbb{N},+), (\mathbb{N},\times)$
\item Group: $(\mathbb{Z},+), (\mathbb{Z},\times)$
\item Ring: $\mathbb{Z}$
\item Field: $\mathbb{Q}$, $\mathbb{R}$ (continuous), $\mathbb{C}$ (algebraic closed)
\end{enumerate}

\section{Haskell language}
From "A Brief, Incomplete and Mostly Wrong History of Programming Languages":\footnote{
\url{http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html}
}
\begin{quotation}
1990 - A committee formed by Simon Peyton-Jones, Paul Hudak, Philip Wadler, Ashton Kutcher, and People for the Ethical Treatment of Animals creates Haskell, a pure, non-strict, functional language. Haskell gets some resistance due to the complexity of using monads to control side effects. Wadler tries to appease critics by explaining that "a monad is a monoid in the category of endofunctors, what's the problem?" 
\end{quotation}

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=3cm, bb= 0 0 1280 904]{Haskell-Logo.png}
\caption{Haskell's logo, the combinations of $\lambda$ and monad's bind \texttt{>>=}.}
\label{Haskell-Logo}
\end{center}
\end{figure}

Haskell language is a standardized purely functional declarative statically typed programming language.

In declarative languages, we describe "what" or "definition" in its codes, however imperative languages, like C/C++, "how" or "procedure".
\begin{quotation}
Functional languages can be seen as 'executable mathematics'; the notation was designed to be as close as possible to the mathematical way of writing.\footnote{
Algorithms: A Functional Programming Approach (Fethi A. Rabhi, Guy Lapalme)
}
\end{quotation}
Instead of loops, we use (implicit) recursions in functional language.\footnote{Of course, as a best practice, we should use higher order function (in this case \texttt{foldr} or \texttt{foldl}) rather than explicit recursions.
}
\begin{verbatim}
> sum :: [Int] -> Int
> sum []     = 0
> sum (i:is) = i + sum is
\end{verbatim}



%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Basics}
We have assumed living knowledge on (axiomatic, i.e., ZFC) set theory, algebraic structures.

\section{Finite field}
\begin{verbatim}
Ffield.lhs

https://arxiv.org/pdf/1608.01902.pdf

> module Ffield where

> import Data.Ratio 
> import Data.Maybe
> import Data.Numbers.Primes
\end{verbatim}

\subsection{Rings}
A ring $(R,+,*)$ is a structured set $R$ with two binary operations
\begin{eqnarray}
\verb|(+) :: R -> R -> R|\\
\verb|(*) :: R -> R -> R|
\end{eqnarray}
satisfying the following 3 (ring) axioms:
\begin{enumerate}
\item $(R,+)$ is an abelian, i.e., commutative group,
i.e.,
\begin{eqnarray}
\forall a,b,c \in R, (a+b) + c = a + (b + c) & \text{ (associativity for $+$)} \\
\forall a, b, \in R, a+b = b+a & \text{ (commutativity)} \\
\exists 0 \in R, \text{ s.t. } \forall a \in R, a + 0 = a & \text{ (additive identity) } \\
\forall a \in R, \exists (-a) \in R \text{ s.t. } a + (-a) = 0 & \text{ (additive inverse)}
\end{eqnarray}

\item $(R,*)$ is a monoid, i.e.,
\begin{eqnarray}
\forall a,b,c \in R, (a*b) * c = a * (b * c) & \text{ (associativity for $*$)} \\
\exists 1 \in R, \text{ s.t. } \forall a \in R, a * 1 = a = 1*a & \text{ (multiplicative identity) } 
\end{eqnarray}

\item Multiplication is distributive w.r.t addition, i.e., $\forall a,b,c \in R$, 
\begin{eqnarray}
a*(b+c) = (a*b) + (a*c) & \text{ (left distributivity)} \\
(a+b)*c = (a*c) + (b*c) & \text{ (right distributivity)} 
\end{eqnarray}

\end{enumerate}

\subsection{Fields}
A field is a ring $(\mathbb{K},+,*)$ whose non-zero elements form an abelian group under multiplication, i.e., $\forall r \in \mathbb{K}$,
\begin{eqnarray}
r \neq 0 \Rightarrow \exists r^{-1} \in \mathbb{K} \text{ s.t. } r*r^{-1} = 1 = r^{-1}*r.
\end{eqnarray}
A field $\mathbb{K}$ is a finite field iff the underlying set $\mathbb{K}$ is finite.
A field $\mathbb{K}$ is called infinite field iff the underlying set is infinite.

\subsection{An example of finite rings $\mathbb{Z}_n$}
Let $n (>0) \in \mathbb{N}$ be a non-zero natural number.
Then the quotient set
\begin{eqnarray}
\mathbb{Z}_n &:=& \mathbb{Z} / n\mathbb{Z} \\
&\cong& \{0, \cdots, (n-1)\}
\end{eqnarray}
with addition, subtraction and multiplication under modulo $n$ is a ring.\footnote{
Here we have taken an equivalence class, 
\begin{eqnarray}
0 \leq \forall k \leq (n-1), [k] := \{k + n*z | z \in \mathbb{Z} \}
\end{eqnarray}
with the following operations:
\begin{eqnarray}
\left[k \right] + \left[l \right] &:=& \left[k+l\right] \\
\left[k \right] * \left[l \right] &:=& \left[k * l\right]
\end{eqnarray}
This is equivalent to take modular $n$:
\begin{eqnarray}
(k \mod n) + (l \mod n) &:=& (k+l \mod n) \\
(k \mod n) * (l \mod n) &:=& (k*l \mod n).
\end{eqnarray}

}

\subsection{B\'ezout's lemma}
Consider $a,b \in \mathbb{Z}$ be nonzero integers.
Then there exist $x,y \in \mathbb{Z}$ s.t.
\begin{eqnarray}
a*x + b*y = \gcd(a,b),
\end{eqnarray}
where $\gcd$ is the greatest common divisor (function), see \S\ref{gcdDefinition}.
We will prove this statement in \S\ref{exGCD}.

\subsection{Greatest common divisor}
\label{gcdDefinition}
Before the proof, here is an implementation of $\gcd$ using Euclidean algorithm with Haskell language:

\begin{verbatim}
> -- Eucledian algorithm.
> myGCD :: Integral a => a -> a -> a
> myGCD a b
>   | b < 0 = myGCD a (-b)
> myGCD a b
>   | a == b = a
>   | b >  a = myGCD b a
>   | b <  a = myGCD (a-b) b
\end{verbatim}

\subsubsection{Example, by hands}
Let us consider the gcd of 7 and 13.
Since they are primes, the gcd should be 1.
First it binds \texttt{a} with 7 and \texttt{b} with 13, and hit \texttt{b > a}.
\begin{eqnarray}
\texttt{myGCD 7 13 == myGCD 13 7}
\end{eqnarray}
Then it hits main line:
\begin{eqnarray}
\texttt{myGCD 13 7 == myGCD (13-7) 7}
\end{eqnarray}
In order to go to next step, Haskell evaluate $(13-7)$,\footnote{
Since Haskell language adopts lazy evaluation, i.e., call by need, not call by name.
}
and
\begin{eqnarray}
\texttt{myGCD (13-7) 7} &\texttt{==}& \texttt{myGCD 6 7} \\
&\texttt{==}& \texttt{myGCD 7 6} \\
&\texttt{==}& \texttt{myGCD (7-6) 6} \\
&\texttt{==}& \texttt{myGCD 1 6} \\
&\texttt{==}& \texttt{myGCD 6 1}
\end{eqnarray}
Finally it ends with 1:
\begin{eqnarray}
\texttt{myGCD 1 1 == 1} 
\end{eqnarray}

As another example, consider $15$ and $25$:
\begin{eqnarray}
\texttt{myGCD 15 25} &\texttt{==}& \texttt{myGCD 25 15}\\
&\texttt{==}& \texttt{myGCD (25-15) 15}\\
&\texttt{==}& \texttt{myGCD 10 15}\\
&\texttt{==}& \texttt{myGCD 15 10}\\
&\texttt{==}& \texttt{myGCD (15-10) 10}\\
&\texttt{==}& \texttt{myGCD 5 10}\\
&\texttt{==}& \texttt{myGCD 10 5}\\
&\texttt{==}& \texttt{myGCD (10-5) 5}\\
&\texttt{==}& \texttt{myGCD 5 5}\\
&\texttt{==}& \texttt{5}
\end{eqnarray}

\subsubsection{Example, by Haskell}
Let us check simple example using Haskell:
\begin{verbatim}
  *Ffield> myGCD 7 13
  1
  *Ffield> myGCD 7 14
  7
  *Ffield> myGCD (-15) (20)
  5
  *Ffield> myGCD (-299) (-13)
  13
\end{verbatim}
The final result is from
\begin{verbatim}
  *Ffield> 13*23
  299
\end{verbatim}

\subsection{Extended Euclidean algorithm}
\label{exGCD}
Here we treat the extended Euclidean algorithm.

As intermediate steps, this algorithm makes sequences of integers $\{r_i\}_i$, $\{s_i\}_i$, $\{t_i\}_i$ and quotients $\{q_i\}_i$ as follows.
The base case are
\begin{eqnarray}
\left(r_0, s_0, t_0 \right) &:=& (a,1,0) \\
\left(r_1, s_1, t_1 \right) &:=& (b,0,1) 
\end{eqnarray}
and inductively,
\begin{eqnarray}
q_i &:=& \text{quot}(r_{i-2}, r_{i-1}) \\
r_i &:=& r_{i-2} - q_i * r_{i-1} \\
s_i &:=& s_{i-2} - q_i * s_{i-1} \\
t_i &:=& t_{i-2} - q_i * t_{i-1}.
\end{eqnarray}
The termination condition\footnote{
This algorithm will terminate eventually, since the sequence $\{r_i\}_i$ is non-negative by definition of $q_i$, but strictly decreasing.
Therefore, $\{r_i\}_i$ will meet $0$ in finite step $k$.
} is
\begin{eqnarray}
r_k = 0
\end{eqnarray}
for some $k \in \mathbb{N}$ and
\begin{eqnarray}
\gcd(a,b) &=& r_{k-1} \\
x &=& s_{k-1} \\
y &=& t_{k-1}.
\end{eqnarray}

\subsubsection{Proof}
By definition,
\begin{eqnarray}
\gcd(r_{i-1}, r_i) &=& \gcd(r_{i-1}, r_{i-2} - q_i * r_{i-1}) \\
&=& \gcd(r_{i-1}, r_{i-2})
\end{eqnarray}
and this implies 
\begin{eqnarray}
\gcd(a,b) =: \gcd(r_0, r_1) = \cdots = \gcd(r_{k-1}, 0),
\end{eqnarray}
i.e., 
\begin{eqnarray}
r_{k-1} = \gcd(a,b).
\end{eqnarray}

Next, for $i=0,1$ observe
\begin{eqnarray}
\label{guessOfRational}
a*s_i + b*t_i = r_i.
\end{eqnarray}
Let $i\geq 2$, then
\begin{eqnarray}
r_i &=& r_{i-2}  - q_i * r_{i-1} \\
&=& a*s_{i-2} + b*t_{i-2} - q_i *(a*s_{i-1} + b*t_{i-1} ) \\
&=& a*(s_{i-2} - q_i **s_{i-1}) + b* (t_{i-2} - q_i *t_{i-1} ) \\
&=:& a*s_i + b*t_i.
\end{eqnarray}
Therefore, inductively we get
\begin{eqnarray}
\gcd(a,b) = r_{k-1} = a*s_{k-1} + b*t_{k-1}. =: a*s + b*t.
\end{eqnarray}
This prove B\'ezout's lemma. \\
$\blacksquare$

\subsubsection{Haskell implementation}
\label{exGCDHaskell}
Here I use lazy lists for intermediate lists of $qs,rs,ss,ts$, and pick up (second) last elements for the results.

\label{extendedEuclideanAlgorithm}
\begin{verbatim}
Here we would like to implement the extended Euclidean algorithm.
See the algorithm, examples, and pseudo code at:

  https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm

> exGCD' :: Integral n => n -> n -> ([n], [n], [n], [n])
> exGCD' a b = (qs, rs, ss, ts)
>   where
>     qs = zipWith quot rs (tail rs)
>     rs = takeBefore (==0) r'
>     r' = steps a b
>     ss = steps 1 0
>     ts = steps 0 1
>     steps a b = rr
>       where rr@(_:rs) = a:b: zipWith (-) rr (zipWith (*) qs rs)
>         
> takeBefore :: (a -> Bool) -> [a] -> [a]
> takeBefore _ [] = []
> takeBefore p (l:ls)
>   | p l       = []
>   | otherwise = l : (takeBefore p ls)
\end{verbatim}
Here we have used so called lazy lists, and higher order function\footnote{
Naively speaking, the function whose inputs and/or outputs are functions is called a higher order function.
}.
The gcd of $a$ and $b$ should be the last element of second list, and our targets $(s,t)$ are second last elements of last two lists.
The following example is from wikipedia:
\begin{verbatim}
  *Ffield> exGCD' 240 46
  ([5,4,1,1,2],[240,46,10,6,4,2],[1,0,1,-4,5,-9,23],[0,1,-5,21,-26,47,-120])
  *Ffield> gcd 240 46
  2
  *Ffield> 240*(-9) + 46*(47)
  2
\end{verbatim}
It works, and we have other simpler examples:
\begin{verbatim}
  *Ffield> exGCD' 15 25
  ([0,1,1,2],[15,25,15,10,5],[1,0,1,-1,2,-5],[0,1,0,1,-1,3])
  *Ffield> 15 * 2 + 25*(-1)
  5
  *Ffield> exGCD' 15 26
  ([0,1,1,2,1,3],[15,26,15,11,4,3,1],[1,0,1,-1,2,-5,7,-26],[0,1,0,1,-1,3,-4,15])
  *Ffield> 15*7 + (-4)*26
  1
\end{verbatim}
Now what we should do is extract gcd of $a$ and $b$, and $(s,t)$ from the tuple of lists:
\begin{verbatim}
> -- a*x + b*y = gcd a b
> exGcd a b = (g, x, y)
>   where
>     (_,r,s,t) = exGCD' a b
>     g = last r
>     x = last . init $ s
>     y = last . init $ t
\end{verbatim}
where the underscore \verb+_+ is a special symbol in Haskell that hits every pattern.
So, in order to get gcd and $(s,t)$ we don't need quotients list.
\begin{verbatim}
  *Ffield> exGcd 46 240
  (2,47,-9)
  *Ffield> 46*47 + 240*(-9)
  2
  *Ffield> gcd 46 240
  2
\end{verbatim}

\subsection{Coprime}
Let us define a binary relation as follows:
\begin{verbatim}
  coprime :: Integral a => a -> a -> Bool
  coprime a b = (gcd a b) == 1
\end{verbatim}

\subsection{Corollary (Inverses in $\mathbb{Z}_n$)}
For a non-zero element
\begin{eqnarray}
a \in \mathbb{Z}_n,
\end{eqnarray}
there is a unique number 
\begin{eqnarray}
b \in \mathbb{Z}_n \text{ s.t. } ((a*b) \mod n) = 1
\end{eqnarray}
iff $a$ and $n$ are coprime.

\subsubsection{Proof}
From B\'ezout's lemma, $a$ and $n$ are coprime iff
\begin{eqnarray}
\exists s,t \in \mathbb{Z}, a*s + n*t = 1.
\end{eqnarray}
Therefore
\begin{eqnarray}
\text{$a$ and $n$ are coprime} &\Leftrightarrow& \exists s,t \in \mathbb{Z}, a*s + n*t = 1 \\
&\Leftrightarrow &\exists s,t' \in \mathbb{Z}, a*s = 1 + n*t'.
\end{eqnarray}
This $s$, by taking its modulo $n$ is our $b = a^{-1}$:
\begin{eqnarray}
a*s = 1 \mod n.
\end{eqnarray}
$\blacksquare$

\subsection{Corollary (Finite field $\mathbb{Z}_p$)}
If $p$ is prime, then 
\begin{eqnarray}
\mathbb{Z}_p := \{0, \cdots, (p-1)\}
\end{eqnarray}
with addition, subtraction and multiplication under modulo $n$ is a field.

\subsubsection{Proof}
It suffices to show that 
\begin{eqnarray}
\forall a \in \mathbb{Z}_p, a \neq 0 \Rightarrow \exists a^{-1} \in \mathbb{K} \text{ s.t. } a*a^{-1} = 1 = a^{-1}*a,
\end{eqnarray}
but since $p$ is prime, and
\begin{eqnarray}
\forall a \in \mathbb{Z}_p, a \neq 0 \Rightarrow \texttt{gcd a p == 1}
\end{eqnarray}
so all non-zero element has its inverse in $ \mathbb{Z}_p$.\\
$\blacksquare$

\subsubsection{Example and implementation}
Let us pick 11 as a prime and consider $\mathbb{Z}_{11}$:
\begin{verbatim}
Example Z_{11}

  *Ffield> isField 11
  True
  *Ffield> map (exGcd 11) [0..10]
  [(11,1,0),(1,0,1),(1,1,-5),(1,-1,4),(1,-1,3)
  ,(1,1,-2),(1,-1,2),(1,2,-3),(1,3,-4),(1,-4,5)
  ,(1,1,-1)
  ]

  *Ffield> map ((`mod` 11) . (\(_,_,x)->x) . exGcd 11) [1..10] 
  [1,6,4,3,9,2,8,7,5,10]
  *Ffield> zip [1..10] it
  [(1,1),(2,6),(3,4),(4,3),(5,9),(6,2),(7,8),(8,7),(9,5),(10,10)]
\end{verbatim}
Let us generalize these flow into a function\footnote{
From \url{https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Maybe.html}:
\begin{quotation}
The Maybe type encapsulates an optional value. 
A value of type Maybe a either contains a value of type a (represented as Just a), or it is empty (represented as Nothing). 
Using Maybe is a good way to deal with errors or exceptional cases without resorting to drastic measures such as error.
\end{quotation}
}:
\begin{verbatim}
> inverses :: Int -> Maybe [(Int, Int)]
> inverses n
>   | isField n = Just lst -- isPrime n
>   | otherwise = Nothing
>   where
>     lst' = map ((`mod` n) . (\(_,_,c)->c) . exGcd n) [1..(n-1)]
>     lst = zip [1..] lst'
\end{verbatim}
The function \texttt{inverses} returns a list of nonzero number with their inverses if $p$ is prime.

Now we define \texttt{inversep'}\footnote{
Here we have used do-notation, a syntactic sugar for use with monadic expressions.
From \url{https://wiki.haskell.org/Monad}:
\begin{quotation}
Monads in Haskell can be thought of as composable computation descriptions.
\end{quotation}
} whose 1st input is the base $p$ of our ring(field) and 2nd input is an element in $\mathbb{Z}_p$.
\begin{verbatim}
> inversep' :: Int -> Int -> Maybe Int
> inversep' p a = do
>   l <- inverses p
>   let a' = (a `mod` p)
>   return (snd $ l !! (a'-1)) 
   
  *Ffield> inverses' 11
  Just [(1,1),(2,6),(3,4),(4,3),(5,9),(6,2),(7,8),(8,7),(9,5),(10,10)]
\end{verbatim}
However, this is not efficient, and we refactor it as follows:
\begin{verbatim}
> inversep :: Int -> Int -> Maybe Int
> inversep p a = let (_,x,y) = exGcd p a in
>   if isPrime p then Just (y `mod` p)
>                else Nothing

  map (inversep' 10007) [1..10006]
  (12.99 secs, 17,194,752,504 bytes)
  map (inversep 10007) [1..10006]
  (1.74 secs, 771,586,416 bytes)
\end{verbatim}


\subsection{A map from $\mathbb{Q}$ to $\mathbb{Z}_p$}
Let $p$ be a prime.
Now we have a map
\begin{eqnarray}
- \mod p : \mathbb{Z} \to \mathbb{Z}_p; a \mapsto (a \mod p),
\end{eqnarray}
and a natural inclusion (or a forgetful map)\footnote{
By introducing this forgetful map, we can use 
\begin{eqnarray}
\times : (\mathbb{Z}, \mathbb{Z}) \to \mathbb{Z} 
\end{eqnarray}
of normal product on $\mathbb{Z}$.
}
\begin{eqnarray}
\text{\textquestiondown} : \mathbb{Z}_p \hookrightarrow \mathbb{Z}.
\end{eqnarray}
Then we can define a map
\begin{eqnarray}
- \mod p : \mathbb{Q} \to \mathbb{Z}_p
\end{eqnarray}
by\footnote{
This is an example of operator overloadings.
}
\begin{eqnarray}
q = \frac{a}{b} \mapsto (q \mod p) := \left( \left( a \times \text{\textquestiondown} \left( b^{-1} \mod p\right) \right) \mod p \right).
\end{eqnarray}

\subsubsection{Example and implementation}
An easy implementation is the followings:
\begin{verbatim}
A map from Q to Z_p.

> modp :: Ratio Int -> Int -> Int
> q `modp` p = (a * (bi `mod` p)) `mod` p
>   where
>     (a,b) = (numerator q, denominator q)
>     bi = fromJust $ inversep p b
\end{verbatim}
Let us consider a rational number $\frac{3}{7}$ on a finite field $\mathbb{Z}_{11}$:
\begin{verbatim}
Example: on Z_{11}
Consider (3 % 7).

  *Ffield Data.Ratio> let q = 3 % 7
  *Ffield Data.Ratio> 3 `mod` 11
  3
  *Ffield Data.Ratio> 7 `mod` 11
  7
  *Ffield Data.Ratio> inverses 11
  Just [(1,1),(2,6),(3,4),(4,3),(5,9),(6,2),(7,8),(8,7),(9,5),(10,10)]
\end{verbatim}
For example, pick 7:
\begin{verbatim}  
  *Ffield Data.Ratio> 7*8 == 11*5+1
  True
\end{verbatim}
Therefore, on $\mathbb{Z}_{11}$, $(7^{-1} \mod 11)$ is equal to $(8 \mod 11)$ and
\begin{verbatim}  
  (3%7) |-> (3 * (7^{-1} `mod` 11) `mod` 11)
             == (3*8 `mod` 11) 
             == 2 ` mod 11

  *Ffield Data.Ratio> q `modp` 11
  2
\end{verbatim}
consistent.

\subsection{Reconstruction from $\mathbb{Z}_p$ to $\mathbb{Q}$}
Consider a rational number $q$ and its image $a \in \mathbb{Z}_p$.
\begin{eqnarray}
a := q \mod p
\end{eqnarray}
The extended Euclidean algorithm can be used for guessing a rational number $q$ from the images $a := q \mod p$ of several primes $p$'s.

At each step, the extended Euclidean algorithm satisfies eq.(\ref{guessOfRational}).
\begin{eqnarray}
a*s_i + p*t_i = r_i
\end{eqnarray}
Therefore
\begin{eqnarray}
r_i = a*s_i \mod p \Leftrightarrow \frac{r_i}{s_i} \mod p = a.
\end{eqnarray}
Hence $\frac{r_i}{s_i}$ is a possible guess for $q$.
We take
\begin{eqnarray}
\label{terminationOfRec}
r_i^2 , s_i^2 < p
\end{eqnarray}
as the termination condition for this reconstruction.

\subsubsection{Haskell implementation}
Let us first try to reconstruct from the image $(\frac{1}{3} \mod p)$ of some prime $p$.
Here we have chosen three primes
\begin{verbatim}
Reconstruction Z_p -> Q
  *Ffield> let q = (1%3)
  *Ffield> take 3 $ dropWhile (<100) primes
  [101,103,107]
\end{verbatim}
The images are basically given by the first elements of second lists ($s_0$'s):
\begin{verbatim}  
  *Ffield> q `modp` 101
  34
  *Ffield> let try x = exGCD' (q `modp` x) x
  *Ffield> try 101
  ([0,2,1,33],[34,101,34,33,1],[1,0,1,-2,3,-101],[0,1,0,1,-1,34])
  *Ffield> try 103
  ([0,1,2,34],[69,103,69,34,1],[1,0,1,-1,3,-103],[0,1,0,1,-2,69])
  *Ffield> try 107
  ([0,2,1,35],[36,107,36,35,1],[1,0,1,-2,3,-107],[0,1,0,1,-1,36])  
\end{verbatim}
Look at the first hit of termination condition eq.(\ref{terminationOfRec}), $r_4=1$ and $s_4=3$.
They give us the same guess $\frac{1}{3}$, and that the reconstructed number.

From the above observations we can make a simple "guess" function:
\begin{verbatim}
> guess :: (Int, Int)       -- (q `modp` p, p)
>       -> (Ratio Int, Int)
> guess (a, p) = let (_,rs,ss,_) = exGCD' a p in
>   (select rs ss p, p)
>     where
>       select :: Integral t => [t] -> [t] -> t -> Ratio t
>       select [] _ _ = 0%1
>       select (r:rs) (s:ss) p
>         | s /= 0 && r^2 <= p && s^2 <= p = (r%s)
>         | otherwise = select rs ss p
\end{verbatim}
We have put a list of big primes as follows.
\begin{verbatim}
> -- Hard code of big primes.
> bigPrimes :: [Int]
> bigPrimes = dropWhile (< 897473) $ takeWhile (<978948) primes  
\end{verbatim}
We choose 3 times match as the termination condition.
\begin{verbatim}
> matches3 :: Eq a => [a] -> a
> matches3 (a:bb@(b:c:cs))
>   | a == b && b == c = a
>   | otherwise        = matches3 bb
\end{verbatim}
Finally, we can check our gadgets.
\begin{verbatim}
What we know is a list of (q `modp` p) and prime p.

  *Ffield> let q = 10%19
  *Ffield> let knownData = zip (map (modp q) bigPrimes) bigPrimes  
  *Ffield> matches3 $  map (fst . guess) knownData 
  10 % 19
\end{verbatim}
The following is the function we need, its input is the list of tuple which first element is the image in $\mathbb{Z}_p$ and second element is that prime $p$.
\begin{verbatim}
> reconstruct :: [(Int,Int)] -> Ratio Int
> reconstruct aps = matches3 $ map (fst . guess) aps

Here is a naive test:
  > let qs = [1 % 3,10 % 19,41 % 17,30 % 311,311 % 32
             ,869 % 232,778 % 123,331 % 739]
  > let modmap q = zip (map (modp q) bigPrimes) bigPrimes 
  > let longList = map modmap qs
  > map reconstruct longList 
  [1 % 3,10 % 19,41 % 17,30 % 311,311 % 32
  ,869 % 232,778 % 123,331 % 739]
  > it == qs
  True
\end{verbatim}

As another example, we have slightly involved function:
\begin{verbatim}
> matches3' :: Eq a => [(a, t)] -> (a, t)
> matches3' (a0@(a,_):bb@((b,_):(c,_):cs))
>   | a == b && b == c = a0
>   | otherwise        = matches3' bb

  *Ffield> let q = (331%739)
  (0.01 secs, 44,024 bytes)
  *Ffield> let smallerprimes = dropWhile (<100) $ takeWhile (<978948) primes
  (0.01 secs, 39,968 bytes)
  *Ffield> let knownData = zip (map (modp q) smallerprimes) smallerprimes 
  (0.01 secs, 39,872 bytes)
  *Ffield> matches3' $ map guess knownData 
  (331 % 739,614693)
  (17.64 secs, 12,402,878,080 bytes)
\end{verbatim}
so, the new function \verb+matches3'+ returns the reconstructed value in $\mathbb{Q}$ and the first matching prime.






\subsection{Chinese remainder theorem}
From wikipedia\footnote{
\url{https://en.wikipedia.org/wiki/Chinese_remainder_theorem}
}
\begin{quotation}
There are certain things whose number is unknown. If we count them by threes, we have two left over; by fives, we have three left over; and by sevens, two are left over. How many things are there? 
\end{quotation}
Here is a solution with Haskell:
\begin{verbatim}
*Ffield> let lst = [n|n<-[0..], mod n 3==2, mod n 5==3, mod n 7==2]
*Ffield> head lst
23
\end{verbatim}

The statement for binary case is the following.
Let $n_1, n_2 \in \mathbb{Z}$ be coprime, then for arbitrary $a_1,a_2 \in \mathbb{Z}$, the following a system of equations
\begin{eqnarray}
x &=& a_1 \mod n_1\\
x &=& a_2 \mod n_2
\end{eqnarray}
have a unique solution modular $n_1*n_2$.

\subsubsection{Proof}
(existence) With \S\ref{exGCD}, there are $m_1,m_2 \in \mathbb{Z}$ s.t.
\begin{eqnarray}
n_1 * m_1 + n_2 * m_2 = 1.
\end{eqnarray}
Now we have
\begin{eqnarray}
n_1 * m_1 &=& 1 \mod n_2 \\
n_2 * m_2 &=& 1 \mod n_1
\end{eqnarray}
that is
\begin{eqnarray}
m_1 &=& n_1^{-1} \mod n_2 \\
m_2 &=& n_2^{-1} \mod n_1.
\end{eqnarray}
Then
\begin{eqnarray}
a := a_1 * n_2 * m_2 + a_2 * n_1 * m_1 \mod (n_1*n_2)
\end{eqnarray}
is a solution.

(uniqueness)
If $a'$ is also a solution, then
\begin{eqnarray}
a - a' &=& 0 \mod n_1 \\
a - a' &=& 0 \mod n_2.
\end{eqnarray}
Since $n_1$ and $n_2$ are coprime, i.e., no common divisors, this difference is divisible by $n_1*n_2$, and
\begin{eqnarray}
a - a' = 0 \mod (n_1 * n_2).
\end{eqnarray}
Therefore, the solution is unique modular $n_1*n_2$. \\
$\blacksquare$

\subsubsection{Generalization}
Given $a \in Z_n$ of pairwise coprime numbers
\begin{eqnarray}
n := n_1 * \cdots * n_k,
\end{eqnarray}
a system of equations
\begin{eqnarray}
\left. a_i = a \mod n_i \right|_{i=1}^k
\end{eqnarray}
have a unique solution
\begin{eqnarray}
a = \sum_i m_i a_i \mod n,
\end{eqnarray}
where
\begin{eqnarray}
\left. m_i = \left( \frac{n_i}{n} \mod n_i \right) \frac{n}{n_i} \right|_{i=1}^k.
\end{eqnarray}

\section{Polynomials and rational functions}

\subsection{Notations}
Let $n \in \mathbb{N}$ be positive. 
We use multi-index notation:
\begin{eqnarray}
\alpha = (\alpha_1, \cdots, \alpha_n) \in \mathbb{N}^n.
\end{eqnarray}
A monomial is defined as
\begin{eqnarray}
z^\alpha := \prod_i z_i^{\alpha_i}.
\end{eqnarray}
The total degree of this monomial is given by
\begin{eqnarray}
|\alpha| := \sum_i \alpha_i.
\end{eqnarray}

\subsection{Polynomials and rational functions}
Let $\mathbb{K}$ be a field.
Consider a map
\begin{eqnarray}
f : \mathbb{F}^n \to \mathbb{F}; z \mapsto f(z) := \sum_\alpha c_\alpha z^\alpha,
\end{eqnarray}
where
\begin{eqnarray}
c_\alpha \in \mathbb{F}.
\end{eqnarray}
We call the value $f(z)$ at the dummy $z \in \mathbb{F}^n$ a polynomial:
\begin{eqnarray}
f(z) := \sum_\alpha c_\alpha z^\alpha.
\end{eqnarray}
We denote
\begin{eqnarray}
\mathbb{F}[z] := \left\{ \sum_\alpha c_\alpha z^\alpha \right\}
\end{eqnarray}
as the ring of all polynomial functions in the variable $z$ with $\mathbb{F}$-coefficients.

Similarly, a rational function can be expressed as a ratio of two polynomials $p(z),q(z) \in \mathbb{F}[z]$:
\begin{eqnarray}
\frac{p(z)}{q(z)} = \frac{\sum_\alpha n_\alpha z^\alpha}{\sum_\beta d_\beta z^\beta}.
\end{eqnarray}
We denote
\begin{eqnarray}
\mathbb{F}(z) := \left\{ \frac{\sum_\alpha n_\alpha z^\alpha}{\sum_\beta d_\beta z^\beta} \right\}
\end{eqnarray}
as the field of rational functions in the variable $z$ with $\mathbb{F}$-coefficients.
Similar to fractional numbers, there are several equivalent representation of a rational function, even if we simplify with gcd.
However there still is an overall constant ambiguity.
To have a unique representation, usually we put the lowest degree of term of the denominator to be 1.

\subsection{As data}
We can identify a polynomial
\begin{eqnarray}
\sum_\alpha c_\alpha z^\alpha
\end{eqnarray}
as a set of coefficients
\begin{eqnarray}
\{ c_\alpha\}_{\alpha}.
\end{eqnarray}

Similarly, for a rational function, we can identify
\begin{eqnarray}
\frac{\sum_\alpha n_\alpha z^\alpha}{\sum_\beta d_\beta z^\beta}
\end{eqnarray}
as an ordered pair of coefficients
\begin{eqnarray}
(\{ n_\alpha\}_\alpha, \{ d_\beta\}_\beta).
\end{eqnarray}
However, there still is an overall factor ambiguity even after gcd simplifications.

\section{Haskell implementation of univariate polynomials}
Here we basically follows some part of \S9 of ref.\ref{Haskellroad}, and its addendum\footnote{
See \url{http://homepages.cwi.nl/~jve/HR/PolAddendum.pdf}
}.

\begin{verbatim}
Univariate.lhs

> module Univariate where
> import Data.Ratio
\end{verbatim}

\subsection{A polynomial as a list of coefficients}
Let us start \texttt{instance} declaration, which enable us to use basic arithmetics:
\begin{verbatim}
> -- polynomials, as coefficients lists
> instance (Num a, Ord a) => Num [a] where
>   fromInteger c = [fromInteger c] 
> 
>   negate []     = []
>   negate (f:fs) = negate f : negate fs
> 
>   signum [] = []
>   signum gs 
>     | signum (last gs) < 0 = negate z
>     | otherwise = z
> 
>   abs [] = []
>   abs gs 
>     | signum gs == z = gs
>     | otherwise      = negate gs
> 
>   fs     + []     = fs
>   []     + gs     = gs
>   (f:fs) + (g:gs) = f+g : fs+gs
> 
>   fs     * []     = []
>   []     * gs     = []
>   (f:fs) * gg@(g:gs) = f*g : (f .* gs + fs * gg)
\end{verbatim}
Note that the above operators are overloaded, say \texttt{(*)}, \texttt{f*g} is a multiplication of two numbers but \texttt{fs*gg} is a multiplication of two list of coefficients.
We can not extend this overloading to scalar multiplication, since Haskell type system takes the operands of \texttt{(*)} the same type
\begin{eqnarray}
\verb+(*) :: Num a => a -> a -> a+
\end{eqnarray}

\begin{verbatim}
> -- scalar multiplication
> infixl 7 .*
> (.*) :: Num a => a -> [a] -> [a]
> c .* []     = []
> c .* (f:fs) = c*f : c .* fs
\end{verbatim}
Now the (dummy) variable is given as 
\begin{verbatim}
> -- z of f(z), variable
> z :: Num a => [a]
> z = [0,1]
\end{verbatim}

A polynomial of degree $R$ is given by a finite sum of the following form:
\begin{eqnarray}
f(z) := \sum_{i=0}^R c_i z^i.
\end{eqnarray}
Therefore, it is natural to represent $f(z)$ by a list of coefficient $\{c_i\}_i$.
Here is the translator from the coefficient list to a polynomial function:
\begin{verbatim}
> p2fct :: Num a => [a] -> a -> a
> p2fct [] x = 0
> p2fct (a:as) x = a + (x * p2fct as x)
\end{verbatim}
This gives us
\begin{verbatim}
*Univariate> take 10 $ map (p2fct [1,2,3]) [0..]
[1,6,17,34,57,86,121,162,209,262]
*Univariate> take 10 $ map (\n -> 1+2*n+3*n^2) [0..]
[1,6,17,34,57,86,121,162,209,262]
\end{verbatim}

\subsection{Difference analysis}
We do not know in general this canonical form of the polynomial, nor the degree.
That means, what we can access is the graph of $f$, i.e., the list of inputs and outputs.
Without loss of generality, we can take
\begin{eqnarray}
\texttt{[0..]}
\end{eqnarray}
as the input data.
Usually we take a finite sublist of this, but we assume it is sufficiently long.
The outputs should be
\begin{eqnarray}
\texttt{map f [0..] = [f 0, f 1 ..]}
\end{eqnarray}
For example
\begin{verbatim}
*Univariate> take 10 $ map (\n -> n^2+2*n+1) [0..]
[1,4,9,16,25,36,49,64,81,100]
\end{verbatim}

Let us consider the difference sequence
\begin{eqnarray}
\label{difference}
\Delta(f) (n) := f(n+1) - f(n).
\end{eqnarray}
Its Haskell version is
\begin{verbatim}
> -- difference analysis
> difs :: (Integral n) => [n] -> [n]
> difs [] = []
> difs [_] = []
> difs (i:jj@(j:js)) = j-i : difs jj
\end{verbatim}
This gives
\begin{verbatim}
*Univariate> difs [1,4,9,16,25,36,49,64,81,100]
[3,5,7,9,11,13,15,17,19]
*Univariate> difs [3,5,7,9,11,13,15,17,19]
[2,2,2,2,2,2,2,2]
\end{verbatim}

We claim that if $f(z)$ is a polynomial of degree $R$, then $\Delta(f)(z)$ is a polynomial of degree $R-1$.
Since the degree is given, we can write $f(z)$ in canonical form
\begin{eqnarray}
f(n) = \sum_{i=0}^R c_i n^i
\end{eqnarray}
and
\begin{eqnarray}
\Delta(f)(n) &:=& f(n+1) - f(n) \\
&=& \sum_{i=0}^R c_i \left\{ (n+1)^i - n^i\right\} \\
&=& \sum_{i=1}^R c_i \left\{ (n+1)^i - n^i\right\} \\
&=& \sum_{i=1}^R c_i \left\{ i*n^{i-1} + O(n^{i-2}) \right\} \\
&=& c_R*R*n^{R-1} + O(n^{R-2})
\end{eqnarray}
where $O(n^{i-2})$ is some polynomial(s) of degree $i-2$.

This guarantees the following function will terminate in finite steps\footnote{
If a given lists is generated by a polynomial.
}; \texttt{difLists} keeps generating difference lists until the difference get constant.
\begin{verbatim}
> difLists :: (Integral n) => [[n]] -> [[n]]
> difLists [] = []
> difLists xx@(xs:xss) =
>   if isConst xs then xx
>                 else difLists $ difs xs : xx
>   where
>     isConst (i:jj@(j:js)) = all (==i) jj
>     isConst _ = error "difLists: lack of data, or not a polynomial"
\end{verbatim}
Let us try:
\begin{verbatim}
  *Univariate> difLists [[-12,-11,6,45,112,213,354,541,780,1077]]
  [[6,6,6,6,6,6,6]
  ,[16,22,28,34,40,46,52,58]
  ,[1,17,39,67,101,141,187,239,297]
  ,[-12,-11,6,45,112,213,354,541,780,1077]
  ]
\end{verbatim}

The degree of the polynomial can be computed by difference analysis:
\begin{verbatim}
> degree :: (Integral n) => [n] -> Int
> degree xs = length (difLists [xs]) -1
\end{verbatim}
For example,
\begin{verbatim}
*Univariate> degree [1,4,9,16,25,36,49,64,81,100]
2
*Univariate> take 10 $ map (\n -> n^2+2*n+1) [0..]
[1,4,9,16,25,36,49,64,81,100]
*Univariate> degree $ take 10 $ map (\n -> n^5+4*n^3+1) [0..]
5
\end{verbatim}

Above \verb+degree+ function can only treat finite list, however, the following function can compute the degree of infinite list.
\begin{verbatim} 
> degreeLazy :: (Eq a, Num a) => [a] -> Int
> degreeLazy xs = helper xs 0
>   where
>     helper as@(a:b:c:_) n
>       | a==b && b==c = n
>       | otherwise    = helper (difs as) (n+1)
\end{verbatim}
Note that this lazy function only sees the first two elements of the list (of difference).
So first take the lazy \verb+degreeLazy+ and guess the degree, take sufficient finite sublist of output and apply \verb+degree+.

\chapter{Functional reconstruction}
The goal of a functional reconstruction algorithm is to identify the monomials appearing in their definition and the corresponding coefficients.

\section{Univariate polynomials}
\subsection{Newtons' polynomial representation}
Consider a univariate polynomial $f(z)$.
Given a sequence of values $\left. y_n \right|_{n \in \mathbb{N}}$, we evaluate the polynomial form $f(z)$ sequentially:
\begin{eqnarray}
f_0(z) &=& a_0 \\
f_1(z) &=& a_0 + (z-y_0)a_1 \\
\nonumber
&\vdots& \\
f_r(z) &=& a_0 + (z-y_0) \left(a_1 + (z-y_1)(\cdots + (z - y_{r-1})a_r \right) \\
&=& f_{r-1}(z) + (z-y_0) (z-y_1) \cdots (z - y_{r-1})a_r,
\end{eqnarray}
where
\begin{eqnarray}
a_0 &=& f(y_0) \\
a_1 &=& \frac{f(y_1) - a_0}{y_1 - y_0} \\
\nonumber
&\vdots& \\
a_r &=& \left( \left( \left( f(y_r)-a_0 \right)\frac{1}{y_r - y_0} - a_1 \right)\frac{1}{y_r - y_1} - \cdots - a_{r-1} \right) \frac{1}{y_r - y_{r-1}} \qquad
\end{eqnarray}
When we have already known the total degree of $f(z)$, say $R$, then we can terminate this sequential trial:
\begin{eqnarray}
f(z) &=& f_R(z) \\
&=& \sum_{r=0}^R a_r \prod_{i=0}^{r-1}(z - y_i).
\end{eqnarray}

In practice, a consecutive zero on the sequence $a_r$ can be taken as the termination condition for this algorithm.\footnote{
We have not proved, but higher power will be dominant when we take sufficiently big input, so we terminate this sequence when we get a consecutive zero in $a_r$.
}

\subsection{Towards canonical representations}
Once we get the Newton's representation
\begin{eqnarray}
\sum_{r=0}^R a_r \prod_{i=0}^{r-1}(z - y_i) = a_0 + (z-y_0) \left(a_1 + (z-y_1)(\cdots + (z - y_{R-1})a_R \right) \quad
\end{eqnarray}
as the reconstructed polynomial, it is convenient to convert it into the canonical form:
\begin{eqnarray}
\sum_{r=0}^R c_r z^r.
\end{eqnarray}
This conversion only requires addition and multiplication of univariate polynomials.
These operations are reasonably cheap, especially on $\mathbb{Z}_p$. 

\subsection{Simplification of our problem}
Without loss of generality, we can put 
\begin{eqnarray}
\texttt{[0..]}
\end{eqnarray}
as our input list, usually we take its finite part but we assume it has enough length.
Corresponding to above input,
\begin{eqnarray}
\texttt{map f [0..] = [f 0, f 1, ..]}
\end{eqnarray}
is our output list.

Then we have slightly simpler forms of coefficients:
\begin{eqnarray}
a_0 &=& f(0) \\
a_1 &=& f(y_1) - a_0 \\
&=& f(1) - f(0) =: \Delta(f)(0) \\
a_2 &=& \frac{f(2)-a_0}{2}-a_1 \\
&=& \frac{f(2) - f(0)}{2} - \left( f(1) - f(0) \right) \\
&=& \frac{f(2)-2f(1)-f(0)}{2} \\
&=& \frac{\left( f(2)-f(1) \right) -\left(f(1)-f(0) \right)}{2} =: \frac{\Delta^2(f)(0)}{2} \\
\nonumber
&\vdots&\\
a_r &=& \frac{\Delta^r(f)(0)}{r!},
\end{eqnarray}
where $\Delta$ is the difference operator in eq.(\ref{difference}):
\begin{eqnarray}
\Delta(f)(n) := f(n+1) - f(n).
\end{eqnarray}

In order to simplify our expression, we introduce a falling power:
\begin{eqnarray}
(x)_0 &:=& 1 \\
(x)_n &:=& x(x-1) \cdots (x-n+1) \\
&=& \prod_{i=0}^{n-1} (x-i).
\end{eqnarray}

Under these settings, we have
\begin{eqnarray}
f(z) &=& f_R(z) \\
&=& \sum_{r=0}^R \frac{\Delta^r(f)(0)}{r!} (x)_r
\end{eqnarray}

\subsubsection{Example}
Consider a polynomial
\begin{eqnarray}
f(z) := 2*z^3+3*z,
\end{eqnarray}
and its out put list
\begin{eqnarray}
\left[ f(0), f(1), f(3), \cdots\right] = \left[0,5,22,63,140,265, \cdots \right]
\end{eqnarray}
This polynomial is 3rd degree, so we compute up to $\Delta^3(f)(0)$:
\begin{eqnarray}
f(0) &=& 0 \\
\Delta(f)(0) &=& f(1) - f(0) = 5\\
\nonumber
\Delta^2(f)(0) &=& \Delta(f)(1) - \Delta(f)(0) \\
&=& f(2) - f(1) - 5 = 22 -5 -5= 12 \\
\nonumber
\Delta^3(f)(0) &=& \Delta^2(f)(1) - \Delta^2(f)(0) \\
&=& f(3)-f(2) - \left\{ f(2) - f(1)\right\} - 12 = 12
\end{eqnarray}
so we get
\begin{eqnarray}
\label{exOfDiff}
\left[0,5,12,12\right]
\end{eqnarray}
as the difference list.
Therefore, we get the falling power representation of $f$:
\begin{eqnarray}
f(z) &=& 5(x)_1 + \frac{12}{2}(x)_2 + \frac{12}{3!}(x)_3 \\
\label{exOfNewton} &=&  5(x)_1 + 6(x)_2 + 2(x)_3.
\end{eqnarray}

\subsection{Haskell implementation}
\subsubsection{Newton interpolation formula}
First, the falling power is naturally given by recursively:
\begin{verbatim}
> infixr 8 ^- -- falling power
> (^-) :: (Integral a) => a -> a -> a
> x ^- 0 = 1
> x ^- n = (x ^- (n-1)) * (x - n + 1)
\end{verbatim}

Assume the differences are given in a list
\begin{eqnarray}
\verb|[x_0, x_1 ..]| := \left[f(0), \Delta(f)(0), \Delta^2(f)(0), \cdots \right].
\end{eqnarray}
Then the implementation of the Newton interpolation formula is as follows:
\begin{verbatim}
> newton :: Integral a => [a] -> [Ratio a]
> newton xs = [x % factorial k | (x,k) <- zip xs [0..]]
>   where
>     factorial k = product [1..fromInteger k]
\end{verbatim}
Consider a polynomial
\begin{eqnarray}
\verb|f x = 2*x^3+3*x|
\end{eqnarray}
Let us try to reconstruct this polynomial from output list.
In order to get the list \verb+[x_0, x_1 ..]+, take \texttt{difLists} and pick the first elements:
\begin{verbatim}
  *NewtonInterpolation> take 10 $ map f [0..]
  [0,5,22,63,140,265,450,707,1048,1485]
  *NewtonInterpolation> difLists [it]
  [[12,12,12,12,12,12,12]
  ,[12,24,36,48,60,72,84,96]
  ,[5,17,41,77,125,185,257,341,437]
  ,[0,5,22,63,140,265,450,707,1048,1485]
  ]
  *NewtonInterpolation> reverse $ map head it
  [0,5,12,12]
\end{verbatim}
This list is the same as eq.(\ref{exOfDiff}) and we get the same expression as eq.(\ref{exOfNewton}):
\begin{verbatim}  
  *NewtonInterpolation> newton it
  [0 % 1,5 % 1,6 % 1,2 % 1]
\end{verbatim}

The list of first differences can be computed as follows:
\begin{verbatim}
> firstDifs :: [Integer] -> [Integer]
> firstDifs xs = reverse $ map head $ difLists [xs]
\end{verbatim}
Mapping a list of integers to a Newton representation:
\begin{verbatim}
> list2npol :: [Integer] -> [Rational]
> list2npol = newton . map fromInteger . firstDifs

  *NewtonInterpolation> take 10 $ map f [0..]
  [0,5,22,63,140,265,450,707,1048,1485]
  *NewtonInterpolation> list2npol it
  [0 % 1,5 % 1,6 % 1,2 % 1]
\end{verbatim}

\subsubsection{Stirling numbers of the first kind}
We need to map Newton falling powers to standard powers.  
This is a matter of applying combinatorics, by means of a convention formula that uses the so-called Stirling cyclic numbers 
\begin{eqnarray}
\left[\begin{array}{c}n \\k \end{array}\right]
\end{eqnarray}
Its defining relation is, $\forall n > 0$,
\begin{eqnarray}
(x)_n = \sum_{k=1}^n (-)^{n-k} \left[\begin{array}{c}n \\k \end{array}\right] x^k, 
\end{eqnarray}
and
\begin{eqnarray}
\left[\begin{array}{c}0 \\0 \end{array}\right] := 1.
\end{eqnarray}
From the highest order, $x^n$, we get
\begin{eqnarray}
\left[\begin{array}{c}n \\n \end{array}\right] = 1, \forall n > 0.
\end{eqnarray}
We also put
\begin{eqnarray}
\left[\begin{array}{c}0 \\1 \end{array}\right] = \left[\begin{array}{c}0 \\2 \end{array}\right] = \left[\begin{array}{c}0 \\3 \end{array}\right] = \cdots = 0,
\end{eqnarray}
and
\begin{eqnarray}
\left[\begin{array}{c}1 \\ 0 \end{array}\right] = \left[\begin{array}{c}2  \\ 0 \end{array}\right] =\left[\begin{array}{c}3 \\ 0 \end{array}\right] = \cdots = 0.
\end{eqnarray}

The key equation is
\begin{eqnarray}
(x)_n = (x)_{n-1}*  (x-n+1)
\end{eqnarray}
and we get
\begin{eqnarray}
(x)_n &=& \sum_{k=1}^n (-)^{n-k} \left[\begin{array}{c}n \\k \end{array}\right] x^k\\
&=& x^n + \sum_{k=1}^{n-1} (-)^{n-k} \left[\begin{array}{c}n \\k \end{array}\right] x^k\\
(x)_{n-1}*  (x-n+1) &=&  \sum_{k=1}^{n-1} (-)^{n-1-k} \left\{ \left[\begin{array}{c}n-1 \\k \end{array}\right] x^{k+1} -(n-1) \left[\begin{array}{c}n-1 \\k \end{array}\right] x^k \right\} \qquad \qquad \\
&=& \sum_{l=2}^n (-)^{n-l} \left[\begin{array}{c}n-1 \\l-1 \end{array}\right] x^l + (n-1)\sum_{k=1}^{n-1} (-)^{n-k} \left[\begin{array}{c}n \\k \end{array}\right] x^k \\
\nonumber &=& x^n + (n-1)(-)^{n-1} x \\
&&+ \sum_{k=2}^{n-1} (-)^{n-k} \left\{ \left[\begin{array}{c}n-1 \\k-1 \end{array}\right]  + (n-1)  \left[\begin{array}{c}n-1 \\k \end{array}\right] \right\} x^k \\
&=& x^n + \sum_{k=1}^{n-1} (-)^{n-k} \left\{ \left[\begin{array}{c}n-1 \\k-1 \end{array}\right]  + (n-1)  \left[\begin{array}{c}n-1 \\k \end{array}\right] \right\} x^k 
\end{eqnarray}
Therefore, $\forall n,k > 0$,
\begin{eqnarray}
\left[\begin{array}{c}n \\k \end{array}\right] = \left[\begin{array}{c}n-1 \\k-1 \end{array}\right]  + (n-1)  \left[\begin{array}{c}n-1 \\k \end{array}\right]
\end{eqnarray}
  
Therefore, an implementation is as follows:
\begin{verbatim}
> stirlingC :: Integer -> Integer -> Integer
> stirlingC 0 0 = 1
> stirlingC 0 _ = 0
> stirlingC n k = (n-1)*(stirlingC (n-1) k) + stirlingC (n-1) (k-1)
\end{verbatim}
This definition can be used to convert from falling powers to standard powers.
\begin{verbatim}
> fall2pol :: Integer -> [Integer]
> fall2pol 0 = [1]
> fall2pol n = 0 : [(stirlingC n k)*(-1)^(n-k) | k<-[1..n]]
\end{verbatim}
We use \texttt{fall2pol} to convert Newton representations to standard polynomials in coefficients list representation.
Here we have uses sum to collect same order terms in list representation.
\begin{verbatim}
> npol2pol :: (Ord t, Num t) => [t] -> [t]
> npol2pol xs = sum [ [x] * (map fromInteger $ fall2pol k)
>                   | (x,k) <- zip xs [0..]
>                   ]
\end{verbatim}
Finally, here is the function for computing a polynomial from an output sequence:
\begin{verbatim}
> list2pol :: [Integer] -> [Rational]
> list2pol = npol2pol . list2npol
\end{verbatim}
Here are some checks on these functions:
\begin{verbatim}
Reconstruction as curve fitting
  *NewtonInterpolation> list2pol $ map (\n -> 7*n^2+3*n-4) [0..100]
  [(-4) % 1,3 % 1,7 % 1]

  *NewtonInterpolation> list2pol [0,1,5,14,30]
  [0 % 1,1 % 6,1 % 2,1 % 3]
  *NewtonInterpolation> map (\n -> n%6 + n^2%2 + n^3%3) [0..4]
  [0 % 1,1 % 1,5 % 1,14 % 1,30 % 1]

  *NewtonInterpolation> map (p2fct $ list2pol [0,1,5,14,30]) [0..8]
  [0 % 1,1 % 1,5 % 1,14 % 1,30 % 1,55 % 1,91 % 1,140 % 1,204 % 1]

\end{verbatim}















\section{Univariate rational functions}
% See \url{https://rosettacode.org/wiki/Thiele%27s_interpolation_formula#Haskell}

\subsection{Thiele's interpolation formula}
Consider a univariate rational function $f(z)$.
Given a sequence of values $\left. y_n \right|_{n \in \mathbb{N}}$, we evaluate the polynomial form $f(z)$ as a continued fraction:
\begin{eqnarray}
f_0(z) &=& a_0 \\
f_1(z) &=& a_0 + \frac{(z-y_0)}{a_1} \\
\nonumber
&\vdots& \\
f_r(z) &=& a_0 + \cfrac{(z-y_0)}{a_1 + \cfrac{z-y_1}{a_2 + \cfrac{z- y_3}{\cdots + \cfrac{z-y_{r-1}}{a_r}}}},
\end{eqnarray}
where
\begin{eqnarray}
a_0 &=& f(y_0) \\
a_1 &=& \frac{y_1 - y_0}{f(y_1) - a_0}\\
\nonumber
&\vdots& \\
a_r &=& \left( \left( \left( f(y_r)-a_0 \right)^{-1} (y_r - y_0) - a_1 \right)^{-1} \frac{1}{y_r - y_1} - \cdots - a_{r-1} \right)^{-1} (y_r - y_{r-1}) \qquad\qquad
\end{eqnarray}

\subsubsection{Termination condition(s)}
We choose our termination conditions as several agreements among new reconstructed function:\footnote{
Note that, this does not simply mean
\begin{eqnarray}
a_{n} = a_{n+1} = a_{n+2} = \cdots = 0.
\end{eqnarray}
}
\begin{eqnarray}
f_{n-1}(z) \neq f_n(z) = f_{n+1}(z) = f_{n+2}(z) = \cdots.
\end{eqnarray}

\subsection{Towards canonical representations}
In order to get a unique representation of canonical form
\begin{eqnarray}
\frac{\sum_\alpha n_\alpha z^\alpha}{\sum_\beta d_\beta z^\beta}
\end{eqnarray}
we put
\begin{eqnarray}
d_{\min r'} = 1
\end{eqnarray}
as a normalization, instead of $d_0$.

\subsection{Haskell implementation}
Here we the same notion of
\begin{quotation}
\url{https://rosettacode.org/wiki/Thiele%27s_interpolation_formula}
\end{quotation}
and especially
\begin{quotation}
\url{https://rosettacode.org/wiki/Thiele%27s_interpolation_formula#C}
\end{quotation}

What we can know is the output-list of \texttt{f::Int -> Ratio Int}:
\begin{eqnarray}
\texttt{map f [0..]}
\end{eqnarray}
 
\subsubsection{Claim}
We claim, without proof, that the Thiele coefficients are given by
\begin{eqnarray}
a_0 &:=& f(0) \\
a_n &:=& \rho_{n,0} - \rho_{{n-2},0},
\end{eqnarray}
where $\rho$ is so called the reciprocal difference:
\begin{eqnarray}
\rho_{0,i} &:=& f(i), i=0,1,2,\cdots \\
\rho_{n,i} &:=& 0, n<0 \\
\rho_{n,i} &:=& \frac{n}{\rho_{{n-1},1} - \rho_{{n-1},0}} + \rho_{{n-2},1}
\end{eqnarray}

These preparation helps us to write the following codes:
\begin{verbatim}
Thiele's interpolation formula
https://rosettacode.org/wiki/Thiele%27s_interpolation_formula#Haskell
http://mathworld.wolfram.com/ThielesInterpolationFormula.html

reciprocal difference
Using the same notation of 
https://rosettacode.org/wiki/Thiele%27s_interpolation_formula#C

> rho :: [Ratio Int] -- A list of output of f :: Int -> Ratio Int
>     -> Int -> Int -> Ratio Int
> rho fs 0 i = fs !! i
> rho fs n _ 
>   | n < 0 = 0
> rho fs n i = (n*den)%num + rho fs (n-2) (i+1)
>   where
>     num  = numerator next
>     den  = denominator next
>     next = (rho fs (n-1) (i+1)) - (rho fs (n-1) i)

Note that (%) has the following type,
  (%) :: Integral a => a -> a -> Ratio a

> a fs 0 = fs !! 0
> a fs n = rho fs n 0 - rho fs (n-2) 0
\end{verbatim}
Now let us consider a simple example
\begin{eqnarray}
f(x) &:=& 1 + \cfrac{x}{2+\cfrac{x-1}{3+\cfrac{x-2}{4}}} \\
&=& \frac{x^2+16x+16}{16+6x}
\end{eqnarray}
Using Maxima, we can verify this:
\begin{verbatim}
  (%i25) f(x) := 1+(x/(2+(x-1)/(3+(x-2)/4)));
  (%o25) f(x):=x/(2+(x-1)/(3+(x-2)/4))+1
  (%i26) ratsimp(f(x));
  (%o26) (x^2+16*x+16)/(16+6*x)
\end{verbatim}
Let us try to get the Thiele coefficients of
\begin{verbatim}
> func x = (x^2 + 16*x + 16)%(6*x + 16)

  *Univariate> map (a fs) [0..]
  [1 % 1,2 % 1,3 % 1,4 % 1,*** Exception: Ratio has zero denominator
\end{verbatim}
This is clearly unsafe, so let us think more carefully.
Observe the reciprocal differences
\begin{verbatim}
  *Univariate> let fs = map func [0..]
  *Univariate> take 5 $ map (rho fs 0) [0..]
  [1 % 1,3 % 2,13 % 7,73 % 34,12 % 5]
  *Univariate> take 5 $ map (rho fs 1) [0..]
  [2 % 1,14 % 5,238 % 69,170 % 43,230 % 53]
  *Univariate> take 5 $ map (rho fs 2) [0..]
  [4 % 1,79 % 16,269 % 44,667 % 88,413 % 44]
  *Univariate> take 5 $ map (rho fs 3) [0..]
  [6 % 1,6 % 1,6 % 1,6 % 1,6 % 1]
\end{verbatim}
So, the constancy of the reciprocal differences can be used to get the depth of Thiele series:
\begin{verbatim}
> tDegree :: [Ratio Int] -> Int
> tDegree fs = helper fs 0
>   where
>     helper fs n
>       | isConstants fs' = n
>       | otherwise       = helper fs (n+1)
>       where
>         fs' = map (rho fs n) [0..]
>     isConstants (i:j:_) = i==j -- 2 times match
> --  isConstants (i:j:k:_) = i==j && j==k
\end{verbatim}
Using this \verb+tDegree+ function, we can safely take the (finite) Thiele sequence.

\subsubsection{Example}
From the equation (3.26) of ref.\ref{Tiziano},
\begin{verbatim}
  *Univariate> let h t = (3+6*t+18*t^2)%(1+2*t+20*t^2)
  *Univariate> let hs = map h [0..]
  *Univariate> tDegree hs
  4
\end{verbatim}
So we get the Thiele coefficients
\begin{verbatim}  
  *Univariate> map (a hs) [0..(tDegree hs)]
  [3 % 1,(-23) % 42,(-28) % 13,767 % 14,7 % 130]
\end{verbatim}
Plug these in the continued fraction, and simplify with Maxima
\begin{verbatim}
  (%i35) h(t) := 3+t/((-23/42)+(t-1)/((-28/13)+(t-2)/((767/14)+(t-3)/(7/130))));
  (%o35) h(t):=t/((-23)/42+(t-1)/((-28)/13+(t-2)/(767/14+(t-3)/(7/130))))+3
  (%i36) ratsimp(h(t));
  (%o36) (18*t^2+6*t+3)/(1+2*t+20*t^2)
\end{verbatim}
Finally we make a function \verb+thieleC+ that returns the Thiele coefficients:
\begin{verbatim}
> thieleC :: [Ratio Int] -> [Ratio Int]
> thieleC lst = map (a lst) [0..(tDegree lst)]

  *Univariate> thieleC hs
  [3 % 1,(-23) % 42,(-28) % 13,767 % 14,7 % 130]
\end{verbatim}

We need a convertor from this thiele sequence to continuous form of rational function.
\begin{verbatim}
> nextStep [a0,a1] (v:_)  = a0 + v/a1
> nextStep (a:as)  (v:vs) = a + (v / nextStep as vs)
>
> thiele' :: Integral a => [Ratio a] -> Ratio a -> Ratio a
> thiele' fs x
>   | x == 0 = a0
>   | otherwise = nextStep as [x,x-1 ..]
>   where
>     a0 = head as
>     as = thieleC fs

  *Univariate> let h t = (3+6*t+18*t^2)%(1+2*t+20*t^2)
  *Univariate> let hs = map h [0..]
  *Univariate> let th x = thiele' hs x
  *Univariate> h 0.1

  <interactive>:28:1: error:
      ? Ambiguous type variable ?a0? arising from a use of ?it?
        prevents the constraint ?(Fractional a0)? from being solved.
        Probable fix: use a type annotation to specify what ?a0? should be.
        These potential instances exist:
          instance Integral a => Fractional (Ratio a)
            -- Defined in ?GHC.Real?
          instance Fractional Double -- Defined in ?GHC.Float?
        instance Fractional Float -- Defined in ?GHC.Float?
      ? In the first argument of ?print?, namely ?it?
        In a stmt of an interactive GHCi command: print it
  *Univariate> th 0.1
  27 % 10 
\end{verbatim}

\subsubsection{Haskell representation for rational functions}
We represent a rational function by a tuple of coefficient lists, say,
\begin{eqnarray}
\texttt{(ns,ds) :: ([Ratio Int],[Ratio Int])}
\end{eqnarray}

Here is a translator from coefficients lists to rational function.
\begin{verbatim}
> lists2ratf :: (Integral a) => ([Ratio a],[Ratio a]) -> (Ratio a -> Ratio a)
> lists2ratf (ns,ds) x = (p2fct ns x)/(p2fct ds x)

  *Univariate> let frac x = lists2ratf ([1,1%2,1%3],[2,2%3]) x
  *Univariate> take 10 $ map frac [0..]
  [1 % 2,11 % 16,1 % 1,11 % 8,25 % 14,71 % 32,8 % 3,25 % 8,79 % 22,65 % 16]
  *Univariate> let ffrac x = (1+(1%2)*x+(1%3)*x^2)/(2+(2%3)*x)
  *Univariate> take 10 $ map ffrac [0..]
  [1 % 2,11 % 16,1 % 1,11 % 8,25 % 14,71 % 32,8 % 3,25 % 8,79 % 22,65 % 16]  
\end{verbatim}

The following \texttt{canonicalizer} reduces the tuple-rep of rational function in canonical form, i.e., the coefficient of the lowest degree term of the denominator to be 1.
\begin{verbatim}
> canonicalizer :: (Integral a) => ([Ratio a],[Ratio a]) -> ([Ratio a],[Ratio a])
> canonicalizer rat@(ns,ds)
>   | dMin == 1 = rat
>   | otherwise = (map (/dMin) ns, map (/dMin) ds)
>   where
>     dMin = firstNonzero ds
>     firstNonzero [a] = a
>     firstNonzero (a:as)
>       | a /= 0 = a
>       | otherwise = firstNonzero as

  *Univariate> canonicalizer ([1,1%2,1%3],[2,2%3])
  ([1 % 2,1 % 4,1 % 6],[1 % 1,1 % 3])
  *Univariate> canonicalizer ([1,1%2,1%3],[0,0,2,2%3])
  ([1 % 2,1 % 4,1 % 6],[0 % 1,0 % 1,1 % 1,1 % 3])
  *Univariate> :e
  [1 of 1] Compiling Univariate       ( Univariate.lhs, interpreted )
  Ok, modules loaded: Univariate.
  *Univariate> canonicalizer ([1,1%2,1%3],[0,0,0,2%3])
  ([3 % 2,3 % 4,1 % 2],[0 % 1,0 % 1,0 % 1,1 % 1])
\end{verbatim}

What we need is a translator from Thiele coefficients to this tuple-rep.






\section{Multivariate polynomials}

\subsection{Foldings as recursive applications}
Consider an arbitrary multivariate polynomial
\begin{eqnarray}
f(z_1,\cdots, z_n) \in \mathbb{F}[z_1,\cdots, z_n].
\end{eqnarray}
First, fix all the variable but 1st and apply the univariate Newton's reconstruction:
\begin{eqnarray}
f(z_1, z_2, \cdots, z_n) = \sum_{r=0}^R a_r (z_2,\cdots, z_n) \prod_{i=0}^{r-1}(z_1 - y_i)
\end{eqnarray}
Recursively, pick up one "coefficient" and apply the univariate Newton's reconstruction on $z_2$:
\begin{eqnarray}
a_r(z_2, \cdots, z_n) = \sum_{s=0}^{S} b_s (z_3,\cdots, z_n) \prod_{j=0}^{s-1}(z_2 - x_j)
\end{eqnarray}
The terminate cotndition should be the univariate case.

\section{Multivariate rational functions}
\subsection{The canonical normalization}
Our target is a pair of coefficients $(\{ n_\alpha\}_\alpha, \{ d_\beta\}_\beta)$ in
\begin{eqnarray}
\frac{\sum_\alpha n_\alpha z^\alpha}{\sum_\beta d_\beta z^\beta}
\end{eqnarray}
A canonical choice is
\begin{eqnarray}
d_0 = d_{(0,\cdots,0)} = 1.
\end{eqnarray}
Accidentally we might face $d_0 = 0$, but we can shift our function and make
\begin{eqnarray}
d'_0 = d_{s} \neq 0.
\end{eqnarray}

\subsection{An auxiliary $t$}
Introducing an auxiliary variable $t$, let us define
\begin{eqnarray}
h(t,z) := f(tz_1, \cdots, tz_n),
\end{eqnarray}
and reconstruct $h(t,z)$ as a univariate rational function of $t$:
\begin{eqnarray}
h(t,z) = \frac{\sum_{r=0}^R p_r(z) t^r}{1+ \sum_{r'=1}^{R'} q_{r'}(z) t^{r'}}
\end{eqnarray}
where
\begin{eqnarray}
p_r(z) &=& \sum_{|\alpha| = r} n_\alpha z^\alpha \\
q_{r'}(z) &=& \sum_{|\beta| = r'} n_\beta z^\beta
\end{eqnarray}
are homogeneous polynomials.

Thus, what we shall do is the (homogeneous) polynomial reconstructions of $\left. p_r(z) \right|_{0 \leq r \leq R}, \left. q_{r'} \right|_{1 \leq r' \leq R'}$.

\subsubsection{A simplification}
Since our new targets are homogeneous polynomials, we can consider, say,
\begin{eqnarray}
p_r(1, z_2, \cdots, z_n)
\end{eqnarray}
instead of $p_r(z_1, z_2, \cdots, z_n)$, reconstruct it using multivariate Newton's method, and homogenize with $z_1$.




\end{document}
